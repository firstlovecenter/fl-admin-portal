type Member {
	id: ID! 
	firstName: String
	middleName: String
	lastName: String
	email: String
	phoneNumber: String
	whatsappNumber: String 
	pictureUrl: String
	gender: Gender  @relation(name: "HAS_GENDER", direction: "OUT")
	maritalStatus: MaritalStatus @relation(name: "HAS_MARITAL_STATUS", direction: "OUT")
	dob: TimeGraph @relation(name: "WAS_BORN_ON", direction: "OUT")
	title: [HasTitle]
	ministry: Ministry @relation(name: "BELONGS_TO", direction: "OUT")
	occupation: Occupation @relation(name: "HAS_OCCUPATION", direction: "OUT")
	bacenta: Bacenta @relation(name: "BELONGS_TO", direction: "OUT")
	leadsBacenta: [Bacenta] @relation(name: "LEADS", direction: "OUT")
	leadsCentre: [Centre] @relation(name: "LEADS", direction: "OUT")
	leadsMinistry: [Ministry] @relation(name: "LEADS", direction: "OUT")
	leadsSonta: [Sonta] @relation(name: "LEADS", direction: "OUT")
	townGSO: [Town] @relation(name: "LEADS", direction: "OUT")
	campusGSO: [Campus] @relation(name: "LEADS", direction: "OUT")
	leadershipHistory: [LeaderHistory] @relation(name:"HAS_LEADERSHIP_HISTORY",direction:"OUT")
	townBishop: [Town] @relation(name: "HAS_TOWN", direction: "OUT")
	campusBishop: [Campus] @relation(name: "HAS_CAMPUS", direction: "OUT")
}

type Gender {
	gender: String
	members: [Member] @relation(name: "HAS_GENDER", direction: "IN")
}

type MaritalStatus {
	status: String
	members: [Member] @relation(name: "HAS_MARITAL_STATUS", direction: "IN")
}

type Occupation {
	occupation: String
	members: [Member] @relation(name: "HAS_OCCUPATION", direction: "IN")
}

type Title {
	title: String! #Pastor, Reverend, Apostle, Bishop (Mother)
	members: [HasTitle]
}

type HasTitle @relation(name: "HAS_TITLE") {
  from: Member
  to: Title
  yearAppointed: Date
  status: String #active or inactive
  numberofTimesRemoved: Int
}

type TimeGraph {
	date: Date
	memberDob: Member @relation(name: "WAS_BORN_ON", direction: "IN")
	# titleAppointmentDate: Member @relation(name: "APPOINTED_ON", direction: "IN")
	leaderHistoryStartDate: TimeGraph @relation(name: "LEADER_STARTED_ON", direction: "OUT")
	leaderHistoryEndDate: TimeGraph @relation(name: "LEADER_ENDED_ON", direction: "OUT")
	bacentaHistoryStartDate: TimeGraph @relation(name: "BACENTA_STARTED_ON", direction: "OUT")
	bacentaHistoryEndDate: TimeGraph @relation(name: "BACENTA_ENDED_ON", direction: "OUT")
	serviceDate: [BacentaServiceRecords] @relation (name: "SERVICE_DATE", direction:"IN")
}
type LeaderHistory {
	created_at: DateTime
	historyRecord: String
	historyStartDate: TimeGraph @relation(name: "LEADER_STARTED_ON", direction: "OUT")
	historyEndDate: TimeGraph @relation(name: "LEADER_ENDED_ON", direction: "OUT")
	leaders: Member @relation(name:"HAS_LEADERSHIP_HISTORY",direction:"IN")
	bacentaerviceRecords: [BacentaServiceRecords] @relation(name:"HAS_SERVICE_RECORDS",direction:"OUT")
}

type BacentaServiceRecords {
	created_at: DateTime
	bacenta: Bacenta @relation (name:"HAS_SERVICE_RECORDS",direction:"IN")
	serviceDate: TimeGraph @relation (name: "SERVICE_DATE", direction:"OUT")
	attendance: Int
	income: Float
	treasurer1ID: String
	treasurer2ID: String
	leaderHistory: LeaderHistory @relation(name:"HAS_SERVICE_RECORDS",direction:"IN")
}

type BacentaHistory {
	created_at: DateTime
	historyRecord: String #leader was transferred to
	historyStartDate: TimeGraph @relation(name: "BACENTA_STARTED_ON", direction: "OUT")
	historyEndDate: TimeGraph @relation(name: "BACENTA_ENDED_ON", direction: "OUT")
	Bacenta: Bacenta @relation(name:"HAS_BACENTA_HISTORY",direction:"IN")
}

# Campus-Centre, Town-Centre
type Campus {
	id: ID
	name: String
	leader: Member @relation(name: "LEADS", direction: "IN")
	sontas: [Sonta] @relation(name: "HAS_SONTA", direction: "OUT")
	centres: [Centre] @relation(name: "HAS_CENTRE", direction: "OUT")
	bishop: Member @relation (name:"HAS_CAMPUS",direction: "IN")
}


type Town {
	id: ID
	name: String
	leader: Member @relation(name: "LEADS", direction: "IN")
	sontas: [Sonta] @relation(name: "HAS_SONTA", direction: "OUT")
	centres: [Centre] @relation(name: "HAS_CENTRE", direction: "OUT")
	bishop: Member @relation (name:"HAS_TOWN", direction: "IN")
}

type Centre {
	id: ID
	name: String
	leader: Member @relation(name: "LEADS", direction: "IN")
	bacentas: [Bacenta] @relation(name:"HAS_BACENTA", direction:"OUT")
	basontas: Basonta @relation(name:"HAS_BASONTA", direction: "OUT")
	town: Town @relation(name: "HAS_CENTRE", direction: "IN")
	campus: Campus @relation(name: "HAS_CENTRE",direction:"IN")
}

# Shared Units: Bacenta, Bacenta, Sonta
type Bacenta {
	id: ID
	name: String
	centre: Centre @relation(name: "HAS_BACENTA", direction: "IN")
	location: Point
	leader: Member @relation(name: "LEADS", direction: "IN")
	members: [Member] @relation(name: "BELONGS_TO", direction: "IN")
	meetingDay: ServiceDay @relation(name:"MEETS_ON_DAY", direction: "OUT")
	serviceRecords: BacentaServiceRecords @relation (name:"HAS_SERVICE_RECORDS",direction:"OUT")
}

type ServiceDay {
	day: String!
	bacenta: Bacenta @relation(name: "MEETS_ON_DAY", direction: "IN")
}

type Ministry {
	id: ID
	name: String
	sonta: [Sonta] @relation(name:"HAS_SONTA", direction:"OUT")
	leader: Member @relation(name: "LEADS", direction: "IN")
	members: [Member] @relation(name: "BELONGS_TO", direction: "IN")
}

type Sonta {
	id: ID
	name: String
	leader: Member @relation(name: "LEADS", direction: "IN")
	basonta: [Basonta] @relation(name:"HAS_BASONTA", direction:"OUT")
	ministry: Ministry @relation(name:"HAS_SONTA", direction:"IN")
	town: Town @relation(name: "HAS_SONTA", direction: "IN")
	campus: [Campus] @relation(name: "HAS_SONTA", direction: "IN")
}
type Basonta {
	basontaID: ID
	name: String
	leader: Member @relation(name: "LEADS", direction: "IN")
	centre: Centre @relation(name: "HAS_BASONTA", direction: "IN")
}

#Custom input types
input pastoralAppointment {
	title: String
	date: String
}

input pastoralHistory {
    historyRecord: String
    historyDate: String
}

enum Role {
  superadmin
  user
  admin
}

#Query Definitions
type Query {

#At the Federal Level
	bishopsList: [Member] @isAuthenticated @cypher(statement:"MATCH ()<-[:HAS_CAMPUS|:HAS_TOWN]-(m:Member) RETURN DISTINCT m")
	bishopsListCampus: [Member] @cypher(statement:"MATCH ()<-[:HAS_CAMPUS]-(m:Member) RETURN DISTINCT m")
	bishopsListTown: [Member] @cypher(statement:"MATCH ()<-[:HAS_TOWN]-(m:Member) RETURN DISTINCT m")
	ministryList: [Ministry] @cypher (statement:"MATCH (m:Ministry) RETURN m")
	memberCount: Int! @cypher(statement: "MATCH (m:Member) RETURN COUNT(m)")
	centreCount: Int! @cypher(statement: "MATCH (b:Centre) RETURN COUNT(c)")
	bacentaCount: Int! @cypher(statement: "MATCH (b:Bacenta) RETURN COUNT(b)")

#At the Episcopal Level
	bishopsCampusTownCount(id: ID): Int! @cypher(statement: "MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->(t) RETURN COUNT(t)")
	bishopBacentaDropdown (id: ID, bacentaName:String):[Bacenta] @cypher(statement: "MATCH (b:Bacenta)<-[]-(:Centre)<-[:HAS_CENTRE]-()<-[:HAS_TOWN|:HAS_CAMPUS]-(:Member {id: $id}) WHERE toLower(b.name) CONTAINS toLower($bacentaName) RETURN b")
	bishopsSontaMemberList(id: ID): [Member]! @cypher(statement: 
		"""
		MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->()-[:HAS_CENTRE]->()-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(m:Member)-[:BELONGS_TO]->(s)
		RETURN m
		"""
		)
	bishopSontaMemberCount(id: ID): Int! @cypher(statement: 
		"""
		MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->()-[:HAS_CENTRE]->()-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(m:Member)-[:BELONGS_TO]->(s)
		RETURN COUNT(m)
		"""
		)
	bishopSontaMemberCountList(bishopId: ID): [Ministry]! @cypher(statement: 
		"""
		MATCH (:Member {id: $bishopId})-[:HAS_TOWN|:HAS_CAMPUS]->()-[:HAS_CENTRE]->()-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(m:Member)-[:BELONGS_TO]->(s:Ministry)
		RETURN s, COUNT(m)
		"""
		)
	bishopPastorCount(id: ID): Int! @cypher(statement: "MATCH (t:Title)<-[:HAS_TITLE]-(m:Member)-[:BELONGS_TO]->()<-[:HAS_BACENTA]-()-[:HAS_CENTRE]-()-[:HAS_TOWN|:HAS_CAMPUS]-(:Member {id: $id}) RETURN COUNT(m)")
	bishopPastorList(id: ID): [Member] @cypher(statement: "MATCH (t:Title)<-[:HAS_TITLE]-(m:Member)-[:BELONGS_TO]->()<-[:HAS_BACENTA]-()-[:HAS_CENTRE]-()-[:HAS_TOWN|:HAS_CAMPUS]-(:Member {id: $id}) RETURN m")
	bishopMemberList(id: ID): [Member]! @cypher(statement: 
		"""
		MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->(t)
		MATCH (t)-[:HAS_CENTRE]->(com)
		MATCH (com)-[:HAS_BACENTA]->(c)
		MATCH (c)<-[:BELONGS_TO*]-(m:Member)
		RETURN m
		"""
		)
	bishopMemberCount(id: ID): Int! @cypher(statement: 
		"""
		MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->(t)
		MATCH (t)-[:HAS_CENTRE]->(com)
		MATCH (com)-[:HAS_BACENTA]->(c)
		MATCH (c)<-[:BELONGS_TO*]-(m:Member)
		RETURN COUNT(m)
		"""
		)

#At the Town Level
	displayTown(id: ID):Town @cypher(statement: "MATCH (t:Town {id:$id}) RETURN t")
	townList(id: ID): [Town] @cypher(statement: "MATCH (ttl:Title {title:'Bishop'})<-[:HAS_TITLE]-(a:Member {id:$id})-[:HAS_TOWN]->(t:Town) RETURN t")
	townBacentaList(id:ID):[Bacenta] @cypher(statement: "MATCH (t:Town {id: $id})-[:HAS_CENTRE]->(:Centre)-[:HAS_BACENTA]-> (c:Bacenta) RETURN c")
	townSontaList (id:ID):[Sonta] @cypher(statement: "MATCH (t:Town {id: $id})-[:HAS_SONTA]->(s:Sonta)  RETURN s")
	townCentreList(id: ID): [Centre] @cypher(statement: "MATCH (t:Town {id:$id})-[:HAS_CENTRE]->(c:Centre) RETURN c")
	townCentreCount(id: ID): Int! @cypher(statement: "MATCH(:Town {id:$id})-[:HAS_CENTRE]->(c:Centre) RETURN COUNT(c)")
	townBacentaCount(id: ID): Int! @cypher(statement: "MATCH (:Town {id:$id})-[]-()-[:HAS_BACENTA]->(cen:Bacenta) RETURN COUNT(cen)")
	townSontaCount(id: ID): Int! @cypher(statement: "MATCH (:Town {id:$id})-[:HAS_SONTA]->(s:Sonta) RETURN COUNT(s)")
	townMemberCount(id: ID): Int! @cypher(statement: "MATCH (:Town {id:$id})-[]-(:Centre)-[]->(:Bacenta)<-[:BELONGS_TO]-(m:Member) RETURN COUNT(m)")
	townSontaMemberCount(id: ID): Int! @cypher(statement: "MATCH (:Town {id: $id})-[]-(:Centre)-[]->(:Bacenta)<-[:BELONGS_TO]-(m:Member) MATCH (m)-[:BELONGS_TO]->(:Ministry) RETURN COUNT(m)")

#At the Campus Level
	displayCampus(id: ID):Campus @cypher(statement: "MATCH (t:Campus {id:$id}) RETURN t")
	campusList(id: ID): [Campus] @cypher(statement: "MATCH (ttl:Title {title:'Bishop'})<-[:HAS_TITLE]-(a:Member {id:$id})-[:HAS_CAMPUS]->(c:Campus) RETURN c")
	campusBacentaList(id:ID):[Bacenta] @cypher(statement: "MATCH (t:Campus {id: $id})-[:HAS_CENTRE]->(:Centre)-[:HAS_BACENTA]-> (c:Bacenta) RETURN c")
	campusSontaList (id:ID):[Sonta] @cypher(statement: "MATCH (t:Campus {id: $id})-[:HAS_SONTA]->(s:Sonta)  RETURN s")
	campusCentreList(id: ID): [Centre] @cypher(statement: "MATCH (t:Campus {id:$id})-[:HAS_CENTRE]->(c:Centre) RETURN c")
	campusCentreCount(id: ID): Int! @cypher(statement: "MATCH(:Campus {id:$id})-[:HAS_CENTRE]->(c:Centre) RETURN COUNT(c)")
	campusBacentaCount(id: ID): Int! @cypher(statement: "MATCH (:Campus {id:$id})-[]-()-[:HAS_BACENTA]->(cen:Bacenta) RETURN COUNT(cen)")
	campusSontaCount(id: ID): Int! @cypher(statement: "MATCH (:Campus {id:$id})-[:HAS_MINISTRY]->(s:Sonta) RETURN COUNT(s)")
	campusMemberCount(id: ID): Int! @cypher(statement: "MATCH (:Campus {id:$id})-[]-(:Centre)-[]->(:Bacenta)<-[:BELONGS_TO]-(m:Member) RETURN COUNT(m)")

#At the Centre Level
	displayCentre(id: ID):Centre @cypher(statement: "MATCH (c:Centre {id:$id}) RETURN c")
	centreDropdown (centreName:String):[Centre] @cypher(statement: "MATCH (c:Centre) WHERE toLower(c.name) CONTAINS toLower($centreName) RETURN c")
	centreBacentaList(id:ID):[Bacenta] @cypher(statement: """
	MATCH (c:Bacenta)  
	WHERE (:Centre {id:$id})-[:HAS_BACENTA]->(c)
	RETURN c
	"""
	)
	centreBacentaCount(id: ID): Int! @cypher(statement: "MATCH (:Centre {id:$id})-[:HAS_BACENTA]->(cen:Bacenta) RETURN COUNT(cen)")
	centreSontaCount(id: ID): Int! @cypher(statement: "MATCH (s:Sonta)<-[:HAS_MINISTRY]-(:Centre {name:$centre}) RETURN COUNT(s)")
	centreMemberCount(id: ID): Int! @cypher(statement: "MATCH (:Centre {id:$id})-[:HAS_BACENTA]->(c:Bacenta)<-[:BELONGS_TO]-(m:Member) RETURN COUNT(m)")

#At the Bacenta Level
	displayBacenta(id: ID):Bacenta @cypher(statement: "MATCH (c:Bacenta{id:$id}) RETURN c")
	bacentaMemberCount (id:ID):Int @cypher(statement: "MATCH (c:Bacenta{id:$id}) MATCH (c)<-[:BELONGS_TO]-(m:Member) RETURN COUNT(m)")
	bacentaDropdown (bacentaName:String):[Bacenta] @cypher(statement: "MATCH (c:Bacenta) WHERE toLower(c.name) CONTAINS toLower($bacentaName) RETURN c")

#At the Ministry Level
	displayMinistry(id: ID):Ministry @cypher(statement:"MATCH (m:Ministry {id: $id}) RETURN m")
	sontaTownList(bishopId: ID, ministryId: ID): [Town] @cypher(statement: 
	"""
	MATCH (n:Ministry {id: $ministryId})<-[:BELONGS_TO]-(m:Member)
	MATCH (m)-[:BELONGS_TO]->(:Bacenta)<-[:HAS_BACENTA]-()<-[:HAS_CENTRE]-(e)
	MATCH (e)<-[:HAS_TOWN|HAS_CAMPUS]-(:Member {id: $bishopId})
	RETURN DISTINCT e,n
	"""
	)


#At the Sonta Level
	sontaList:[Sonta] @cypher(statement: "MATCH (s:Sonta) RETURN s")
	townSontaLeader(bishopId: ID): [Member] @cypher (statement:"""
	MATCH (n:Ministry)<-[:BELONGS_TO]-(m:Member)
	MATCH (m)-[:BELONGS_TO]->(:Bacenta)<-[:HAS_BACENTA]-()<-[:HAS_CENTRE]-(e)
	MATCH (e)<-[:HAS_TOWN|HAS_CAMPUS]-(:Member {id: $bishopId})
	MATCH (n)-[:HAS_SONTA]->(s:Sonta {id:$sontaId})<-[:LEADS]-(l:Member)
	WHERE s.name CONTAINS e.name
    RETURN DISTINCT l
	"""
	)

#Members
	# Display Member basecd on ID
	displayMember(id: ID):Member @cypher(statement: "MATCH (m:Member {id:$id}) RETURN m")
	memberByEmail(email: String):Member @cypher(statement:"MATCH (m:Member {email:$email}) RETURN m")

#Fuzzy Search
	globalSearch(searchKey:String!):[Member] @cypher(statement:"""
	MATCH (m:Member) 
	WHERE toLower(m.firstName) STARTS WITH toLower($searchKey) 
	OR toLower(m.lastName) STARTS WITH toLower($searchKey) 
	OR toLower(m.firstName) CONTAINS toLower($searchKey) 
	OR toLower(m.lastName) CONTAINS toLower($searchKey) 
	RETURN m
	"""
	)
	occupationList(searchKey:String!):[Occupation] @cypher(statement:"MATCH (o:Occupation) WHERE toLower(o.occupation) CONTAINS toLower($searchKey) RETURN o")

#Filtering
	FilterMembers(
		gender: String
		maritalStatus: String
		occupation: String
		yearAppointed: Int
		title: String
		age: Int
	):Member
	@cypher(statement:
	"""
	MATCH (m:Member)-[:HAS_GENDER]->(g:Gender {gender: $gender})
	WHERE EXISTS {
    MATCH (:MaritalStatus {status:$maritalStatus})<-[:HAS_MARITAL_STATUS]-(m)-[:HAS_OCCUPATION]->(:Occupation {occupation:$occupation}) 
    	WHERE EXISTS {
        MATCH (t:Title{title:$title})<-[tit:HAS_TITLE]-(m) 
        WHERE date(tit.yearAppointed).year = $yearAppointed
        } WHERE EXISTS
			{
				MATCH (m)-[:WAS_BORN_ON]->(dob:TimeGraph)
				WHERE date().year - date(dob.date).year = $age
			}
    }
    RETURN m
	"""
	)
}

#Mutation Definitions
type Mutation {

	#CREATE OPERATIONS
	# Add Member to the Database
	CreateMember(
		firstName: String!
		middleName: String
		lastName: String!
		email: String
		phoneNumber: String!
		whatsappNumber: String
		dob: String!
		maritalStatus: String!
		gender: String!
		occupation: String
		bacenta: String!
		ministry: String
		pictureUrl: String!
		pastoralAppointment: [pastoralAppointment]
		pastoralHistory: [pastoralHistory]
	): Member
	@cypher(statement:
	"""
	CREATE (m:Member {whatsappNumber:$whatsappNumber})
	SET
		m.id = apoc.create.uuid(),
		m.firstName = $firstName,
		m.middleName = $middleName,
		m.lastName = $lastName,
		m.email = $email,
		m.phoneNumber = $phoneNumber,
		m.pictureUrl = $pictureUrl

	WITH m
	MATCH (ms:MaritalStatus {status:$maritalStatus})
	MATCH (g:Gender {gender: $gender})
		
    MERGE (m)-[:HAS_MARITAL_STATUS]-> (ms)
	MERGE (m)-[:HAS_GENDER]-> (g)
    
	WITH m	
    CALL {
    	WITH m
    	WITH m  WHERE $dob IS NOT NULL
    	MERGE (t:TimeGraph {date: date($dob)})
		MERGE (m)-[:WAS_BORN_ON]->(t)
    	RETURN count(m)
    	}
    
	WITH m
    CALL {
    	WITH m
    	WITH m  WHERE $occupation IS NOT NULL
    	MERGE (o:Occupation {occupation:$occupation})
		MERGE (m)-[:HAS_OCCUPATION]-> (o)
    	RETURN count(m)
    	}
	WITH m
	CALL {
    	WITH m
    	WITH m  WHERE $bacenta IS NOT NULL
    	MATCH (c:Bacenta {id: $bacenta})
		MERGE (m)-[:BELONGS_TO]-> (c)
    	RETURN count(m)
    	}
	WITH m
	CALL {
    	WITH m
    	WITH m  WHERE $ministry IS NOT NULL
    	MATCH (s:Ministry {id:$ministry})
		MERGE (m)-[:BELONGS_TO]-> (s)
    	RETURN count(m)
    	}
   
	RETURN m
	"""
	),
	CreateLeaderTitle(
		id: ID!
		pastoralAppointment: [pastoralAppointment]
	):Title
	@cypher(statement:
	"""
	MATCH (member:Member {id: $id})
	UNWIND $pastoralAppointment as x
	MERGE (t:Title {title: x.title})
	MERGE (member)-[r:HAS_TITLE]->(t)
		SET r.yearAppointed = date(x.date)
	RETURN t
	"""
	),
	AddLeaderHistory(
		id: ID
		pastoralHistory: [pastoralHistory]
	):LeaderHistory
	@cypher(statement:
	"""
	UNWIND $pastoralHistory as x
	CREATE (h:LeaderHistory)
		SET
		h.historyRecord = x.historyRecord,
		h.created_at = datetime()
	with h
	MATCH (l:Member {id: $id})
	MERGE (tg:TimeGraph {date: date(x.historyDate)})
	MERGE (h)-[:LEADER_STARTED_ON]->(tg)
	MERGE (l)-[:HAS_LEADERSHIP_HISTORY]->(h) 
	RETURN h
	"""
	),
	CreateTown(
		townName: String
		lWhatsappNumber: String
		id: ID
		centres:[ID]
	):Town
	@cypher(statement:
	"""
	CREATE (t:Town {name:$townName})
    	SET 
		t.id = apoc.create.uuid()
	WITH t
	MATCH (m:Member {whatsappNumber: $lWhatsappNumber})
	MERGE (m)-[:LEADS]->(t)
	MERGE (a:Member {id: $id})
	MERGE (a)-[:HAS_TOWN]->(t)

	WITH t
    CALL {
    	WITH t
    	WITH t  WHERE $centres IS NOT NULL
    	UNWIND $centres AS x
        MATCH (c:Centre {id:x})
        OPTIONAL MATCH (t1)-[r:HAS_CENTRE]->(c)
        DELETE r
        MERGE (t)-[:HAS_CENTRE]->(c)
    	RETURN count(t)
    	}

	RETURN t
	"""
	),
	CreateCampus(
		campusName: String
		lWhatsappNumber: String
		id: ID
		centres:[ID]
	):Campus
	@cypher(statement:
	"""
	CREATE (t:Campus {name:$campusName})
    	SET 
		t.id = apoc.create.uuid()
	WITH t
	MATCH (m:Member {whatsappNumber: $lWhatsappNumber})
	MERGE (m)-[:LEADS]->(t)
	MERGE (a:Member {id: $id})
	MERGE (a)-[:HAS_CAMPUS]->(t)

	WITH t
    CALL {
    	WITH t
    	WITH t  WHERE $centres IS NOT NULL
    	UNWIND $centres AS x
        MATCH (c:Centre {id:x})
        OPTIONAL MATCH (t1)-[r:HAS_CENTRE]->(c)
        DELETE r
        MERGE (t)-[:HAS_CENTRE]->(c)
    	RETURN count(t)
    	}

	RETURN t
	"""
	),
	CreateCentre(
		centreName: String
		lWhatsappNumber: String
		townCampusId: ID
		bacentas:[ID]
	):Centre
	@cypher(statement:
	"""
	CREATE (c:Centre {name:$centreName})
    	SET 
		c.id = apoc.create.uuid()
	WITH c
	MATCH (m:Member {whatsappNumber: $lWhatsappNumber})
	MATCH (t {id:$townCampusId})-[:HAS_TOWN|:HAS_CAMPUS]-()
	MERGE (t)-[:HAS_CENTRE]->(c)
	MERGE (m)-[:LEADS]->(c)

	WITH c
    CALL {
        WITH c
        WITH c  WHERE $bacentas IS NOT NULL
        UNWIND $bacentas AS x
        MATCH (b:Bacenta {id:x})
        OPTIONAL MATCH (c1)-[r:HAS_BACENTA]->(b)
        DELETE r
        MERGE (c)-[:HAS_BACENTA]->(b)
        RETURN count(c)
        }

	RETURN c
	"""
	),
	CreateBacenta(
		bacentaName: String!
		lWhatsappNumber: String
		centreId: ID
		meetingDay: String!
		venueLongitude: Float
		venueLatitude: Float
	):Bacenta
	@cypher(statement:
	"""
	CREATE (b:Bacenta {name:$bacentaName,location: point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})})
    	SET
		b.id = apoc.create.uuid()
    WITH b
	MATCH (m:Member {whatsappNumber: $lWhatsappNumber}) 
	MATCH (c:Centre {id: $centreId})
    MERGE (md:ServiceDay {day: $meetingDay})
	MERGE (c)-[:HAS_BACENTA]->(b)
    MERGE (b)-[:MEETS_ON_DAY]->(md)
	MERGE (m)-[:LEADS]->(b)
    RETURN b
	"""
	),


	#UPDATE OPERATIONS
	UpdateMemberDetails(
		id: ID!
		firstName: String!
		middleName: String
		lastName: String!
		email: String
		phoneNumber: String!
		whatsappNumber: String
		dob: String
		maritalStatus: String!
		gender: String!
		occupation: String
		bacenta: String
		ministry: String
		pictureUrl: String!
		pastoralAppointment: [pastoralAppointment]
		pastoralHistory: [pastoralHistory]
	): Member
	@cypher(statement:
	"""
	MATCH (m:Member {id:$id})
	SET
		m.firstName = $firstName,
		m.middleName = $middleName,
		m.lastName = $lastName,
		m.email = $email,
		m.phoneNumber = $phoneNumber,
		m.pictureUrl = $pictureUrl

	WITH m
	
	MATCH (g:Gender {gender: $gender})	
	MERGE (m)-[:HAS_GENDER]-> (g)
    
    
	WITH m
    CALL {
    	WITH m
    	WITH m  WHERE $dob IS NOT NULL
    	MERGE (t:TimeGraph {date: date($dob)})
		WITH m,t
		OPTIONAL MATCH (m)-[r1:WAS_BORN_ON]->()
		DELETE r1
		MERGE (m)-[:WAS_BORN_ON]->(t)
    	RETURN count(m)
    	}

	WITH m
    CALL {
    	WITH m
    	WITH m  WHERE $maritalStatus IS NOT NULL
    	MATCH (ms:MaritalStatus {status:$maritalStatus})
		OPTIONAL MATCH (m)-[r1:HAS_MARITAL_STATUS]->()
		DELETE r1
		MERGE (m)-[:HAS_MARITAL_STATUS]-> (ms)
    	RETURN count(m)
    	}

    WITH m
    CALL {
    	WITH m
    	WITH m  WHERE $occupation IS NOT NULL
		MATCH (m)-[r1:HAS_OCCUPATION]-> ()
    	MERGE (o:Occupation {occupation:$occupation})
		DELETE r1
		MERGE (m)-[:HAS_OCCUPATION]-> (o)
    	RETURN count(m)
    	}
	WITH m
	CALL {
    	WITH m
    	WITH m  WHERE $bacenta IS NOT NULL
    	MATCH (c:Bacenta {id: $bacenta})
		OPTIONAL MATCH (m)-[r1:BELONGS_TO]-> (:Bacenta)
		DELETE r1
		MERGE (m)-[:BELONGS_TO]-> (c)
    	RETURN count(m)
    	}
	WITH m
	CALL {
    	WITH m
    	WITH m  WHERE $ministry IS NOT NULL
    	MATCH (s:Ministry {id:$ministry})
		OPTIONAL MATCH (m)-[r1:BELONGS_TO]-> (:Ministry)
		DELETE r1
		MERGE (m)-[:BELONGS_TO]-> (s)
    	RETURN count(m)
    	}
   
	RETURN m
	"""
	),
	UpdateTown(
		townID: ID!
		townName: String
		lWhatsappNumber: String
		bishopID: ID
		centres:[ID]
	):Town
	@cypher(statement:
	"""
	MATCH (t:Town {id: $townID})
		SET t.name = $townName
	
	WITH t
    CALL {
    	WITH t
    
        MATCH (m:Member {whatsappNumber: $lWhatsappNumber})
        OPTIONAL MATCH (t)<-[r:LEADS]-()
        DELETE r
        MERGE (m)-[:LEADS]->(t)
    	RETURN count(t)
    	}

	WITH t
    CALL {
    	WITH t
    
        MATCH (b:Member {id: $bishopID})
        OPTIONAL MATCH (t)<-[r:HAS_TOWN]-()
        DELETE r
        MERGE (b)-[:HAS_TOWN]->(t)
    	RETURN count(t)
    	}

	WITH t
    CALL {
    	WITH t
    	WITH t  WHERE $centres IS NOT NULL
    	UNWIND $centres AS x
        MATCH (c:Centre {id:x})
        OPTIONAL MATCH ()-[r:HAS_CENTRE]->(c)
		OPTIONAL MATCH (t)-[r1:HAS_CENTRE]->()
        DELETE r,r1
        MERGE (t)-[:HAS_CENTRE]->(c)
    	RETURN count(t)
    	}

	RETURN t
	"""
	),
	UpdateCampus(
		campusID: ID
		campusName: String
		lWhatsappNumber: String
		bishopID: ID
		centres:[ID]
	):Campus
	@cypher(statement:
	"""
	MATCH (t:Campus {id: $campusID})
		SET t.name = $campusName
	
	WITH t
    CALL {
    	WITH t
    
        MATCH (m:Member {whatsappNumber: $lWhatsappNumber})
        OPTIONAL MATCH (t)<-[r:LEADS]-()
        DELETE r
        MERGE (m)-[:LEADS]->(t)
    	RETURN count(t)
    	}

	WITH t
    CALL {
    	WITH t
    
        MATCH (b:Member {id: $bishopID})
        OPTIONAL MATCH (t)<-[r:HAS_CAMPUS]-()
        DELETE r
        MERGE (b)-[:HAS_CAMPUS]->(t)
    	RETURN count(t)
    	}

	WITH t
    CALL {
    	WITH t
    	WITH t  WHERE $centres IS NOT NULL
    	UNWIND $centres AS x
        MATCH (c:Centre {id:x})
        OPTIONAL MATCH ()-[r:HAS_CENTRE]->(c)
		OPTIONAL MATCH (t)-[r1:HAS_CENTRE]->()
        DELETE r,r1
        MERGE (t)-[:HAS_CENTRE]->(c)
    	RETURN count(t)
    	}

	RETURN t
	"""
	),

	#DELETE OPERATIONS
	RemoveBacentaLeader(
		lWhatsappNumber: String
		groupToNotLead: String
		endDate: Date
		):Member
	@cypher(statement:
	"""
	MATCH (m:Member {whatsappNumber: $lWhatsappNumber})
	MATCH (c:Bacenta {name: $groupToNotLead})
	MERGE (l)-[leads:LEADS]->(c)
		SET leads.endDate: $endDate
	MERGE (hist:LeaderHistory {HistoryDate:$endDate, HistoryRecord: `m.firstName m.lastName has been has been removed as a bacenta leader of $groupNotToLead`})
	MERGE (m)-[:HAS_LEADERSHIP_HISTORY]->(hist)
	RETURN m
	"""
	)
}