type SwellStats {
  attendance: Int
  date: Date
  target: Int
}

type Target {
  target: Int
  date: TimeGraph! @relationship(type: "TARGET_FOR", direction: OUT)
  bacenta: Bacenta!
    @cypher(
      statement: """
      MATCH (this)-[:TARGET_FOR]->(:ServiceLog)-[:HAS_HISTORY]->(bacenta:Bacenta)
      RETURN bacenta
      """
    )
  council: Council!
    @cypher(
      statement: """
      MATCH (this)-[:TARGET_FOR]->(:ServiceLog)-[:HAS_HISTORY]->(bacenta:Bacenta)
      RETURN bacenta
      """
    )
}

extend type Oversight {
  swellBussingRecords(startDate: String!, endDate: String!): [SwellStats!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (swell:SwellDate)
      WHERE date(swell.date) >= date($startDate) AND date(swell.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target)-[:TARGET_FOR]->(swell)

      WITH collect(DISTINCT(date(swell.date).week)) as list, aggregate, swell, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance), date: swell.date, target: target.target}
      """
    )
}

extend type GatheringService {
  swellBussingRecords(startDate: String!, endDate: String!): [SwellStats!]!
    @cypher(
      statement: """
       MATCH (this)
      MATCH (swell:SwellDate)
      WHERE date(swell.date) >= date($startDate) AND date(swell.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target)-[:TARGET_FOR]->(swell)

      WITH collect(DISTINCT(date(swell.date).week)) as list, aggregate, swell, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance), date: swell.date, target: target.target}
      """
    )
}

extend type Stream {
  swellBussingRecords(startDate: String!, endDate: String!): [SwellStats!]!
    @cypher(
      statement: """
      MATCH (this)
        MATCH (swell:SwellDate)
        WHERE date(swell.date) >= date($startDate) AND date(swell.date) <= date($endDate)
        MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
        OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target)-[:TARGET_FOR]->(swell)

        WITH collect(DISTINCT(date(swell.date).week)) as list, aggregate, swell, target
        MATCH (aggregate) WHERE aggregate.week IN list
        RETURN {attendance: toFloat(aggregate.attendance), date: swell.date, target: target.target}
      """
    )
}

extend type Council {
  swellBussingRecords(startDate: String!, endDate: String!): [SwellStats!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (swell:SwellDate)
      WHERE date(swell.date) >= date($startDate) AND date(swell.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target)-[:TARGET_FOR]->(swell)

      WITH collect(DISTINCT(date(swell.date).week)) as list, aggregate, swell, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance), date: swell.date, target: target.target}
      """
    )
  swellTarget: Target!
    @cypher(
      statement: """
      MATCH (target:Target)-[:TARGET_FOR]->(:ServiceLog)-[:HAS_HISTORY]->(this)
      RETURN target
      """
    )
}

extend type Constituency {
  swellBussingRecords(startDate: String!, endDate: String!): [SwellStats!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (swell:SwellDate)
      WHERE date(swell.date) >= date($startDate) AND date(swell.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target)-[:TARGET_FOR]->(swell)

      WITH collect(DISTINCT(date(swell.date).week)) as list, aggregate, swell, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance), date: swell.date, target: target.target}
      """
    )
}

extend type Bacenta {
  swellBussingRecords(startDate: String!, endDate: String!): [SwellStats!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (swell:SwellDate)
      WHERE date(swell.date) >= date($startDate) AND date(swell.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target)-[:TARGET_FOR]->(swell)

      WITH collect(DISTINCT(date(swell.date).week)) as list, aggregate, swell, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance), date: swell.date, target: target.target}
      """
    )
}

extend type Mutation {
  UploadBacentaTargets(data: String!, swellDate: String!): Boolean!
  ShareTargetsByCouncil(data: String!, swellDate: String!): Boolean!
}
