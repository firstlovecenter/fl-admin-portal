extend type Mutation {
  RecordMultiplicationEvent(
    churchId: ID!
    preacherId: String!
    crusadeLocation: String!
    attendance: Int!
    income: Float!
    foreignCurrency: String
    souls: Int!
    miracles: Int!
    crusadePictures: [String!]!
    treasurerSelfie: String!
    crusadeDate: Date!
    treasurers: [ID]!
  ): MultiplicationRecord

  SubmitMultiplicationBankingSlip(
    multiplicationRecordId: String!
    bankingSlip: String!
  ): MultiplicationRecord
}

type MultiplicationRecord {
  id: ID!
  crusadeDate: TimeGraph! @relationship(type: "CRUSADE_HELD_ON", direction: OUT)
  preacher: Member! @relationship(type: "PREACHED_AT", direction: IN)
  crusadeLocation: String!
  attendance: Int!
  income: Float!
  foreignCurrency: String
  souls: Int!
  miracles: Int!
  crusadePictures: [String!]!
  treasurers: [Member!]!
  treasurerSelfie: String!
  bankingSlipUploader: Member
    @relationship(type: "UPLOADED_SLIP_FOR", direction: IN)
  bankingProof: Boolean
    @cypher(
      statement: """
      MATCH (this)
      WITH this WHERE this.bankingSlip IS NOT NULL
      OR  this.transactionStatus = 'success'
      OR this.tellerConfirmationTime IS NOT NULL
      RETURN true
      """
    )
  createdAt: Date!
  created_by: Member! @relationship(type: "LOGGED_BY", direction: OUT)
  bankingSlip: String
}

type AggregateMultiplicationRecord {
  id: ID!
  week: Int!
  year: Int!
  attendance: Int!
  income: Float!
  souls: Int!
  miracles: Int!
}

extend type Member {
  preacher: [MultiplicationRecord!]!
    @relationship(type: "PREACHED_AT", direction: OUT)
  multiplicationTreasurers: [MultiplicationRecord!]!
    @relationship(type: "WAS_TREASURER_FOR", direction: OUT)
  multiplicationBankingSlipUploader: [MultiplicationRecord!]!
    @relationship(type: "UPLOADED_SLIP_FOR", direction: OUT)
}

extend type TimeGraph {
  multiplicationRecordDate: [MultiplicationRecord!]!
    @relationship(type: "CRUSADE_HELD_ON", direction: IN)
}

extend type Campus {
  multiplicationRecords(limit: Int): [MultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_RECORD]->(records:MultiplicationRecord)-[:CRUSADE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records, date
      RETURN records ORDER BY date.date DESC LIMIT $limit
      """
      columnName: "multiplicationRecords"
    )
  aggregateMultiplicationRecords(
    limit: Int! = 4
  ): [AggregateMultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      WHERE aggregate.year = date().year
      RETURN aggregate ORDER BY aggregate.year, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateMultiplicationRecords"
    )
  multiplicationStats(
    startDate: String!
    endDate: String!
  ): [MultiplicationStats!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (multiplication:MultiplicationDate)
      WHERE date(multiplication.date) >= date($startDate) AND date(multiplication.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(multiplication.date)

      WITH collect(DISTINCT(date(multiplication.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "multiplicationRecords"
    )
  target: Int
    @cypher(
      statement: """
      MATCH (this)-[:CURRENT_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target)
      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
}

extend type Stream {
  multiplicationRecords(limit: Int): [MultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_RECORD]->(records:MultiplicationRecord)-[:CRUSADE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records, date
      RETURN records ORDER BY date.date DESC LIMIT $limit
      """
      columnName: "multiplicationRecords"
    )

  aggregateMultiplicationRecords(
    limit: Int! = 4
  ): [AggregateMultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      WHERE aggregate.year = date().year
      RETURN aggregate ORDER BY aggregate.year, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateMultiplicationRecords"
    )
  multiplicationStats(
    startDate: String!
    endDate: String!
  ): [MultiplicationStats!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (multiplication:MultiplicationDate)
      WHERE date(multiplication.date) >= date($startDate) AND date(multiplication.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(multiplication.date)

      WITH collect(DISTINCT(date(multiplication.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "multiplicationRecords"
    )
  target: Int
    @cypher(
      statement: """
      MATCH (this)-[:CURRENT_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target)
      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
}

extend type Council {
  multiplicationRecords(limit: Int): [MultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_RECORD]->(records:MultiplicationRecord)-[:CRUSADE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records, date
      RETURN records ORDER BY date.date DESC LIMIT $limit
      """
      columnName: "multiplicationRecords"
    )

  aggregateMultiplicationRecords(
    limit: Int! = 4
  ): [AggregateMultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      WHERE aggregate.year = date().year
      RETURN aggregate ORDER BY aggregate.year, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateMultiplicationRecords"
    )
  multiplicationStats(
    startDate: String!
    endDate: String!
  ): [MultiplicationStats!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (multiplication:MultiplicationDate)
      WHERE date(multiplication.date) >= date($startDate) AND date(multiplication.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(multiplication.date)

      WITH collect(DISTINCT(date(multiplication.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "multiplicationRecords"
    )
  target: Int
    @cypher(
      statement: """
      MATCH (this)-[:CURRENT_HISTORY]->(log:ServiceLog)-[:HAS_TARGET]->(target)
      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
}

extend type Governorship {
  multiplicationRecords(limit: Int): [MultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_RECORD]->(records:MultiplicationRecord)-[:CRUSADE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records, date
      RETURN records ORDER BY date.date DESC LIMIT $limit
      """
      columnName: "multiplicationRecords"
    )

  aggregateMultiplicationRecords(
    limit: Int! = 4
  ): [AggregateMultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      WHERE aggregate.year = date().year
      RETURN aggregate ORDER BY aggregate.year, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateMultiplicationRecords"
    )
  multiplicationStats(
    startDate: String!
    endDate: String!
  ): [MultiplicationStats!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (multiplication:MultiplicationDate)
      WHERE date(multiplication.date) >= date($startDate) AND date(multiplication.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(multiplication.date)

      WITH collect(DISTINCT(date(multiplication.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "multiplicationRecords"
    )
  target: Int
    @cypher(
      statement: """
      MATCH (this)
      MATCH (this)-[:CURRENT_HISTORY]->(log:ServiceLog)-[:HAS_TARGET]->(target)

      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
}

extend type Oversight {
  target: Int
    @cypher(
      statement: """
      MATCH (this)-[:CURRENT_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target)
      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
  multiplicationRecords(
    startDate: String!
    endDate: String!
  ): [MultiplicationStats!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (multiplication:MultiplicationDate)
      WHERE date(multiplication.date) >= date($startDate) AND date(multiplication.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(multiplication.date)

      WITH collect(DISTINCT(date(multiplication.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "multiplicationRecords"
    )
}

extend type Bacenta {
  multiplicationRecords(
    startDate: String!
    endDate: String!
  ): [MultiplicationStats!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (multiplication:MultiplicationDate)
      WHERE date(multiplication.date) >= date($startDate) AND date(multiplication.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(multiplication.date)

      WITH collect(DISTINCT(date(multiplication.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "multiplicationRecords"
    )
  target: Int
    @cypher(
      statement: """
      MATCH (this)-[:CURRENT_HISTORY]->(log:ServiceLog)-[:HAS_TARGET]->(target)
      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
}
