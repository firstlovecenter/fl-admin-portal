extend type Mutation {
  LogStreamHistory(
    streamId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newCampusId: ID
    oldCampusId: ID
  ): Stream
    @cypher(
      statement: """
      MATCH  (stream:Stream {id: $streamId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (stream)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,stream
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Active:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        SET r0.current = false
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,stream
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Active:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,stream
      CALL {
        WITH log
        WITH log WHERE $oldCampusId IS NOT NULL
        MATCH (campus:Campus {id: $oldCampusId})
        MERGE (campus)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,stream
      CALL {
        WITH log
        WITH log WHERE $newCampusId IS NOT NULL
        MATCH (campus:Campus {id: $newCampusId})
        MERGE (campus)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN stream
      """
    )

  LogCampusHistory(
    campusId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newOversightId: ID
    oldOversightId: ID
  ): Campus
    @cypher(
      statement: """
      MATCH  (campus:Campus {id: $campusId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (campus)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,campus
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Active:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        SET r0.current = false
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,campus
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Active:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,campus
      CALL {
        WITH log
        WITH log WHERE $oldOversightId IS NOT NULL
        MATCH (oversight:Oversight {id: $oldOversightId})
        MERGE (oversight)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,campus
      CALL {
        WITH log
        WITH log WHERE $newOversightId IS NOT NULL
        MATCH (oversight:Oversight {id: $newOversightId})
        MERGE (oversight)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN campus
      """
    )

  LogOversightHistory(
    oversightId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    oldDenominationId: ID
    newDenominationId: ID
  ): Oversight!
    @cypher(
      statement: """
      MATCH  (oversight:Oversight {id: $oversightId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (oversight)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,oversight
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Active:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        SET r0.current = false
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log, oversight
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Active:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log, oversight
      CALL {
        WITH log
        WITH log WHERE $oldDenominationId IS NOT NULL
        MATCH (denomination:Denomination {id: $oldDenominationId})
        MERGE (denomination)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log, oversight
      CALL {
        WITH log
        WITH log WHERE $newDenominationId IS NOT NULL
        MATCH (denomination:Denomination {id: $newDenominationId})
        MERGE (denomination)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN oversight
      """
    )

  LogMemberHistory(ids: [ID], historyRecord: String!): Member
    @cypher(
      statement: """
       CREATE (log:HistoryLog)
         SET log.id = apoc.create.uuid(),
          log.timeStamp = datetime(),
          log.historyRecord = $historyRecord

       WITH  log
      MERGE (date:TimeGraph {date: date()})

      WITH log, date
      MATCH (author:Active:Member {auth_id: $auth.jwt.sub})
       MERGE (log)-[:LOGGED_BY]->(author)
       MERGE (log)-[:RECORDED_ON]->(date)


      WITH log
       UNWIND $ids AS nodeId
       MATCH (node {id: nodeId}) WHERE node:Active:Member OR node:Fellowship
       MERGE (node)-[:HAS_HISTORY]->(log)

       WITH node WHERE node:Active:Member

      RETURN node
      """
    )

  LogFellowshipHistory(
    fellowshipId: ID!
    historyRecord: String!
    oldLeaderId: ID
    newLeaderId: ID
    oldBacentaId: ID
    newBacentaId: ID
  ): Fellowship
    @cypher(
      statement: """
      MATCH  (fellowship:Fellowship {id: $fellowshipId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (fellowship)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)


      WITH log,fellowship
      CALL{
        WITH log
        WITH log WHERE $oldBacentaId IS NOT NULL
        MATCH (oldBacenta:Bacenta {id: $oldBacentaId})
        MERGE (oldBacenta)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,fellowship
      CALL{
        WITH log
        WITH log WHERE $newBacentaId IS NOT NULL
        MATCH (newBacenta:Bacenta {id: $newBacentaId})
        MERGE (newBacenta)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN fellowship
      """
    )
  LogBacentaHistory(
    bacentaId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newConstituencyId: ID
    oldConstituencyId: ID
  ): Bacenta
    @cypher(
      statement: """
       MATCH  (bacenta:Bacenta {id: $bacentaId})
       MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
       CREATE (log:HistoryLog {id: apoc.create.uuid()})
         SET log.historyRecord = $historyRecord,
           log.timeStamp = datetime()
       MERGE (date:TimeGraph {date: date()})
       MERGE (bacenta)-[r:HAS_HISTORY]->(log)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (log)-[:LOGGED_BY]->(admin)

       WITH log,bacenta
       CALL{
         WITH log
         WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Active:Member {id: $newLeaderId})
      OPTIONAL MATCH (oldLeader:Active:Member {id: $oldLeaderId})
         SET log :ServiceLog
         WITH log, newLeader,oldLeader
       OPTIONAl MATCH (log)<-[r0:HAS_HISTORY]-()
         WITH log,newLeader,oldLeader
       CREATE (oldLeader)-[:HAS_HISTORY]->(log)
       CREATE (newLeader)-[:HAS_HISTORY]->(log)

          WITH log
       RETURN COUNT(log)
       }


       WITH log,bacenta
       CALL {
         WITH log
         WITH log WHERE $oldConstituencyId IS NOT NULL
         MATCH (oldconstituency:Constituency {id: $oldConstituencyId})
         MERGE (oldconstituency)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       WITH log,bacenta
       CALL {
         WITH log
         WITH log WHERE $newConstituencyId IS NOT NULL
         MATCH (newconstituency:Constituency {id: $newConstituencyId})
         MERGE (newconstituency)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       RETURN bacenta
      """
    )
  LogConstituencyHistory(
    constituencyId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newCouncilId: ID
    oldCouncilId: ID
  ): Constituency
    @cypher(
      statement: """
      MATCH  (constituency:Constituency {id: $constituencyId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (constituency)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,constituency
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Active:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        SET r0.current = false
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,constituency
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Active:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,constituency
      CALL {
        WITH log
        WITH log WHERE $oldCouncilId IS NOT NULL
        MATCH (council:Council {id: $oldCouncilId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,constituency
      CALL {
        WITH log
        WITH log WHERE $newCouncilId IS NOT NULL
        MATCH (council:Council {id: $newCouncilId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN constituency
      """
    )

  LogCouncilHistory(
    councilId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newStreamId: ID
    oldStreamId: ID
  ): Council
    @cypher(
      statement: """
      MATCH  (council:Council {id: $councilId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (council)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,council
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Active:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        SET r0.current = false
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Active:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $oldStreamId IS NOT NULL
        MATCH (council:Council {id: $oldStreamId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $newStreamId IS NOT NULL
        MATCH (council:Council {id: $newStreamId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN council
      """
    )

  # New Church With History
}
