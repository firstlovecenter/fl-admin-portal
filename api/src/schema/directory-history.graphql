extend type Mutation {
  CreateChurchSubstructure(
    churchType: String!
    servantType: String!
    churchId: ID!
  ): ID!

  LogStreamHistory(ids: [ID], historyRecord: String!): Stream
    @cypher(
      statement: """
      CREATE (log:HistoryLog)
        SET log.id = apoc.create.uuid(),
         log.timeStamp = datetime(),
         log.historyRecord = $historyRecord

      WITH  log
      MERGE (date:TimeGraph {date: date()})

      WITH log, date
      MATCH (author:Member {auth_id: $auth.jwt.sub})
      CREATE (log)-[:LOGGED_BY]->(author)
      CREATE (log)-[:RECORDED_ON]->(date)

      WITH log
      UNWIND $ids AS nodeId
      MATCH (node {id: $nodeId}) WHERE node:Member OR node:Stream
      CREATE (node)-[:HAS_HISTORY]->(log)

      WITH node WHERE node:Stream
      RETURN node
      """
    )

  LogMemberHistory(ids: [ID], historyRecord: String!): Member
    @cypher(
      statement: """
       CREATE (log:HistoryLog)
         SET log.id = apoc.create.uuid(),
          log.timeStamp = datetime(),
          log.historyRecord = $historyRecord

       WITH  log
      MERGE (date:TimeGraph {date: date()})

      WITH log, date
      MATCH (author:Member {auth_id: $auth.jwt.sub})
       MERGE (log)-[:LOGGED_BY]->(author)
       MERGE (log)-[:RECORDED_ON]->(date)


      WITH log
       UNWIND $ids AS nodeId
       MATCH (node {id: nodeId}) WHERE node:Member OR node:Fellowship
       MERGE (node)-[:HAS_HISTORY]->(log)

       WITH node WHERE node:Member

      RETURN node
      """
    )

  ConnectChurchHistory(churchId: ID!): [ServiceLog!]!
    @cypher(
      statement: """
      MATCH (church {id: $churchId})
      WHERE church:Bacenta OR church:Constituency OR church:Council OR church:Stream OR church:Sonta
      MATCH (church)-[r:HAS_HISTORY]->(churchHistory:ServiceLog) WHERE r.current=true
      MATCH (church)-[:HAS]->(downRelatedChurch)
      MATCH (upRelatedChurch)-[:HAS]->(church)
      MATCH (downRelatedChurch)-[r1:HAS_HISTORY]->(downHistory:ServiceLog) WHERE r1.current=true
      MATCH (upRelatedChurch)-[r2:HAS_HISTORY]->(upHistory:ServiceLog) WHERE r2.current=true

      MERGE (upHistory)-[:HAS_COMPONENT]->(churchHistory)
      MERGE (churchHistory)-[:HAS_COMPONENT {direct: true}]->(downHistory)

      RETURN churchHistory
      """
    )

  ConnectFellowshipHistory(churchId: ID!): [ServiceLog!]!
    @cypher(
      statement: """
      MATCH (church:Fellowship {id: $churchId})
      MATCH (church)-[r:HAS_HISTORY]->(churchHistory:ServiceLog) WHERE r.current=true
      MATCH (upRelatedChurch)-[:HAS]->(church)
      MATCH (upRelatedChurch)-[r2:HAS_HISTORY]->(upHistory:ServiceLog) WHERE r2.current=true

      MERGE (upHistory)-[:HAS_COMPONENT]->(churchHistory)

      RETURN churchHistory
      """
    )
  ConnectGatheringServiceHistory(churchId: ID!): [ServiceLog!]!
    @cypher(
      statement: """
      MATCH (church:GatheringService {id: $churchId})
      MATCH (church)-[r:HAS_HISTORY]-(churchHistory:ServiceLog) WHERE r.current=true
      MATCH (downRelatedChurch)-[:HAS]->(church)
      MATCH (downRelatedChurch)-[r2:HAS_HISTORY]->(downHistory:ServiceLog) WHERE r2.current=true

      MERGE (churchHistory)-[:HAS_COMPONENT]->(downHistory)

      RETURN churchHistory
      """
    )

  LogFellowshipHistory(
    fellowshipId: ID!
    historyRecord: String!
    oldLeaderId: ID
    newLeaderId: ID
    oldBacentaId: ID
    newBacentaId: ID
  ): Fellowship
    @cypher(
      statement: """
      MATCH  (fellowship:Fellowship {id: $fellowshipId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (fellowship)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)


      WITH log,fellowship
      CALL{
        WITH log
        WITH log WHERE $oldBacentaId IS NOT NULL
        MATCH (oldBacenta:Bacenta {id: $oldBacentaId})
        MERGE (oldBacenta)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,fellowship
      CALL{
        WITH log
        WITH log WHERE $newBacentaId IS NOT NULL
        MATCH (newBacenta:Bacenta {id: $newBacentaId})
        MERGE (newBacenta)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN fellowship
      """
    )
  LogBacentaHistory(
    bacentaId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newConstituencyId: ID
    oldConstituencyId: ID
  ): Bacenta
    @cypher(
      statement: """
       MATCH  (bacenta:Bacenta {id: $bacentaId})
       MATCH (admin:Member {auth_id: $auth.jwt.sub})
       CREATE (log:HistoryLog {id: apoc.create.uuid()})
         SET log.historyRecord = $historyRecord,
           log.timeStamp = datetime()
       MERGE (date:TimeGraph {date: date()})
       MERGE (bacenta)-[r:HAS_HISTORY]->(log)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (log)-[:LOGGED_BY]->(admin)

       WITH log,bacenta
       CALL{
         WITH log
         WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Member {id: $newLeaderId})
      OPTIONAL MATCH (oldLeader:Member {id: $oldLeaderId})
         SET log :ServiceLog
         WITH log, newLeader,oldLeader
       OPTIONAl MATCH (log)<-[r0:HAS_HISTORY]-()
         WITH log,newLeader,oldLeader
       CREATE (oldLeader)-[:HAS_HISTORY]->(log)
       CREATE (newLeader)-[:HAS_HISTORY]->(log)

          WITH log
       RETURN COUNT(log)
       }


       WITH log,bacenta
       CALL {
         WITH log
         WITH log WHERE $oldConstituencyId IS NOT NULL
         MATCH (oldconstituency:Constituency {id: $oldConstituencyId})
         MERGE (oldconstituency)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       WITH log,bacenta
       CALL {
         WITH log
         WITH log WHERE $newConstituencyId IS NOT NULL
         MATCH (newconstituency:Constituency {id: $newConstituencyId})
         MERGE (newconstituency)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       RETURN bacenta
      """
    )
  LogConstituencyHistory(
    constituencyId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newCouncilId: ID
    oldCouncilId: ID
  ): Constituency
    @cypher(
      statement: """
      MATCH  (constituency:Constituency {id: $constituencyId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (constituency)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,constituency
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        SET r0.current = false
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,constituency
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,constituency
      CALL {
        WITH log
        WITH log WHERE $oldCouncilId IS NOT NULL
        MATCH (council:Council {id: $oldCouncilId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,constituency
      CALL {
        WITH log
        WITH log WHERE $newCouncilId IS NOT NULL
        MATCH (council:Council {id: $newCouncilId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN constituency
      """
    )

  LogCouncilHistory(
    councilId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newStreamId: ID
    oldStreamId: ID
  ): Council
    @cypher(
      statement: """
      MATCH  (council:Council {id: $councilId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (council)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,council
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        SET r0.current = false
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $oldStreamId IS NOT NULL
        MATCH (council:Council {id: $oldStreamId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $newStreamId IS NOT NULL
        MATCH (council:Council {id: $newStreamId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN council
      """
    )

  LogSontaHistory(
    sontaId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
  ): Sonta
    @cypher(
      statement: """
       MATCH  (sonta:Sonta {id: $sontaId})
       MATCH (admin:Member {auth_id: $auth.jwt.sub})
       CREATE (log:HistoryLog {id: apoc.create.uuid()})
         SET log.historyRecord = $historyRecord,
           log.timeStamp = datetime()
       MERGE (date:TimeGraph {date: date()})
       MERGE (sonta)-[r:HAS_HISTORY]->(log)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (log)-[:LOGGED_BY]->(admin)

       WITH log,sonta
       CALL{
         WITH log
         WITH log WHERE $newLeaderId IS NOT NULL
       MATCH (newLeader:Member {id: $newLeaderId})
      OPTIONAL MATCH (oldLeader:Member {id: $oldLeaderId})
         SET log :ServiceLog
         WITH log, newLeader,oldLeader
       OPTIONAl MATCH ()-[r0:CURRENT_HISTORY]->(log)
         DELETE r0
         WITH log,newLeader,oldLeader
       CREATE (oldLeader)-[:HAS_HISTORY]->(log)
       CREATE (newLeader)-[r:HAS_HISTORY]->(log)
       CREATE (newLeader)-[:CURRENT_HISTORY]->(log)
          WITH log
       RETURN COUNT(log)
       }


       RETURN sonta
      """
    )

  # New Church With History
}
