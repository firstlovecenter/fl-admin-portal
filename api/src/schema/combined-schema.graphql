#Query Definitions
extend schema @authentication

type Query {
  currentUser(id: ID): Member!
    @cypher(
      statement: "MATCH (member:Active:Member {auth_id: $auth.jwt.sub}) RETURN member"
      columnName: "member"
    )

  memberByEmail(email: String!): Member
    @cypher(
      statement: "MATCH (member:Active:Member {email:$email}) RETURN member LIMIT 1"
      columnName: "member"
    )
}

type Mutation {
  MakeFellowshipIntoBacenta(fellowshipId: ID!): Bacenta!
  CreateMemberAccount(memberId: ID!): Member!
}
 type Member {
  id: ID! @id
  auth_id: String
  firstName: String #@search
  middleName: String
  lastName: String
  fullName: String @customResolver
  currentTitle: String
    @cypher(
      statement: """
      MATCH (this)-[r:HAS_TITLE]->(title:Title)
      WHERE NOT r.inactive = true
      RETURN title.name ORDER BY title.priority DESC LIMIT 1
      """
      columnName: "currentTitle"
    )
  nameWithTitle: String @customResolver
  email: String
  phoneNumber: String
  whatsappNumber: String!
  pictureUrl: String
  visitationArea: String
  location: Point
  gender: Gender! @relationship(type: "HAS_GENDER", direction: OUT)
  maritalStatus: MaritalStatus!
    @relationship(type: "HAS_MARITAL_STATUS", direction: OUT)
  dob: TimeGraph @relationship(type: "WAS_BORN_ON", direction: OUT)
  title: [Title!]!
    @relationship(type: "HAS_TITLE", properties: "HasTitle", direction: OUT)
  basonta: Basonta @relationship(type: "BELONGS_TO", direction: OUT)
  stickyNote: String
  occupation: Occupation @relationship(type: "HAS_OCCUPATION", direction: OUT)
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)-[:BELONGS_TO]->(:Fellowship)<-[:HAS*4]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
      columnName: "stream_name"
    )
  # Church Details
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|DOES_ARRIVALS_FOR|IS_ADMIN_FOR|IS_SHEEP_SEEKER_FOR*1..7]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN DISTINCT members ORDER BY toLower(members.firstName), toLower(members.lastName)
      """
      columnName: "members"
    )

  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|DOES_ARRIVALS_FOR|IS_ADMIN_FOR|IS_SHEEP_SEEKER_FOR*1..7]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "memberCount"
    )
  basontaMembers: [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR*1..5]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      MATCH (members)-[:BELONGS_TO]->(:Basonta)
      RETURN DISTINCT members ORDER BY toLower(members.firstName), toLower(members.lastName)
      """
      columnName: "basontaMembers"
    )
  basontaMembershipCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR*1..5]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      MATCH (members)-[:BELONGS_TO]->(:Basonta)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "basontaMembershipCount"
    )
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC  LIMIT $limit"
      columnName: "history"
    )
  loggedHistory: [HistoryLog!]! @relationship(type: "LOGGED_BY", direction: IN)
  bacenta: Bacenta @relationship(type: "BELONGS_TO", direction: OUT)
  leadsFellowship: [Fellowship!]! @relationship(type: "LEADS", direction: OUT)
  leadsFellowshipCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(fellowships:Fellowship)
      RETURN COUNT(fellowships)
      """
      columnName: "leadsFellowshipCount"
    )
  leadsBacenta: [Bacenta!]! @relationship(type: "LEADS", direction: OUT)
  leadsBacentaCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(bacentas:Bacenta)
      RETURN COUNT(bacentas)
      """
      columnName: "leadsBacentaCount"
    )

  ### CREATIVE ARTS WORK ###
  leadsCreativeArts: [CreativeArts!]!
    @relationship(type: "LEADS", direction: OUT)
  leadsMinistry: [Ministry!]! @relationship(type: "LEADS", direction: OUT)
  leadsHub: [Hub!]! @relationship(type: "LEADS", direction: OUT)
  leadsGovernorship: [Governorship!]!
    @relationship(type: "LEADS", direction: OUT)
  leadsGovernorshipCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(governorship:Governorship)
      RETURN COUNT(DISTINCT governorship)
      """
      columnName: "leadsGovernorshipCount"
    )
  isAdminForGovernorshipCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:IS_ADMIN_FOR]->(governorship:Governorship)
      RETURN COUNT(DISTINCT governorship)
      """
      columnName: "isAdminForGovernorshipCount"
    )
  leadsAdminsGovernorshipCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|IS_ADMIN_FOR]->(governorship:Governorship)
      RETURN COUNT(DISTINCT governorship)
      """
      columnName: "leadsAdminsGovernorshipCount"
    )
  leadsCouncil: [Council!]! @relationship(type: "LEADS", direction: OUT)
  leadsCouncilCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(council:Council)
      RETURN COUNT(DISTINCT council)
      """
      columnName: "leadsCouncilCount"
    )
  isAdminForCouncilCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:IS_ADMIN_FOR]->(council:Council)
      RETURN COUNT(DISTINCT council)
      """
      columnName: "isAdminForCouncilCount"
    )
  leadsAdminsCouncilCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|IS_ADMIN_FOR]->(council:Council)
      RETURN COUNT(DISTINCT council)
      """
      columnName: "leadsAdminsCouncilCount"
    )
  leadsStream: [Stream!]! @relationship(type: "LEADS", direction: OUT)
  leadsStreamCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(stream:Stream)
      RETURN COUNT(DISTINCT stream)
      """
      columnName: "leadsStreamCount"
    )
  isAdminForStreamCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:IS_ADMIN_FOR]->(stream:Stream)
      RETURN COUNT(DISTINCT stream)
      """
      columnName: "isAdminForStreamCount"
    )
  leadsCampus: [Campus!]! @relationship(type: "LEADS", direction: OUT)
  isAdminForCampusCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:IS_ADMIN_FOR]->(campus:Campus)
      RETURN COUNT(DISTINCT campus)
      """
      columnName: "isAdminForCampusCount"
    )
  leadsCampusCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(campus:Campus)
      RETURN COUNT(DISTINCT campus)
      """
      columnName: "leadsCampusCount"
    )
  leadsAdminsCampusCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|IS_ADMIN_FOR]->(campus:Campus)
      RETURN COUNT(DISTINCT campus)
      """
      columnName: "leadsAdminsCampusCount"
    )

  leadsOversight: [Oversight!]! @relationship(type: "LEADS", direction: OUT)
  isAdminForOversightCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:IS_ADMIN_FOR]->(oversight:Oversight)
      RETURN COUNT(DISTINCT oversight)
      """
      columnName: "isAdminForOversightCount"
    )
  leadsOversightCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(oversight:Oversight)
      RETURN COUNT(DISTINCT oversight)
      """
      columnName: "leadsOversightCount"
    )
  leadsAdminsOversight: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|IS_ADMIN_FOR]->(oversight:Oversight)
      RETURN COUNT(DISTINCT oversight)
      """
      columnName: "leadsAdminsOversight"
    )
  leadsDenomination: [Denomination!]!
    @relationship(type: "LEADS", direction: OUT)
  isAdminForDenominationCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:IS_ADMIN_FOR]->(denomination:Denomination)
      RETURN COUNT(DISTINCT denomination)
      """
      columnName: "isAdminForDenominationCount"
    )
  leadsDenominationCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(denomination:Denomination)
      RETURN COUNT(DISTINCT denomination)
      """
      columnName: "leadsDenominationCount"
    )
  leadsAdminsDenominationCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|IS_ADMIN_FOR]->(denomination:Denomination)
      RETURN COUNT(DISTINCT denomination)
      """
      columnName: "leadsAdminsDenominationCount"
    )

  isAdminForDenomination: [Denomination!]!
    @relationship(type: "IS_ADMIN_FOR", direction: OUT)
  isAdminForOversight: [Oversight!]!
    @relationship(type: "IS_ADMIN_FOR", direction: OUT)
  isAdminForCampus: [Campus!]!
    @relationship(type: "IS_ADMIN_FOR", direction: OUT)
  isAdminForStream: [Stream!]!
    @relationship(type: "IS_ADMIN_FOR", direction: OUT)
  isAdminForCouncil: [Council!]!
    @relationship(type: "IS_ADMIN_FOR", direction: OUT)
  isAdminForGovernorship: [Governorship!]!
    @relationship(type: "IS_ADMIN_FOR", direction: OUT)

  #OTHER WORKS
  was_treasurer_for: [ServiceRecord!]!
    @relationship(type: "WAS_TREASURER_FOR", direction: OUT)
}

type Gender {
  gender: String
  members: [Member!]! @relationship(type: "HAS_GENDER", direction: IN)
}

type MaritalStatus {
  status: String
  members: [Member!]! @relationship(type: "HAS_MARITAL_STATUS", direction: IN)
}

type Occupation {
  occupation: String
  members: [Member!]! @relationship(type: "HAS_OCCUPATION", direction: IN)
}

type Title {
  name: String! #Pastor, Reverend, Apostle, Bishop (Mother)
  members: [Member!]!
    @relationship(type: "HAS_TITLE", properties: "HasTitle", direction: IN)
}

type HasTitle @relationshipProperties {
  date: Date
}

interface TimeGraphNode {
  date: Date
}

type TimeGraph implements TimeGraphNode {
  id: ID
    @cypher(
      statement: """
      MATCH (this)
      RETURN toString(this.date)
      """
      columnName: "result"
    )
  date: Date
  swell: Boolean
    @cypher(
      statement: """
      MATCH (this)
      UNWIND labels(this) AS swellStatus
      WITH swellStatus WHERE swellStatus ='SwellDate'
      RETURN true
      """
      columnName: "result"
    )
  memberDob: Member @relationship(type: "WAS_BORN_ON", direction: IN)
  # titleAppointmentDate: Member @relationship(type: "APPOINTED_ON", direction: IN)
  leaderHistoryStartDate: Member
    @relationship(type: "LEADER_STARTED_ON", direction: OUT)
  leaderHistoryEndDate: TimeGraph
    @relationship(type: "LEADER_ENDED_ON", direction: OUT)
  historyDate: Member @relationship(type: "RECORDED_ON", direction: OUT)
  serviceDate: [ServiceRecord!]!
    @relationship(type: "SERVICE_HELD_ON", direction: IN)
  bussingDate: [BussingRecord!]! @relationship(type: "BUSSED_ON", direction: IN)
}

type HistoryLog {
  id: ID @id
  timeStamp: DateTime
  historyRecord: String #leader was transferred to
  createdAt: TimeGraph @relationship(type: "RECORDED_ON", direction: OUT)
  loggedBy: Member @relationship(type: "LOGGED_BY", direction: OUT)
  leaders: [Member!]! @relationship(type: "HAS_HISTORY", direction: IN)
  fellowship: [Fellowship!]! @relationship(type: "HAS_HISTORY", direction: IN)
  bacenta: [Bacenta!]! @relationship(type: "HAS_HISTORY", direction: IN)
  governorship: [Governorship!]!
    @relationship(type: "HAS_HISTORY", direction: IN)
  ministry: [Ministry!]! @relationship(type: "HAS_HISTORY", direction: IN)
  hub: Hub! @relationship(type: "HAS_HISTORY", direction: IN)
  creativeArt: [CreativeArts!]!
    @relationship(type: "HAS_HISTORY", direction: IN)
}

##Church Types##
interface Church {
  id: ID
  name: String!
  leader: Member @declareRelationship
  members: [Member!]!
  memberSearch(key: String!, limit: Int!): [Member!]!
  memberCount: Int!
  pastorCount: Int
  history(limit: Int! = 3): [HistoryLog!]!

  serviceLogs: [ServiceLog!]! @declareRelationship
  services(limit: Int!, skip: Int): [ServiceRecord!]!
}

type Denomination implements Church {
  id: ID! @id
  name: String!
  leader: Member @relationship(type: "LEADS", direction: IN)
  oversights: [Oversight!]! @relationship(type: "HAS", direction: OUT)
  campuses: [Campus!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(campus:Campus) RETURN campus"
      columnName: "campuses"
    )
  streams: [Stream!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(stream:Stream) RETURN stream"
      columnName: "streams"
    )
  councils: [Council!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(councils:Council) RETURN councils"
      columnName: "councils"
    )
  governorships: [Governorship!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*5]->(governorships:Governorship) RETURN governorships"
      columnName: "governorships"
    )
  bacentas: [Bacenta!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*6]->(bacentas:Bacenta) RETURN bacentas"
      columnName: "bacentas"
    )
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*7]->(:Fellowship)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN DISTINCT members ORDER BY toLower(members.firstName), toLower(members.lastName)
      """
      columnName: "members"
    )

  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*6]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "memberCount"
    )
  pastorCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*6]->(:Bacenta)<-[:BELONGS_TO]-(pastors:Active:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
      columnName: "pastorCount"
    )
  campusCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(campus:Campus) RETURN COUNT(campus)"
      columnName: "campusCount"
    )
  streamCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(stream:Stream) RETURN COUNT(stream)"
      columnName: "streamCount"
    )
  councilCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(council:Council) RETURN COUNT(council)"
      columnName: "councilCount"
    )
  governorshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*5]->(governorship:Governorship) RETURN COUNT(governorship)"
      columnName: "governorshipCount"
    )
  bacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*6]->(bacentas:Bacenta) RETURN COUNT(DISTINCT bacentas)"
      columnName: "bacentaCount"
    )
  activeBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*6]->(bacentas:Active:Bacenta) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeBacentaCount"
    )
  vacationBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*6]-(bacentas:Vacation:Bacenta) RETURN COUNT(bacentas)"
      columnName: "vacationBacentaCount"
    )
  activeBacentaICCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*6]->(bacentas:Active:Bacenta:Red) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeBacentaICCount"
    )
  vacationBacentaICCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*6]-(bacentas:Vacation:Bacenta:Red) RETURN COUNT(bacentas)"
      columnName: "vacationBacentaICCount"
    )
  activeGraduatedBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*6]->(bacentas:Active:Bacenta:Green) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeGraduatedBacentaCount"
    )
  vacationGraduatedBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*6]-(bacentas:Vacation:Bacenta:Green) RETURN COUNT(bacentas)"
      columnName: "vacationGraduatedBacentaCount"
    )

  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC  LIMIT $limit"
      columnName: "history"
    )
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!, skip: Int = 0): [ServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(records:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records, date
      RETURN records ORDER BY date.date DESC SKIP $skip LIMIT $limit
      """
      columnName: "services"
    )
}

type Oversight implements Church {
  id: ID @id
  name: String!
  noIncomeTracking: Boolean
  leader: Member @relationship(type: "LEADS", direction: IN)
  denomination: Denomination @relationship(type: "HAS", direction: IN)
  campuses: [Campus!]! @relationship(type: "HAS", direction: OUT)
  streams: [Stream!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(stream:Stream) RETURN stream"
      columnName: "streams"
    )
  councils: [Council!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(councils:Council) RETURN councils"
      columnName: "councils"
    )
  governorships: [Governorship!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(governorships:Governorship) RETURN governorships"
      columnName: "governorships"
    )
  bacentas: [Bacenta!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*5]->(bacentas:Bacenta) RETURN bacentas"
      columnName: "bacentas"
    )
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN DISTINCT members ORDER BY toLower(members.firstName), toLower(members.lastName)
      """
      columnName: "members"
    )

  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "memberCount"
    )
  pastorCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(:Bacenta)<-[:BELONGS_TO]-(pastors:Active:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
      columnName: "pastorCount"
    )
  campusCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]->(campus:Campus) RETURN COUNT(campus)"
      columnName: "campusCount"
    )
  streamCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(stream:Stream) RETURN COUNT(stream)"
      columnName: "streamCount"
    )
  councilCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(council:Council) RETURN COUNT(council)"
      columnName: "councilCount"
    )
  governorshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(governorship:Governorship) RETURN COUNT(governorship)"
      columnName: "governorshipCount"
    )
  bacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*5]->(bacentas:Bacenta) RETURN COUNT(DISTINCT bacentas)"
      columnName: "bacentaCount"
    )
  activeBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*5]->(bacentas:Active:Bacenta) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeBacentaCount"
    )
  vacationBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*5]-(bacentas:Vacation:Bacenta) RETURN COUNT(bacentas)"
      columnName: "vacationBacentaCount"
    )
  activeBacentaICCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*5]->(bacentas:Active:Bacenta:Red) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeBacentaICCount"
    )
  vacationBacentaICCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*5]-(bacentas:Vacation:Bacenta:Red) RETURN COUNT(bacentas)"
      columnName: "vacationBacentaICCount"
    )
  activeGraduatedBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*5]->(bacentas:Active:Bacenta:Green) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeGraduatedBacentaCount"
    )
  vacationGraduatedBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*5]-(bacentas:Vacation:Bacenta:Green) RETURN COUNT(bacentas)"
      columnName: "vacationGraduatedBacentaCount"
    )

  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC  LIMIT $limit"
      columnName: "history"
    )
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!, skip: Int = 0): [ServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(records:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records, date
      RETURN records ORDER BY date.date DESC SKIP $skip LIMIT $limit
      """
      columnName: "services"
    )
}

type Campus implements Church {
  id: ID @id
  name: String!
  noIncomeTracking: Boolean!
  currency: String!
  conversionRateToDollar: Float!

  leader: Member @relationship(type: "LEADS", direction: IN)
  oversight: Oversight! @relationship(type: "HAS", direction: IN)
  streams: [Stream!]! @relationship(type: "HAS", direction: OUT)
  creativeArts: [CreativeArts!]!
    @relationship(type: "HAS_MINISTRY", direction: OUT)

  councils: [Council!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(councils:Council) RETURN councils"
      columnName: "councils"
    )
  governorships: [Governorship!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(governorships:Governorship) RETURN governorships"
      columnName: "governorships"
    )
  bacentas(limit: Int): [Bacenta!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(bacentas:Bacenta) RETURN bacentas"
      columnName: "bacentas"
    )
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN DISTINCT members ORDER BY toLower(members.firstName), toLower(members.lastName)
      """
      columnName: "members"
    )

  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "memberCount"
    )
  pastorCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(:Bacenta)<-[:BELONGS_TO]-(pastors:Active:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
      columnName: "pastorCount"
    )
  streamCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]->(stream:Stream) RETURN COUNT(stream)"
      columnName: "streamCount"
    )
  councilCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(council:Council) RETURN COUNT(council)"
      columnName: "councilCount"
    )
  governorshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(governorship:Governorship) RETURN COUNT(governorship)"
      columnName: "governorshipCount"
    )
  bacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(bacentas:Bacenta)  RETURN COUNT(DISTINCT bacentas)"
      columnName: "bacentaCount"
    )
  activeBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(bacentas:Bacenta:Active) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeBacentaCount"
    )
  vacationBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*4]-(bacentas:Vacation:Bacenta) RETURN COUNT(bacentas)"
      columnName: "vacationBacentaCount"
    )
  activeBacentaICCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(bacentas:Bacenta:Active:Red) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeBacentaICCount"
    )
  vacationBacentaICCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*4]-(bacentas:Vacation:Bacenta:Red) RETURN COUNT(bacentas)"
      columnName: "vacationBacentaICCount"
    )
  activeGraduatedBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta:Green) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeGraduatedBacentaCount"
    )
  vacationGraduatedBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*4]-(bacentas:Vacation:Bacenta:Green) RETURN COUNT(bacentas)"
      columnName: "vacationGraduatedBacentaCount"
    )

  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC  LIMIT $limit"
      columnName: "history"
    )
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!, skip: Int = 0): [ServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(records:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records, date
      RETURN records ORDER BY date.date DESC SKIP $skip LIMIT $limit
      """
      columnName: "services"
    )
}

type Stream implements Church {
  id: ID @id
  name: String!
  bankAccount: String!
  vacationStatus: String!
    @cypher(
      statement: """
      MATCH (this)
      UNWIND labels(this) AS status
      WITH status WHERE status = 'Active' OR status = 'Vacation'
      RETURN status
      """
      columnName: "vacationStatus"
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  councils: [Council!]! @relationship(type: "HAS", direction: OUT)
  campus: Campus @relationship(type: "HAS", direction: IN)
  ministries: [Ministry!]! @relationship(type: "HAS_MINISTRY", direction: OUT)
  meetingDay: ServiceDay! @relationship(type: "MEETS_ON", direction: OUT)

  stream_name: String
    @cypher(
      statement: """
      MATCH (this:Stream)
      RETURN DISTINCT toLower(this.name)
      """
      columnName: "stream_name"
    )
  governorships: [Governorship!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(governorships:Governorship) RETURN governorships"
      columnName: "governorships"
    )
  bacentas(limit: Int): [Bacenta!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(bacentas:Bacenta)  RETURN bacentas"
      columnName: "bacentas"
    )
  ics(limit: Int): [Bacenta!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(bacentas:Red) RETURN bacentas"
      columnName: "ics"
    )

  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN DISTINCT members ORDER BY toLower(members.firstName), toLower(members.lastName)
      """
      columnName: "members"
    )
  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "memberCount"
    )
  pastorCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(:Bacenta)<-[:BELONGS_TO]-(pastors:Active:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
      columnName: "pastorCount"
    )
  councilCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]->(council:Council) RETURN COUNT(council)"
      columnName: "councilCount"
    )
  governorshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(governorship:Governorship) RETURN COUNT(governorship)"
      columnName: "governorshipCount"
    )
  bacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(bacentas:Bacenta)  RETURN COUNT(DISTINCT bacentas)"
      columnName: "bacentaCount"
    )
  activeBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(bacentas:Bacenta:Active)  RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeBacentaCount"
    )
  vacationBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]-(bacentas:Vacation:Bacenta)  RETURN COUNT(bacentas)"
      columnName: "vacationBacentaCount"
    )
  activeBacentaICCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(bacentas:Bacenta:Active:Red)  RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeBacentaICCount"
    )
  vacationBacentaICCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]-(bacentas:Vacation:Bacenta:Red)  RETURN COUNT(bacentas)"
      columnName: "vacationBacentaICCount"
    )
  activeGraduatedBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta:Green) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeGraduatedBacentaCount"
    )
  vacationGraduatedBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]-(bacentas:Vacation:Bacenta:Green) RETURN COUNT(bacentas)"
      columnName: "vacationGraduatedBacentaCount"
    )

  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC  LIMIT $limit"
      columnName: "history"
    )
  serviceRecord: [ServiceRecord!]!
    @relationship(type: "HAS_SERVICE", direction: OUT)
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!, skip: Int = 0): [ServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(records:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records, date
      RETURN records ORDER BY date.date DESC SKIP $skip LIMIT $limit
      """
      columnName: "services"
    )
}

type Council implements Church {
  id: ID @id
  name: String!
  leader: Member @relationship(type: "LEADS", direction: IN)
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
      columnName: "stream_name"
    )
  stream: Stream @relationship(type: "HAS", direction: IN)
  bacentas: [Bacenta!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*1..2]->(bacentas:Bacenta) RETURN bacentas"
      columnName: "bacentas"
    )
  governorships: [Governorship!]! @relationship(type: "HAS", direction: OUT)
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN DISTINCT members ORDER BY toLower(members.firstName), toLower(members.lastName)
      """
      columnName: "members"
    )
  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "memberCount"
    )
  pastorCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(:Bacenta)<-[:BELONGS_TO]-(pastors:Active:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
      columnName: "pastorCount"
    )
  governorshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]->(governorship:Governorship) RETURN COUNT(governorship)"
      columnName: "governorshipCount"
    )
  bacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(bacentas:Bacenta)  RETURN COUNT(DISTINCT bacentas)"
      columnName: "bacentaCount"
    )
  activeBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(bacentas:Bacenta:Active)  RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeBacentaCount"
    )
  vacationBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]-(bacentas:Vacation:Bacenta)  RETURN COUNT(bacentas)"
      columnName: "vacationBacentaCount"
    )
  activeBacentaICCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(bacentas:Bacenta:Active:Red)  RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeBacentaICCount"
    )
  vacationBacentaICCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]-(bacentas:Vacation:Bacenta:Red)  RETURN COUNT(bacentas)"
      columnName: "vacationBacentaICCount"
    )
  activeGraduatedBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta:Green) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeGraduatedBacentaCount"
    )
  vacationGraduatedBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]-(bacentas:Vacation:Bacenta:Green) RETURN COUNT(bacentas)"
      columnName: "vacationGraduatedBacentaCount"
    )

  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC  LIMIT $limit"
      columnName: "history"
    )
  serviceRecord: [ServiceRecord!]!
    @relationship(type: "HAS_SERVICE", direction: OUT)
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!, skip: Int = 0): [ServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(records:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records, date
      RETURN records ORDER BY date.date DESC SKIP $skip LIMIT $limit
      """
      columnName: "services"
    )
}

type Governorship implements Church {
  id: ID @id
  name: String!
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*2]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
      columnName: "stream_name"
    )
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN DISTINCT members ORDER BY toLower(members.firstName), toLower(members.lastName)
      """
      columnName: "members"
    )
  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "memberCount"
    )
  pastorCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*]->(:Bacenta)<-[:BELONGS_TO]-(pastors:Active:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
      columnName: "pastorCount"
    )
  bacentas: [Bacenta!]! @relationship(type: "HAS", direction: OUT)

  bacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]->(bacentas:Bacenta)  RETURN COUNT(bacentas)"
      columnName: "bacentaCount"
    )
  activeBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)  RETURN COUNT(bacentas)"
      columnName: "activeBacentaCount"
    )
  vacationBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]-(bacentas:Vacation:Bacenta)  RETURN COUNT(bacentas)"
      columnName: "vacationBacentaCount"
    )
  activeBacentaICCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]->(bacentas:Active:Bacenta:Red)  RETURN COUNT(bacentas)"
      columnName: "activeBacentaICCount"
    )
  vacationBacentaICCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]-(bacentas:Vacation:Bacenta:Red)  RETURN COUNT(bacentas)"
      columnName: "vacationBacentaICCount"
    )
  activeGraduatedBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]->(bacentas:Active:Bacenta:Green) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeGraduatedBacentaCount"
    )
  vacationGraduatedBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]-(bacentas:Vacation:Bacenta:Green) RETURN COUNT(bacentas)"
      columnName: "vacationGraduatedBacentaCount"
    )

  leader: Member @relationship(type: "LEADS", direction: IN)
  council: Council @relationship(type: "HAS", direction: IN)

  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC  LIMIT $limit"
      columnName: "history"
    )
  serviceRecord: [ServiceRecord!]!
    @relationship(type: "HAS_SERVICE", direction: OUT)
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int! = 12, skip: Int = 0): [ServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(records:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records, date
      RETURN records ORDER BY date.date DESC SKIP $skip LIMIT $limit
      """
      columnName: "services"
    )
}

type Bacenta implements Church {
  id: ID @id
  name: String!
  bankingCode: Int
  location: Point
  meetingDay: ServiceDay! @relationship(type: "MEETS_ON", direction: OUT)
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*3]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
      columnName: "stream_name"
    )
  vacationStatus: String!
    @cypher(
      statement: """
      MATCH (this)
      UNWIND labels(this) AS status
      WITH status WHERE status = 'Active' OR status = 'Vacation'
      RETURN status
      """
      columnName: "vacationStatus"
    )
  labels: [String]
    @cypher(
      statement: """
      MATCH (this)
      RETURN labels(this)
      """
      columnName: "result"
    )
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN DISTINCT members ORDER BY toLower(members.firstName), toLower(members.lastName)
      """
      columnName: "members"
    )
  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "memberCount"
    )
  pastorCount: Int!
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(pastors:Active:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
      columnName: "pastorCount"
    )
  leader: Member @relationship(type: "LEADS", direction: IN)

  governorship: Governorship @relationship(type: "HAS", direction: IN)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC LIMIT $limit"
      columnName: "history"
    )
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int! = 12, skip: Int = 0): [ServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(services:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT services, date
      RETURN services ORDER BY date.date DESC SKIP $skip LIMIT $limit
      """
      columnName: "services"
    )

  council: Council
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*2]-(council:Council)
      RETURN council
      """
      columnName: "result"
    )
  stream: Stream
    @cypher(
      statement: "MATCH (this)<-[:HAS*3]-(stream:Stream) RETURN stream"
      columnName: "stream"
    )

  hubs: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*2]-(council:Council)-[:HAS_MINISTRY]->(hubs:Hub)
      RETURN hubs
      """
      columnName: "result"
    )
}

# Shared Units: Fellowship, Fellowship
type Fellowship implements Church {
  id: ID @id
  bankingCode: Int
  name: String!
  location: Point
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*4]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
      columnName: "stream_name"
    )
  vacationStatus: String!
    @cypher(
      statement: """
      MATCH (this)
      UNWIND labels(this) AS status
      WITH status WHERE status = 'Active' OR status = 'Vacation' OR status = 'Online'
      RETURN status
      """
      columnName: "vacationStatus"
    )
  hubStatus: Boolean!
    @cypher(
      statement: "MATCH (this) RETURN EXISTS((this)<-[:HAS]-(:Hub))"
      columnName: "hubStatus"
    )
  bacenta: Bacenta @relationship(type: "HAS", direction: IN)
  leader: Member @relationship(type: "LEADS", direction: IN)
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN DISTINCT members ORDER BY toLower(members.firstName), toLower(members.lastName)
      """
      columnName: "members"
    )
  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "memberCount"
    )
  ministryMemberCount: Int
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)-[:BELONGS_TO]->(:Ministry)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "ministryMemberCount"
    )
  pastorCount: Int
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(pastors:Active:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
      columnName: "pastorCount"
    )
  meetingDay: ServiceDay! @relationship(type: "MEETS_ON", direction: OUT)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC LIMIT $limit"
      columnName: "history"
    )
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!, skip: Int = 0): [ServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(records:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records,date
      RETURN records ORDER BY date.date DESC SKIP $skip LIMIT $limit
      """
      columnName: "services"
    )
  labels: [String]
    @cypher(
      statement: """
      MATCH (this)
      RETURN labels(this)
      """
      columnName: "result"
    )

  council: Council
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*3]-(council:Council)
      RETURN council
      """
      columnName: "result"
    )
}
type ClosedFellowship {
  id: ID @id
  bankingCode: Int
  name: String
  location: Point
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*4]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
      columnName: "stream_name"
    )
  bacenta: Bacenta @relationship(type: "HAS", direction: IN)
  leader: Member @relationship(type: "LEADS", direction: IN)
  members: [Member!]! @relationship(type: "BELONGS_TO", direction: IN)
  meetingDay: ServiceDay @relationship(type: "MEETS_ON", direction: OUT)
  history: [HistoryLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!, skip: Int = 0): [ServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(records:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records, date
      RETURN records ORDER BY date.date DESC SKIP $skip LIMIT $limit
      """
      columnName: "services"
    )
  labels: [String]
    @cypher(
      statement: """
      MATCH (this)
      RETURN labels(this)
      """
      columnName: "labels"
    )
  council: Council
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*3]-(council:Council)
      RETURN council
      """
      columnName: "council"
    )
  hub: Hub! @relationship(type: "HAS", direction: IN)
}
 extend type Mutation {
  RemoveRoleFromMember(role: String!): Boolean!
  #resolver Mutations
  MakeOversightAdmin(adminId: ID!, oversightId: ID!, oldAdminId: ID): Member!
  RemoveOversightAdmin(adminId: ID!, newAdminId: ID!, oversightId: ID!): Member
  MakeCampusAdmin(adminId: ID!, oldAdminId: ID!, campusId: ID!): Member!
  RemoveCampusAdmin(adminId: ID!, newAdminId: ID, campusId: ID!): Member
  MakeStreamAdmin(adminId: ID!, oldAdminId: ID!, streamId: ID!): Member!
  RemoveStreamAdmin(adminId: ID!, newAdminId: ID, streamId: ID!): Member
  MakeCouncilAdmin(adminId: ID!, oldAdminId: ID, councilId: ID!): Member!
  RemoveCouncilAdmin(adminId: ID!, newAdminId: ID!, councilId: ID!): Member
  MakeGovernorshipAdmin(
    adminId: ID!
    oldAdminId: ID
    governorshipId: ID!
  ): Member!
  RemoveGovernorshipAdmin(
    adminId: ID!
    newAdminId: ID!
    governorshipId: ID!
  ): Member

  #Pastoral Roles
  MakeFellowshipLeader(
    leaderId: ID!
    fellowshipId: ID!
    oldLeaderId: ID
  ): Member!
  RemoveFellowshipLeader(
    leaderId: ID!
    newLeaderId: ID!
    fellowshipId: ID!
  ): Member
  MakeBacentaLeader(leaderId: ID!, bacentaId: ID!, oldLeaderId: ID): Member!
  RemoveBacentaLeader(leaderId: ID!, newLeaderId: ID!, bacentaId: ID!): Member
  MakeGovernorshipLeader(
    leaderId: ID!
    governorshipId: ID!
    oldLeaderId: ID
  ): Member!
  RemoveGovernorshipLeader(
    leaderId: ID!
    newLeaderId: ID!
    governorshipId: ID!
  ): Member
  MakeCouncilLeader(leaderId: ID!, councilId: ID!, oldLeaderId: ID): Member!
  RemoveCouncilLeader(leaderId: ID!, newLeaderId: ID!, councilId: ID!): Member
  MakeStreamLeader(leaderId: ID!, streamId: ID!, oldLeaderId: ID): Member!
  RemoveStreamLeader(leaderId: ID!, newLeaderId: ID!, streamId: ID!): Member
  MakeCampusLeader(leaderId: ID!, campusId: ID!, oldLeaderId: ID): Member!
  RemoveCampusLeader(leaderId: ID!, newLeaderId: ID!, campusId: ID!): Member
  MakeOversightLeader(leaderId: ID!, oversightId: ID!, oldLeaderId: ID): Member!
  RemoveOversightLeader(
    leaderId: ID!
    newLeaderId: ID!
    oversightId: ID!
  ): Member
  MakeDenominationLeader(
    leaderId: ID!
    denominationId: ID!
    oldLeaderId: ID
  ): Member!
  RemoveDenominationLeader(
    leaderId: ID!
    newLeaderId: ID!
    denominationId: ID!
  ): Member
}

#### GO ON VACATION AND COME BACK ###
extend type Mutation {
  #Set Fellowship to be 'OnVacation
  SetVacationFellowship(fellowshipId: ID!): Fellowship!
    @cypher(
      statement: """
      MATCH (fellowship:Fellowship {id:$fellowshipId})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = fellowship.name + ' Fellowship went on vacation mode'

      WITH log,fellowship
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (fellowship)<-[:HAS]-(bacenta:Bacenta)
      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (fellowship)-[:HAS_HISTORY]->(log)
      MERGE (bacenta)-[:HAS_HISTORY]->(log)

      SET fellowship:Vacation
      REMOVE fellowship:Active, fellowship:Online

      RETURN fellowship
      """
      columnName: "SetVacationFellowship"
    )
  #Set Bacenta to be 'OnVacation
  SetVacationBacenta(bacentaId: ID!): Bacenta!
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id:$bacentaId})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = bacenta.name + ' Bacenta went on vacation mode'

      WITH log,bacenta
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (bacenta)<-[:HAS]-(governorship:Governorship)
      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (bacenta)-[:HAS_HISTORY]->(log)
      MERGE (governorship)-[:HAS_HISTORY]->(log)

      SET bacenta:Vacation
      REMOVE bacenta:Active

      RETURN bacenta
      """
      columnName: "SetVacationBacenta"
    )
  SetVacationStream(streamId: ID!): Fellowship!
    @cypher(
      statement: """
      MATCH (stream:Stream {id:$streamId})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = stream.name + ' Stream went on vacation mode'

      WITH log, stream
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (stream)<-[:HAS]-(campus:Campus)
      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (stream)-[:HAS_HISTORY]->(log)
      MERGE (campus)-[:HAS_HISTORY]->(log)

      SET stream:Vacation
      REMOVE stream:Active, stream:Online

      RETURN stream
      """
      columnName: "SetVacationStream"
    )

  #Set Fellowship to be 'Active
  SetActiveStream(streamId: ID!): Stream!
    @cypher(
      statement: """
      MATCH (stream:Stream {id:$streamId})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = stream.name + ' Stream was made active again'

      WITH log,stream
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (stream)<-[:HAS]-(campus:Campus)
      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (stream)-[:HAS_HISTORY]->(log)
      MERGE (campus)-[:HAS_HISTORY]->(log)

      SET stream:Active:Stream
      REMOVE stream:Vacation, stream:Online

      RETURN stream
      """
      columnName: "SetActiveStream"
    )
  SetActiveFellowship(fellowshipId: ID!): Fellowship!
    @cypher(
      statement: """
      MATCH (fellowship:Fellowship {id:$fellowshipId})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = fellowship.name + ' Fellowship was made active again'

      WITH log,fellowship
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (fellowship)<-[:HAS]-(bacenta:Bacenta)
      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (fellowship)-[:HAS_HISTORY]->(log)
      MERGE (bacenta)-[:HAS_HISTORY]->(log)

      SET fellowship:Active:Fellowship
      REMOVE fellowship:Vacation, fellowship:Online

      RETURN fellowship
      """
      columnName: "SetActiveFellowship"
    )
  SetActiveHub(hubId: ID!): Hub!
    @cypher(
      statement: """
      MATCH (hub:Hub {id:$hubId})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = hub.name + ' Hub was made active again'

      WITH log,hub
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (hub)<-[:HAS]-(fellowship:HubCouncil)
      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (hub)-[:HAS_HISTORY]->(log)
      MERGE (fellowship)-[:HAS_HISTORY]->(log)

      SET hub:Active:Hub
      REMOVE hub:Vacation, hub:Online

      RETURN hub
      """
      columnName: "SetActiveHub"
    )
  SetVacationHub(hubId: ID!): Hub!
    @cypher(
      statement: """
      MATCH (hub:Hub {id:$hubId})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = hub.name + ' Hub went on vacation mode'

      WITH log,hub
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (hub)<-[:HAS]-(hubCouncil:HubCouncil)
      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (hub)-[:HAS_HISTORY]->(log)
      MERGE (hubCouncil)-[:HAS_HISTORY]->(log)

      SET hub:Vacation
      REMOVE hub:Active, hub:Online

      RETURN hub
      """
      columnName: "SetVacationHub"
    )

  # Set fellowship to be 'Online'
  SetOnlineFellowship(fellowshipId: ID!): Fellowship!
    @cypher(
      statement: """
      MATCH (fellowship:Fellowship {id:$fellowshipId})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = fellowship.name + ' Fellowship was made an online fellowship'

      WITH log,fellowship
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (fellowship)<-[:HAS]-(bacenta:Bacenta)
      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (fellowship)-[:HAS_HISTORY]->(log)
      MERGE (bacenta)-[:HAS_HISTORY]->(log)

      SET fellowship:Online
      REMOVE fellowship:Active, fellowship:Vacation

      RETURN fellowship
      """
      columnName: "SetOnlineFellowship"
    )

  #Set Bacenta to be 'Active
  SetActiveBacenta(bacentaId: ID!): Bacenta
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id:$bacentaId})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = bacenta.name + ' Bacenta was made active again'

      WITH log,bacenta
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (bacenta)<-[:HAS]-(governorship:Governorship)
      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (bacenta)-[:HAS_HISTORY]->(log)
      MERGE (governorship)-[:HAS_HISTORY]->(log)

      SET bacenta:Active:Bacenta
      REMOVE bacenta:Vacation

      RETURN bacenta
      """
      columnName: "SetActiveBacenta"
    )
}

# CREATE OPERATIONS
extend type Mutation {
  CreateMember(
    firstName: String!
    middleName: String
    lastName: String!
    email: String
    phoneNumber: String!
    whatsappNumber: String!
    dob: String!
    maritalStatus: String!
    gender: String!
    occupation: String
    visitationArea: String!
    bacenta: String!
    basonta: String
    pictureUrl: String!
  ): Member!

  CreateOversight(name: String!, leaderId: ID!, denominationId: ID!): Oversight
    @authentication(jwt: { roles_INCLUDES: ["adminDenomination"] })
    @cypher(
      statement: """
      CREATE (oversight:Oversight {id:apoc.create.uuid(), name:$name})


      WITH oversight
      MATCH (leader:Active:Member {id: $leaderId}) WHERE leader.email IS NOT NULL
      MATCH (currentUser:Active:Member {auth_id:$auth.jwt.sub})
      MATCH (denomination:Denomination {id: $denominationId})


        CREATE (log:HistoryLog:ServiceLog)
          SET
          log.id =  apoc.create.uuid(),
          log.timeStamp = datetime(),
          log.historyRecord =  $name +' Oversight History Begins',
          log.priority = 2

      MERGE (denomination)-[:HAS]->(oversight)
      MERGE (leader)-[:LEADS]->(oversight)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (oversight)-[:HAS_HISTORY]->(log)
      MERGE (leader)-[:HAS_HISTORY]->(log)

      RETURN oversight
      """
      columnName: "oversight"
    )

  CreateCampus(
    name: String!
    leaderId: ID!
    oversightId: ID!
    noIncomeTracking: Boolean!
    currency: String!
    conversionRateToDollar: Float!
  ): Campus
    @authentication(
      jwt: { roles_INCLUDES: ["adminOversight", "adminDenomination"] }
    )
    @cypher(
      statement: """
      CREATE (campus:Campus {id:apoc.create.uuid(), name:$name})
        SET campus.noIncomeTracking = $noIncomeTracking,
        campus.currency = $currency,
        campus.conversionRateToDollar = $conversionRateToDollar

      WITH campus
      MATCH (leader:Active:Member {id: $leaderId}) WHERE leader.email IS NOT NULL
      MATCH (currentUser:Active:Member {auth_id:$auth.jwt.sub})
      MATCH (oversight:Oversight {id: $oversightId})


       CREATE (log:HistoryLog:ServiceLog {priority: 3})
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = datetime(),
        log.historyRecord =  $name +' Campus History Begins'

      MERGE (oversight)-[:HAS]->(campus)
      MERGE (leader)-[:LEADS]->(campus)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (campus)-[:HAS_HISTORY]->(log)
      MERGE (leader)-[:HAS_HISTORY]->(log)

      RETURN campus
      """
      columnName: "campus"
    )

  CreateStream(
    name: String!
    leaderId: ID!
    campusId: ID!
    meetingDay: String!
    bankAccount: String!
  ): Stream
    @authentication(jwt: { roles_INCLUDES: ["adminCampus", "adminOversight"] })
    @cypher(
      statement: """
      CREATE (stream:Active:Stream {id:apoc.create.uuid(), name: $name})
        SET stream.bankAccount = $bankAccount

       WITH stream
        CREATE (log:HistoryLog:ServiceLog)
         SET
         log.id =  apoc.create.uuid(),
         log.timeStamp = datetime(),
         log.historyRecord =  $name +' Stream History Begins',
         log.priority = 4

       WITH log, stream
       MATCH (leader:Active:Member {id: $leaderId}) WHERE leader.email IS NOT NULL
       MATCH (currentUser:Active:Member {auth_id:$auth.jwt.sub})
       MATCH (campus:Campus {id: $campusId})
       MATCH (meetingDay:ServiceDay {day: $meetingDay})

       WITH log,stream,leader,currentUser, campus, meetingDay
       MERGE (campus)-[:HAS]->(stream)
       MERGE (stream)-[:MEETS_ON]->(meetingDay)
       MERGE (leader)-[:LEADS]->(stream)

       MERGE (date:TimeGraph {date: date()})
       MERGE (log)-[:LOGGED_BY]->(currentUser)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (stream)-[:HAS_HISTORY]->(log)
       MERGE (leader)-[:HAS_HISTORY]->(log)

       RETURN stream
      """
      columnName: "stream"
    )

  CreateCouncil(name: String!, leaderId: ID!, streamId: ID!): Council
    @authentication(jwt: { roles_INCLUDES: ["adminCampus", "adminStream"] })
    @cypher(
      statement: """
       CREATE (council:Council {id:apoc.create.uuid(), name:$name})
        SET council.weekdayBalance  = 0.0,
          council.bussingSocietyBalance = 0.0,
          council.hrAmount = 0.0,
          council.bussingAmount = 0.0

      WITH council
      MATCH (leader:Active:Member {id: $leaderId}) WHERE leader.email IS NOT NULL
      MATCH (currentUser:Active:Member {auth_id:$auth.jwt.sub})
      MATCH (stream:Stream {id: $streamId})


       CREATE (log:HistoryLog:ServiceLog)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = datetime(),
        log.historyRecord = $name +' Council History Begins',
        log.priority = 5

      MERGE (stream)-[:HAS]->(council)
      MERGE (leader)-[:LEADS]->(council)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (council)-[:HAS_HISTORY]->(log)
      MERGE (leader)-[:HAS_HISTORY]->(log)

      RETURN council
      """
      columnName: "council"
    )

  CreateGovernorship(
    name: String!
    leaderId: ID!
    councilId: ID!
  ): Governorship
    @authentication(
      jwt: { roles_INCLUDES: ["adminCampus", "adminStream", "adminCouncil"] }
    )
    @cypher(
      statement: """
       CREATE (governorship:Governorship {name: $name})
         	SET	governorship.id = apoc.create.uuid()
      WITH governorship
       CREATE (log:HistoryLog)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = datetime(),
        log.historyRecord = $name +' Governorship History Begins',
        log.priority = 6
      WITH log, governorship
      MATCH (leader:Active:Member {id: $leaderId}) WHERE leader.email IS NOT NULL
      MATCH (currentUser:Active:Member {auth_id:$auth.jwt.sub})
      MATCH (council:Council {id: $councilId})


      MERGE (council)-[:HAS]->(governorship)
      MERGE (leader)-[:LEADS]->(governorship)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (council)-[:HAS_HISTORY]->(log)
      MERGE (leader)-[:HAS_HISTORY]->(log)

      RETURN governorship
      """
      columnName: "governorship"
    )

  CreateBacenta(
    name: String!
    governorshipId: ID!
    leaderId: ID!
    meetingDay: String!
    venueLongitude: Float
    venueLatitude: Float
  ): Bacenta!
    @authentication(
      jwt: {
        roles_INCLUDES: ["adminStream", "adminCampus", "arrivalsAdminCampus"]
      }
    )
    @cypher(
      statement: """
      MATCH (lastCode:LastBankingCode)
      CREATE (bacenta:Bacenta:Red:Active {name:$name, location: point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})})
        SET	bacenta.id = apoc.create.uuid(),
        bacenta.sprinterTopUp = 0,
        bacenta.urvanTopUp = 0,
        bacenta.outbound = false,
        bacenta.bankingCode = lastCode.number,
        lastCode.number = bacenta.bankingCode

      WITH bacenta
       MATCH (leader:Active:Member {id:$leaderId}) WHERE leader.email IS NOT NULL
       MATCH (governorship:Governorship {id:$governorshipId})
       MATCH (currentUser:Active:Member {auth_id:$auth.jwt.sub})
       MATCH (meetingDay:ServiceDay {day: $meetingDay})


      CREATE (log:HistoryLog:ServiceLog)
      SET log.id = apoc.create.uuid(),
       log.timeStamp = datetime(),
       log.historyRecord = bacenta.name +' Bacenta History Begins',
       log.priority = 7

       MERGE (governorship)-[:HAS]->(bacenta)
       MERGE (leader)-[:LEADS]->(bacenta)
       MERGE (bacenta)-[:MEETS_ON]->(meetingDay)

       MERGE (date:TimeGraph {date: date()})
       MERGE (log)-[:LOGGED_BY]->(currentUser)
       MERGE (log)-[:RECORDED_ON]->(date)


      RETURN bacenta
      """
      columnName: "bacenta"
    )

  CreateFellowship(
    name: String!
    bacentaId: ID!
    leaderId: ID!
    meetingDay: String!
    venueLongitude: Float
    venueLatitude: Float
  ): Fellowship!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminCampus"
          "adminStream"
          "adminCouncil"
          "adminGovernorship"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (leader:Active:Member {id:$leaderId}) WHERE leader.email IS NOT NULL
      MATCH (lastCode:LastBankingCode)
      CREATE (fellowship:Fellowship:Active {name:$name,location: point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})})
         	SET
      	fellowship.id = apoc.create.uuid(),
        fellowship.bankingCode = lastCode.number + 1,
        lastCode.number = fellowship.bankingCode


      WITH fellowship, leader
      MATCH (bacenta:Bacenta {id: $bacentaId})
      MATCH (currentUser:Active:Member {auth_id:$auth.jwt.sub})
      MATCH (meetingDay:ServiceDay {day: $meetingDay})

      MERGE (bacenta)-[:HAS]->(fellowship)
      MERGE (leader)-[:LEADS]->(fellowship)
      MERGE (fellowship)-[:MEETS_ON]->(meetingDay)

      RETURN fellowship
      """
      columnName: "fellowship"
    )
}

### UPDATE OPERATIONS ###
extend type Mutation {
  UpdateMemberEmail(id: ID!, email: String!): Member!
  UpdateMemberAppointmentDate(id: ID!, appointmentDate: String): Member!
    @authentication(jwt: { roles_INCLUDES: ["adminDenomination"] })
    @cypher(
      statement: """
      MATCH (member:Active:Member {id: $id})
      MATCH (pastor:Title {name: 'Pastor'})
      OPTIONAL MATCH (member)-[r:HAS_TITLE]->(pastor)
      DELETE r

      WITH member, pastor
      MERGE (member)-[:HAS_TITLE {date: $appointmentDate}]->(pastor)
      RETURN member
      """
      columnName: "member"
    )
  UpdateMemberOrdinationDate(id: ID!, ordinationDate: String!): Member!
    @authentication(jwt: { roles_INCLUDES: ["adminDenomination"] })
    @cypher(
      statement: """
      MATCH (member:Active:Member {id: $id})
      MATCH (reverend:Title {name: 'Reverend'})
      OPTIONAL MATCH (member)-[r:HAS_TITLE]->(reverend)
      DELETE r

      WITH member, reverend
      MERGE (member)-[:HAS_TITLE {date: $ordinationDate}]->(reverend)
      RETURN member
      """
      columnName: "member"
    )
  UpdateMemberConsecrationDate(id: ID!, consecrationDate: String!): Member!
    @authentication(jwt: { roles_INCLUDES: ["adminDenomination"] })
    @cypher(
      statement: """
      MATCH (member:Active:Member {id: $id})
      MATCH (bishop:Title {name: 'Bishop'})
      OPTIONAL MATCH (member)-[r:HAS_TITLE]->(bishop)
      DELETE r

      WITH member,bishop
      MERGE (member)-[:HAS_TITLE {date: $consecrationDate}]->(bishop)
      RETURN member
      """
      columnName: "member"
    )

  DeleteMemberTitles(id: ID!): Member!
    @authentication(jwt: { roles_INCLUDES: ["adminDenomination"] })
    @cypher(
      statement: """
      MATCH (member:Active:Member {id: $id})
      OPTIONAL MATCH (member)-[r:HAS_TITLE]->()
       DELETE r
      RETURN member
      """
      columnName: "member"
    )
  UpdateMemberBacenta(memberId: ID!, bacentaId: ID!): Member!

  UpdateMemberBasonta(memberId: ID!, basontaId: ID!): Member!
    @cypher(
      statement: """
      MATCH (member:Active:Member {id: $memberId})
      OPTIONAL MATCH (member)-[previous:BELONGS_TO]->(:Basonta)
      DELETE previous

      WITH member
      CALL {
      	WITH member
      	WITH member  WHERE $basontaId <> 'None'
        MATCH (ministry:Basonta {id: $basontaId})
        MERGE (member)-[:BELONGS_TO]->(ministry)

        RETURN count(member)
        }

      RETURN member
      """
      columnName: "member"
    )

  UpdateMemberDetails(
    id: ID!
    firstName: String!
    middleName: String
    lastName: String!
    phoneNumber: String!
    whatsappNumber: String
    dob: String
    maritalStatus: String!
    gender: String!
    occupation: String
    bacenta: String!
    ministry: String
    pictureUrl: String!
  ): Member
    @cypher(
      statement: """
      MATCH (member:Active:Member {id:$id})
      SET
      	member.firstName = $firstName,
      	member.middleName = $middleName,
      	member.lastName = $lastName,
      	member.phoneNumber = $phoneNumber,
        member.whatsappNumber = $whatsappNumber,
      	member.pictureUrl = $pictureUrl

       CREATE (log:HistoryLog)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = datetime(),
        log.historyRecord = $firstName +' ' +$lastName+' Details were updated'

      WITH member, log
      MATCH (currentUser:Active:Member {auth_id:$auth.jwt.sub})
      MATCH (gender:Gender {gender: $gender})
      OPTIONAL MATCH (member)-[gen_rel:HAS_GENDER]-> ()
      DELETE gen_rel
      MERGE (member)-[:HAS_GENDER]-> (gender)
      MERGE (member)-[:HAS_HISTORY]->(log)
      MERGE (today:TimeGraph {date: date()})
      MERGE (log)-[:RECORDED_ON]->(today)
      MERGE (log)-[:LOGGED_BY]->(currentUser)


      WITH member
         CALL {
         	WITH member
         	WITH member  WHERE $dob IS NOT NULL
         	MERGE (date:TimeGraph {date: date($dob)})
      	WITH member,date
      	OPTIONAL MATCH (member)-[r1:WAS_BORN_ON]->()
      	DELETE r1
      	MERGE (member)-[:WAS_BORN_ON]->(date)
         	RETURN count(member)
         	}

      WITH member
         CALL {
         	WITH member
         	WITH member  WHERE $maritalStatus IS NOT NULL
         	MATCH (maritalStatus:MaritalStatus {status:$maritalStatus})
      	OPTIONAL MATCH (member)-[r1:HAS_MARITAL_STATUS]->()
      	DELETE r1
      	MERGE (member)-[:HAS_MARITAL_STATUS]-> (maritalStatus)
         	RETURN count(member)
         	}

         WITH member
         CALL {
         	WITH member
         	WITH member  WHERE $occupation IS NOT NULL
      	OPTIONAL MATCH (member)-[r1:HAS_OCCUPATION]-> ()
        MERGE (occupation:Occupation {occupation:$occupation})
      	DELETE r1
      	MERGE (member)-[:HAS_OCCUPATION]-> (occupation)
         	RETURN count(member)
         	}

      RETURN member
      """
      columnName: "member"
    )

  UpdateDenominationDetails(denominationId: ID!, name: String!): Denomination
    @authentication(jwt: { roles_INCLUDES: ["adminDenomination"] })
    @cypher(
      statement: """
      MATCH (denomination:Denomination {id: $denominationId})
      	SET denomination.name = $name

      RETURN denomination
      """
      columnName: "denomination"
    )
  UpdateOversightDetails(oversightId: ID!, name: String!): Oversight!
    @authentication(jwt: { roles_INCLUDES: ["adminDenomination"] })
    @cypher(
      statement: """
      MATCH (oversight:Oversight {id: $oversightId})
      	SET oversight.name = $name

      RETURN oversight
      """
      columnName: "oversight"
    )

  UpdateCampusDetails(
    campusId: ID!
    name: String!
    noIncomeTracking: Boolean!
    currency: String!
    conversionRateToDollar: Float!
  ): Campus
    @authentication(
      jwt: { roles_INCLUDES: ["adminOversight", "adminDenomination"] }
    )
    @cypher(
      statement: """
           MATCH (campus:Campus {id: $campusId})
           	SET campus.name = $name,
            campus.noIncomeTracking = $noIncomeTracking,
            campus.currency = $currency,
            campus.conversionRateToDollar = $conversionRateToDollar

      RETURN campus
      """
      columnName: "campus"
    )
  UpdateStreamDetails(
    streamId: ID!
    name: String!
    bankAccount: String!
    meetingDay: String!
  ): Stream
    @authentication(
      jwt: {
        roles_INCLUDES: ["adminCampus", "adminOversight", "adminDenomination"]
      }
    )
    @cypher(
      statement: """
        MATCH (stream:Stream {id: $streamId})
           	SET stream.name = $name,
            stream.bankAccount = $bankAccount

            WITH stream
                    CALL {
                     	WITH stream
                      WITH  stream WHERE $meetingDay IS NOT NULL
                      MATCH (meetingDay:ServiceDay {day: $meetingDay})
                      OPTIONAL MATCH (stream)-[r:MEETS_ON]->()
                      DELETE r
                      MERGE (stream)-[:MEETS_ON]->(meetingDay)
                     	RETURN count(stream)
                     	}

      RETURN stream
      """
      columnName: "stream"
    )
  UpdateCouncilDetails(councilId: ID!, name: String!): Council
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminCampus"
          "adminStream"
          "adminOversight"
          "adminDenomination"
        ]
      }
    )
    @cypher(
      statement: """
           MATCH (council:Council {id: $councilId})
           	SET council.name = $name

      RETURN council
      """
      columnName: "council"
    )

  UpdateGovernorshipDetails(governorshipId: ID!, name: String!): Governorship
    @authentication(
      jwt: { roles_INCLUDES: ["adminCampus", "adminStream", "adminCouncil"] }
    )
    @cypher(
      statement: """
           MATCH (governorship:Governorship {id: $governorshipId})
           	SET governorship.name = $name

      RETURN governorship
      """
      columnName: "governorship"
    )
  UpdateBacentaDetails(
    id: ID!
    name: String!
    meetingDay: String!
    venueLongitude: Float!
    venueLatitude: Float!
  ): Bacenta
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminDenomination"
          "adminOversight"
          "adminCampus"
          "adminStream"
          "adminCouncil"
          "adminGovernorship"
          "arrivalsAdminGovernorship"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id: $id})
               	SET bacenta.name = $name
              	SET bacenta.location = point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})

               WITH bacenta
                    CALL {
                     	WITH bacenta
                      WITH bacenta WHERE $meetingDay IS NOT NULL
                      MATCH (meetingDay:ServiceDay {day: $meetingDay})
                      OPTIONAL MATCH (bacenta)-[r:MEETS_ON]->()
                      DELETE r
                      MERGE (bacenta)-[:MEETS_ON]->(meetingDay)
                     	RETURN count(bacenta)
                     	}

      RETURN bacenta
      """
      columnName: "bacenta"
    )

  UpdateFellowshipDetails(
    id: ID!
    name: String!
    meetingDay: String
    venueLongitude: Float
    venueLatitude: Float
  ): Fellowship
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminCampus"
          "adminStream"
          "adminCouncil"
          "adminGovernorship"
          "leaderFellowship"
        ]
      }
    )
    @cypher(
      statement: """
               MATCH (fellowship:Fellowship {id: $id})
               	SET fellowship.name = $name
              	SET fellowship.location = point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})

               WITH fellowship
                    CALL {
                     	WITH fellowship
                      WITH fellowship WHERE $meetingDay IS NOT NULL
                      MATCH (meetingDay:ServiceDay {day: $meetingDay})
                      OPTIONAL MATCH (fellowship)-[r:MEETS_ON]->()
                      DELETE r
                      MERGE (fellowship)-[:MEETS_ON]->(meetingDay)
                     	RETURN count(fellowship)
                     	}

      RETURN fellowship
      """
      columnName: "fellowship"
    )
}

### DELETE OPERATIONS (MAKE INACTIVE) ###
extend type Mutation {
  # In the context of church data we never delete, we only render inactive
  MakeMemberInactive(id: ID!, reason: String!): Member
  CloseDownFellowship(fellowshipId: ID!, leaderId: ID!): Bacenta!
  CloseDownBacenta(bacentaId: ID!, leaderId: ID!): Governorship!
  CloseDownGovernorship(
    governorshipId: ID!
    leaderId: ID!
    adminId: ID!
  ): Council!
  CloseDownCouncil(councilId: ID!, leaderId: ID!, adminId: ID!): Stream!
  CloseDownStream(streamId: ID!, leaderId: ID!, adminId: ID!): Campus!
  CloseDownCampus(campusId: ID!, leaderId: ID!, adminId: ID!): Oversight!
  CloseDownOversight(
    oversightId: ID!
    leaderId: ID!
    adminId: ID!
  ): Denomination!

  MoveOversightToDenomination(
    oversightId: ID!
    denominationId: ID!
  ): Oversight!
    @cypher(
      statement: """
      MATCH (oversight:Oversight {id: $oversightId})
      MATCH (denomination:Denomination {id: $denominationId})
      OPTIONAL MATCH (oversight)<-[r:HAS]-(:Denomination)
      DELETE r

      MERGE (denomination)-[:HAS]->(oversight)
      RETURN oversight
      """
      columnName: "oversight"
    )

  MoveCampusToOversight(campusId: ID!, oversightId: ID!): Campus!
    @cypher(
      statement: """
      MATCH (campus:Campus {id: $campusId})
      MATCH (oversight:Oversight {id: $oversightId})
      OPTIONAL MATCH (campus)<-[r:HAS]-(:Oversight)
      DELETE r

      MERGE (oversight)-[:HAS]->(campus)
      RETURN campus
      """
      columnName: "campus"
    )

  MoveStreamToCampus(streamId: ID!, campusId: ID!): Stream!
    @cypher(
      statement: """
      MATCH (stream:Stream {id: $streamId})
      MATCH (campus:Campus {id: $campusId})
      OPTIONAL MATCH (stream)<-[r:HAS]-(:Campus)
      DELETE r

      MERGE (campus)-[:HAS]->(stream)
      RETURN stream
      """
      columnName: "stream"
    )

  MoveCouncilToStream(councilId: ID!, streamId: ID!): Council!
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})
      MATCH (stream:Stream {id: $streamId})
      OPTIONAL MATCH (council)<-[r:HAS]-(:Stream)
      DELETE r

      MERGE (stream)-[:HAS]->(council)
      RETURN council
      """
      columnName: "council"
    )

  MoveGovernorshipToCouncil(governorshipId: ID!, councilId: ID!): Governorship!
    @cypher(
      statement: """
      MATCH (governorship:Governorship {id: $governorshipId})
      MATCH (council:Council {id: $councilId})
      OPTIONAL MATCH (governorship)<-[r:HAS]-(:Council)
      DELETE r

      MERGE (council)-[:HAS]->(governorship)
      RETURN governorship
      """
      columnName: "governorship"
    )
  MoveBacentaToGovernorship(bacentaId: ID!, governorshipId: ID!): Bacenta!
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id: $bacentaId})
      MATCH (governorship:Governorship {id: $governorshipId})
      OPTIONAL MATCH (bacenta)<-[r:HAS]-(:Governorship)
      DELETE r

      MERGE (governorship)-[:HAS]->(bacenta)
      RETURN bacenta
      """
      columnName: "bacenta"
    )

  MoveFellowshipToBacenta(fellowshipId: ID!, bacentaId: ID!): Fellowship!
    @cypher(
      statement: """
      MATCH (fellowship:Fellowship {id: $fellowshipId})
      MATCH (bacenta:Bacenta {id: $bacentaId})
      OPTIONAL MATCH (fellowship)<-[r:HAS]-(:Bacenta)
      DELETE r

      MERGE (bacenta)-[:HAS]->(fellowship)
      RETURN fellowship
      """
      columnName: "fellowship"
    )

  MoveCreativeArtsToCampus(creativeArtsId: ID!, campusId: ID!): CreativeArts!
    @cypher(
      statement: """
      MATCH (creativeArts:CreativeArts {id: $creativeArtsId})
      MATCH (campus:Campus {id: $campusId})
      OPTIONAL MATCH (creativeArts)<-[r:HAS_MINISTRY]-(:Campus)
      DELETE r

      MERGE (campus)-[:HAS_MINISTRY]->(creativeArts)
      RETURN creativeArts
      """
      columnName: "creativeArts"
    )

  MoveMinistryToCreativeArts(ministryId: ID!, creativeArtsId: ID!): Ministry!
    @cypher(
      statement: """
      MATCH (ministry:Ministry {id: $ministryId})
      MATCH (creativeArts:CreativeArts {id: $creativeArtsId})
      OPTIONAL MATCH (ministry)<-[r:HAS]-(:CreativeArts)
      DELETE r

      MERGE (creativeArts)-[:HAS]->(ministry)
      RETURN ministry
      """
      columnName: "ministry"
    )
  MoveMinistryToStream(ministryId: ID!, streamId: ID!): Ministry!
    @cypher(
      statement: """
      MATCH (ministry:Ministry {id: $ministryId})
      MATCH (stream:Stream {id: $streamId})
      OPTIONAL MATCH (ministry)<-[r:HAS_MINISTRY]-(:Stream)
      DELETE r

      MERGE (stream)-[:HAS_MINISTRY]->(ministry)
      RETURN ministry
      """
      columnName: "ministry"
    )
  MoveHubCouncilToMinistry(hubCouncilId: ID!, ministryId: ID!): HubCouncil!
    @cypher(
      statement: """
      MATCH (hubCouncil:HubCouncil {id: $hubCouncilId})
      MATCH (ministry:Ministry {id: $ministryId})
      OPTIONAL MATCH (hubCouncil)<-[r:HAS]-(:Ministry)
      DELETE r

      MERGE (ministry)-[:HAS]->(hubCouncil)
      RETURN hubCouncil
      """
      columnName: "hubCouncil"
    )
  MoveHubCouncilToCouncil(hubCouncilId: ID!, councilId: ID!): HubCouncil!
    @cypher(
      statement: """
      MATCH (hubCouncil:HubCouncil {id: $hubCouncilId})
      MATCH (council:Council {id: $councilId})
      OPTIONAL MATCH (hubCouncil)<-[r:HAS_MINISTRY]-(:Council)
      DELETE r

      MERGE (council)-[:HAS_MINISTRY]->(hubCouncil)
      RETURN hubCouncil
      """
      columnName: "hubCouncil"
    )
  MoveHubToHubCouncil(hubId: ID!, hubCouncilId: ID!): Hub!
    @cypher(
      statement: """
      MATCH (hub:Hub {id: $hubId})
      MATCH (hubCouncil:HubCouncil {id: $hubCouncilId})
      OPTIONAL MATCH (hub)<-[r:HAS]-(:HubCouncil)
      DELETE r

      MERGE (hubCouncil)-[:HAS]->(hub)
      RETURN hub
      """
      columnName: "hub"
    )
  MoveHubToGovernorship(hubId: ID!, governorshipId: ID!): Hub!
    @cypher(
      statement: """
      MATCH (hub:Hub {id: $hubId})
      MATCH (governorship:Governorship {id: $governorshipId})
      OPTIONAL MATCH (hub)<-[r:HAS_MINISTRY]-(:Governorship)
      DELETE r

      MERGE (governorship)-[:HAS_MINISTRY]->(hub)
      RETURN hub
      """
      columnName: "hub"
    )
  MoveHubFellowshipToHub(hubFellowshipId: ID!, hubId: ID!): HubFellowship!
    @cypher(
      statement: """
      MATCH (hubFellowship:HubFellowship {id: $hubFellowshipId})
      MATCH (hub:Hub {id: $hubId})
      OPTIONAL MATCH (hubFellowship)<-[r:HAS]-(:Hub)
      DELETE r

      MERGE (hub)-[:HAS]->(hubFellowship)
      RETURN hubFellowship
      """
      columnName: "hubFellowship"
    )
}
 extend type Mutation {
  LogStreamHistory(
    streamId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newCampusId: ID
    oldCampusId: ID
  ): Stream
    @cypher(
      statement: """
      MATCH  (stream:Stream {id: $streamId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (stream)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,stream
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Active:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,stream
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Active:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,stream
      CALL {
        WITH log
        WITH log WHERE $oldCampusId IS NOT NULL
        MATCH (campus:Campus {id: $oldCampusId})
        MERGE (campus)-[:OLD_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,stream
      CALL {
        WITH log
        WITH log WHERE $newCampusId IS NOT NULL
        MATCH (campus:Campus {id: $newCampusId})
        MERGE (campus)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN stream
      """
      columnName: "stream"
    )

  LogCampusHistory(
    campusId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newOversightId: ID
    oldOversightId: ID
  ): Campus
    @cypher(
      statement: """
      MATCH  (campus:Campus {id: $campusId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (campus)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,campus
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Active:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,campus
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Active:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:OLD_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,campus
      CALL {
        WITH log
        WITH log WHERE $oldOversightId IS NOT NULL
        MATCH (oversight:Oversight {id: $oldOversightId})
        MERGE (oversight)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,campus
      CALL {
        WITH log
        WITH log WHERE $newOversightId IS NOT NULL
        MATCH (oversight:Oversight {id: $newOversightId})
        MERGE (oversight)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN campus
      """
      columnName: "campus"
    )

  LogOversightHistory(
    oversightId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    oldDenominationId: ID
    newDenominationId: ID
  ): Oversight!
    @cypher(
      statement: """
      MATCH  (oversight:Oversight {id: $oversightId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (oversight)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,oversight
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Active:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log, oversight
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Active:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:OLD_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log, oversight
      CALL {
        WITH log
        WITH log WHERE $oldDenominationId IS NOT NULL
        MATCH (denomination:Denomination {id: $oldDenominationId})
        MERGE (denomination)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log, oversight
      CALL {
        WITH log
        WITH log WHERE $newDenominationId IS NOT NULL
        MATCH (denomination:Denomination {id: $newDenominationId})
        MERGE (denomination)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN oversight
      """
      columnName: "oversight"
    )

  LogDenominationHistory(
    denominationId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
  ): Denomination!
    @cypher(
      statement: """
      MATCH  (denomination:Denomination {id: $denominationId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (denomination)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log, denomination
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Active:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,denomination
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Active:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:OLD_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN denomination
      """
      columnName: "denomination"
    )

  LogMemberHistory(ids: [ID], historyRecord: String!): Member
    @cypher(
      statement: """
       CREATE (log:HistoryLog)
         SET log.id = apoc.create.uuid(),
          log.timeStamp = datetime(),
          log.historyRecord = $historyRecord

       WITH  log
      MERGE (date:TimeGraph {date: date()})

      WITH log, date
      MATCH (author:Active:Member {auth_id: $auth.jwt.sub})
       MERGE (log)-[:LOGGED_BY]->(author)
       MERGE (log)-[:RECORDED_ON]->(date)


      WITH log
       UNWIND $ids AS nodeId
       MATCH (node {id: nodeId}) WHERE node:Active:Member OR node:Fellowship
       MERGE (node)-[:HAS_HISTORY]->(log)

       WITH node WHERE node:Active:Member

      RETURN node
      """
      columnName: "member"
    )

  LogFellowshipHistory(
    fellowshipId: ID!
    historyRecord: String!
    oldLeaderId: ID
    newLeaderId: ID
    oldBacentaId: ID
    newBacentaId: ID
  ): Fellowship
    @cypher(
      statement: """
      MATCH  (fellowship:Fellowship {id: $fellowshipId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (fellowship)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)


      WITH log,fellowship
      CALL{
        WITH log
        WITH log WHERE $oldBacentaId IS NOT NULL
        MATCH (oldBacenta:Bacenta {id: $oldBacentaId})
        MERGE (oldBacenta)-[:OLD_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,fellowship
      CALL{
        WITH log
        WITH log WHERE $newBacentaId IS NOT NULL
        MATCH (newBacenta:Bacenta {id: $newBacentaId})
        MERGE (newBacenta)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN fellowship
      """
      columnName: "fellowship"
    )
  LogBacentaHistory(
    bacentaId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newGovernorshipId: ID
    oldGovernorshipId: ID
  ): Bacenta
    @cypher(
      statement: """
       MATCH  (bacenta:Bacenta {id: $bacentaId})
       MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
       CREATE (log:HistoryLog {id: apoc.create.uuid()})
         SET log.historyRecord = $historyRecord,
           log.timeStamp = datetime()
       MERGE (date:TimeGraph {date: date()})
       MERGE (bacenta)-[r:HAS_HISTORY]->(log)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (log)-[:LOGGED_BY]->(admin)

       WITH log,bacenta
       CALL{
         WITH log
         WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Active:Member {id: $newLeaderId})
      OPTIONAL MATCH (oldLeader:Active:Member {id: $oldLeaderId})
         SET log :ServiceLog
         WITH log, newLeader,oldLeader
       OPTIONAl MATCH (log)<-[r0:HAS_HISTORY]-()
         WITH log,newLeader,oldLeader
       CREATE (oldLeader)-[:HAS_HISTORY]->(log)
       CREATE (newLeader)-[:HAS_HISTORY]->(log)

          WITH log
       RETURN COUNT(log)
       }


       WITH log,bacenta
       CALL {
         WITH log
         WITH log WHERE $oldGovernorshipId IS NOT NULL
         MATCH (oldgovernorship:Governorship {id: $oldGovernorshipId})
         MERGE (oldgovernorship)-[:OLD_HISTORY]->(log)
         RETURN COUNT(log)
       }

       WITH log,bacenta
       CALL {
         WITH log
         WITH log WHERE $newGovernorshipId IS NOT NULL
         MATCH (newgovernorship:Governorship {id: $newGovernorshipId})
         MERGE (newgovernorship)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       RETURN bacenta
      """
      columnName: "bacenta"
    )
  LogGovernorshipHistory(
    governorshipId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newCouncilId: ID
    oldCouncilId: ID
  ): Governorship
    @cypher(
      statement: """
      MATCH (governorship:Governorship {id: $governorshipId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (governorship)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,governorship
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Active:Member {id: $newLeaderId})
        SET log:ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,governorship
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Active:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,governorship
      CALL {
        WITH log
        WITH log WHERE $oldCouncilId IS NOT NULL
        MATCH (council:Council {id: $oldCouncilId})
        MERGE (council)-[:OLD_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,governorship
      CALL {
        WITH log
        WITH log WHERE $newCouncilId IS NOT NULL
        MATCH (council:Council {id: $newCouncilId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN governorship
      """
      columnName: "governorship"
    )

  LogCouncilHistory(
    councilId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newStreamId: ID
    oldStreamId: ID
  ): Council
    @cypher(
      statement: """
      MATCH  (council:Council {id: $councilId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (council)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,council
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Active:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Active:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $oldStreamId IS NOT NULL
        MATCH (council:Council {id: $oldStreamId})
        MERGE (council)-[:OLD_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $newStreamId IS NOT NULL
        MATCH (council:Council {id: $newStreamId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN council
      """
      columnName: "result"
    )

  ### CREATIVE ARTS ###
  LogCreativeArtsHistory(
    creativeArtsId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newCampusId: ID
    oldCampusId: ID
  ): CreativeArts!
    @cypher(
      statement: """
      MATCH  (creativeArts:CreativeArts {id: $creativeArtsId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (creativeArts)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log, creativeArts
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Active:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log, creativeArts
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Active:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log, creativeArts
      CALL {
        WITH log
        WITH log WHERE $oldCampusId IS NOT NULL
        MATCH (campus:Campus {id: $oldCampusId})
        MERGE (campus)-[:OLD_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log, creativeArts
      CALL {
        WITH log
        WITH log WHERE $newCampusId IS NOT NULL
        MATCH (campus:Campus {id: $newCampusId})
        MERGE (campus)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN creativeArts
      """
      columnName: "creativeArts"
    )

  LogMinistryHistory(
    ministryId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newCreativeArtsId: ID
    oldCreativeArtsId: ID
  ): Ministry!
    @cypher(
      statement: """
        MATCH  (ministry:Ministry {id: $ministryId})
        MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
        CREATE (log:HistoryLog {id: apoc.create.uuid()})
          SET log.historyRecord = $historyRecord,
            log.timeStamp = datetime()
        MERGE (date:TimeGraph {date: date()})
        MERGE (ministry)-[r:HAS_HISTORY]->(log)
        MERGE (log)-[:RECORDED_ON]->(date)
        MERGE (log)-[:LOGGED_BY]->(admin)

        WITH log,ministry
        CALL{
          WITH log
          WITH log WHERE $newLeaderId IS NOT NULL
        MATCH (newLeader:Active:Member {id: $newLeaderId})
          SET log :ServiceLog
          WITH log, newLeader
        OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
          WITH log,newLeader
        CREATE (newLeader)-[r:HAS_HISTORY]->(log)
           SET r.current = true
           WITH log
        RETURN COUNT(log)
        }

        WITH log, ministry
        CALL {
          WITH log
          WITH log WHERE $oldLeaderId IS NOT NULL
          MATCH (oldLeader:Active:Member {id: $oldLeaderId})
          CREATE (oldLeader)-[:HAS_HISTORY]->(log)
          RETURN COUNT(log)
        }

        WITH log, ministry
        CALL {
          WITH log
          WITH log WHERE $oldCreativeArtsId IS NOT NULL
          MATCH (creativeArts:CreativeArts {id: $oldCreativeArtsId})
          MERGE (creativeArts)-[:OLD_HISTORY]->(log)
          RETURN COUNT(log)
        }

        WITH log, ministry
        CALL {
          WITH log
          WITH log WHERE $newCreativeArtsId IS NOT NULL
          MATCH (creativeArts:CreativeArts {id: $newCreativeArtsId})
          MERGE (creativeArts)-[:HAS_HISTORY]->(log)
          RETURN COUNT(log)
        }

      RETURN ministry
      """
      columnName: "ministry"
    )
  LogMinistryHistoryWithStream(
    ministryId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newStreamId: ID
    oldStreamId: ID
  ): Ministry!
    @cypher(
      statement: """
        MATCH  (ministry:Ministry {id: $ministryId})
        MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
        CREATE (log:HistoryLog {id: apoc.create.uuid()})
          SET log.historyRecord = $historyRecord,
            log.timeStamp = datetime()
        MERGE (date:TimeGraph {date: date()})
        MERGE (ministry)-[r:HAS_HISTORY]->(log)
        MERGE (log)-[:RECORDED_ON]->(date)
        MERGE (log)-[:LOGGED_BY]->(admin)

        WITH log,ministry
        CALL{
          WITH log
          WITH log WHERE $newLeaderId IS NOT NULL
        MATCH (newLeader:Active:Member {id: $newLeaderId})
          SET log :ServiceLog
          WITH log, newLeader
        OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
          WITH log,newLeader
        CREATE (newLeader)-[r:HAS_HISTORY]->(log)
           SET r.current = true
           WITH log
        RETURN COUNT(log)
        }

        WITH log, ministry
        CALL {
          WITH log
          WITH log WHERE $oldLeaderId IS NOT NULL
          MATCH (oldLeader:Active:Member {id: $oldLeaderId})
          CREATE (oldLeader)-[:HAS_HISTORY]->(log)
          RETURN COUNT(log)
        }

        WITH log, ministry
        CALL {
          WITH log
          WITH log WHERE $oldStreamId IS NOT NULL
          MATCH (stream:Stream {id: $oldStreamId})
          MERGE (stream)-[:OLD_HISTORY]->(log)
          RETURN COUNT(log)
        }

        WITH log, ministry
        CALL {
          WITH log
          WITH log WHERE $newStreamId IS NOT NULL
          MATCH (stream:Stream {id: $newStreamId})
          MERGE (stream)-[:HAS_HISTORY]->(log)
          RETURN COUNT(log)
        }

      RETURN ministry
      """
      columnName: "ministry"
    )
  LogHubCouncilHistory(
    hubCouncilId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newMinistryId: ID
    oldMinistryId: ID
  ): HubCouncil!
    @cypher(
      statement: """
        MATCH  (hubCouncil:HubCouncil {id: $hubCouncilId})
        MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
        CREATE (log:HistoryLog {id: apoc.create.uuid()})
          SET log.historyRecord = $historyRecord,
            log.timeStamp = datetime()
        MERGE (date:TimeGraph {date: date()})
        MERGE (hubCouncil)-[r:HAS_HISTORY]->(log)
        MERGE (log)-[:RECORDED_ON]->(date)
        MERGE (log)-[:LOGGED_BY]->(admin)

        WITH log,hubCouncil
        CALL{
          WITH log
          WITH log WHERE $newLeaderId IS NOT NULL
        MATCH (newLeader:Active:Member {id: $newLeaderId})
          SET log :ServiceLog
          WITH log, newLeader
        OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
          WITH log,newLeader
        CREATE (newLeader)-[r:HAS_HISTORY]->(log)
           SET r.current = true
           WITH log
        RETURN COUNT(log)
        }

        WITH log, hubCouncil
        CALL {
          WITH log
          WITH log WHERE $oldLeaderId IS NOT NULL
          MATCH (oldLeader:Active:Member {id: $oldLeaderId})
          CREATE (oldLeader)-[:HAS_HISTORY]->(log)
          RETURN COUNT(log)
        }

        WITH log, hubCouncil
        CALL {
          WITH log
          WITH log WHERE $oldMinistryId IS NOT NULL
          MATCH (ministry:Ministry {id: $oldMinistryId})
          MERGE (ministry)-[:OLD_HISTORY]->(log)
          RETURN COUNT(log)
        }

        WITH log, hubCouncil
        CALL {
          WITH log
          WITH log WHERE $newMinistryId IS NOT NULL
          MATCH (ministry:Ministry {id: $newMinistryId})
          MERGE (ministry)-[:HAS_HISTORY]->(log)
          RETURN COUNT(log)
        }

      RETURN hubCouncil
      """
      columnName: "hubCouncil"
    )
  LogHubCouncilHistoryWithCouncil(
    hubCouncilId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newCouncilId: ID
    oldCouncilId: ID
  ): HubCouncil!
    @cypher(
      statement: """
        MATCH  (hubCouncil:HubCouncil {id: $hubCouncilId})
        MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
        CREATE (log:HistoryLog {id: apoc.create.uuid()})
          SET log.historyRecord = $historyRecord,
            log.timeStamp = datetime()
        MERGE (date:TimeGraph {date: date()})
        MERGE (hubCouncil)-[r:HAS_HISTORY]->(log)
        MERGE (log)-[:RECORDED_ON]->(date)
        MERGE (log)-[:LOGGED_BY]->(admin)

        WITH log,hubCouncil
        CALL{
          WITH log
          WITH log WHERE $newLeaderId IS NOT NULL
        MATCH (newLeader:Active:Member {id: $newLeaderId})
          SET log :ServiceLog
          WITH log, newLeader
        OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
          WITH log,newLeader
        CREATE (newLeader)-[r:HAS_HISTORY]->(log)
           SET r.current = true
           WITH log
        RETURN COUNT(log)
        }

        WITH log, hubCouncil
        CALL {
          WITH log
          WITH log WHERE $oldLeaderId IS NOT NULL
          MATCH (oldLeader:Active:Member {id: $oldLeaderId})
          CREATE (oldLeader)-[:HAS_HISTORY]->(log)
          RETURN COUNT(log)
        }

        WITH log, hubCouncil
        CALL {
          WITH log
          WITH log WHERE $oldCouncilId IS NOT NULL
          MATCH (council:Council {id: $oldCouncilId})
          MERGE (council)-[:OLD_HISTORY]->(log)
          RETURN COUNT(log)
        }

        WITH log, hubCouncil
        CALL {
          WITH log
          WITH log WHERE $newCouncilId IS NOT NULL
          MATCH (council:Council {id: $newCouncilId})
          MERGE (council)-[:HAS_HISTORY]->(log)
          RETURN COUNT(log)
        }

      RETURN hubCouncil
      """
      columnName: "hubCouncil"
    )

  LogHubHistory(
    hubId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newHubCouncilId: ID
    oldHubCouncilId: ID
  ): Hub!
    @cypher(
      statement: """
        MATCH  (hub:Hub {id: $hubId})
        MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
        CREATE (log:HistoryLog {id: apoc.create.uuid()})
          SET log.historyRecord = $historyRecord,
            log.timeStamp = datetime()
        MERGE (date:TimeGraph {date: date()})
        MERGE (hub)-[r:HAS_HISTORY]->(log)
        MERGE (log)-[:RECORDED_ON]->(date)
        MERGE (log)-[:LOGGED_BY]->(admin)

        WITH log,hub
        CALL{
          WITH log
          WITH log WHERE $newLeaderId IS NOT NULL
        MATCH (newLeader:Active:Member {id: $newLeaderId})
          SET log :ServiceLog
          WITH log, newLeader
        OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
          WITH log,newLeader
        CREATE (newLeader)-[r:HAS_HISTORY]->(log)
           SET r.current = true
           WITH log
        RETURN COUNT(log)
        }

        WITH log, hub
        CALL {
          WITH log
          WITH log WHERE $oldLeaderId IS NOT NULL
          MATCH (oldLeader:Active:Member {id: $oldLeaderId})
          CREATE (oldLeader)-[:HAS_HISTORY]->(log)
          RETURN COUNT(log)
        }

        WITH log, hub
        CALL {
          WITH log
          WITH log WHERE $oldHubCouncilId IS NOT NULL
          MATCH (hubCouncil:HubCouncil {id: $oldHubCouncilId})
          MERGE (hubCouncil)-[:OLD_HISTORY]->(log)
          RETURN COUNT(log)
        }

        WITH log, hub
        CALL {
          WITH log
          WITH log WHERE $newHubCouncilId IS NOT NULL
          MATCH (hubCouncil:HubCouncil {id: $newHubCouncilId})
          MERGE (hubCouncil)-[:HAS_HISTORY]->(log)
          RETURN COUNT(log)
        }

      RETURN hub
      """
      columnName: "hub"
    )
  LogHubHistoryWithGovernorship(
    hubId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newGovernorshipId: ID
    oldGovernorshipId: ID
  ): Hub!
    @cypher(
      statement: """
      MATCH  (hub:Hub {id: $hubId})
        MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
        CREATE (log:HistoryLog {id: apoc.create.uuid()})
          SET log.historyRecord = $historyRecord,
            log.timeStamp = datetime()
        MERGE (date:TimeGraph {date: date()})
        MERGE (hub)-[r:HAS_HISTORY]->(log)
        MERGE (log)-[:RECORDED_ON]->(date)
        MERGE (log)-[:LOGGED_BY]->(admin)

        WITH log,hub
        CALL{
          WITH log
          WITH log WHERE $newLeaderId IS NOT NULL
        MATCH (newLeader:Active:Member {id: $newLeaderId})
          SET log :ServiceLog
          WITH log, newLeader
        OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
          WITH log,newLeader
        CREATE (newLeader)-[r:HAS_HISTORY]->(log)
           SET r.current = true
           WITH log
        RETURN COUNT(log)
        }

        WITH log, hub
        CALL {
          WITH log
          WITH log WHERE $oldLeaderId IS NOT NULL
          MATCH (oldLeader:Active:Member {id: $oldLeaderId})
          CREATE (oldLeader)-[:HAS_HISTORY]->(log)
          RETURN COUNT(log)
        }

        WITH log, hub
        CALL {
          WITH log
          WITH log WHERE $oldGovernorshipId IS NOT NULL
          MATCH (governorship:Governorship {id: $oldGovernorshipId})
          MERGE (governorship)-[:OLD_HISTORY]->(log)
          RETURN COUNT(log)
        }

        WITH log, hub
        CALL {
          WITH log
          WITH log WHERE $newGovernorshipId IS NOT NULL
          MATCH (governorship:Governorship {id: $newGovernorshipId})
          MERGE (governorship)-[:HAS_HISTORY]->(log)
          RETURN COUNT(log)
        }

      RETURN hub
      """
      columnName: "hub"
    )
  LogHubFellowshipHistory(
    hubFellowshipId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newHubId: ID
    oldHubId: ID
  ): HubFellowship!
    @cypher(
      statement: """
        MATCH  (hubFellowship:HubFellowship {id: $hubFellowshipId})
        MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
        CREATE (log:HistoryLog {id: apoc.create.uuid()})
          SET log.historyRecord = $historyRecord,
            log.timeStamp = datetime()
        MERGE (date:TimeGraph {date: date()})
        MERGE (hubFellowship)-[r:HAS_HISTORY]->(log)
        MERGE (log)-[:RECORDED_ON]->(date)
        MERGE (log)-[:LOGGED_BY]->(admin)

        WITH log,hubFellowship
        CALL{
          WITH log
          WITH log WHERE $newLeaderId IS NOT NULL
        MATCH (newLeader:Active:Member {id: $newLeaderId})
          SET log :ServiceLog
          WITH log, newLeader
        OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
          WITH log,newLeader
        CREATE (newLeader)-[r:HAS_HISTORY]->(log)
           SET r.current = true
           WITH log
        RETURN COUNT(log)
        }

        WITH log, hubFellowship
        CALL {
          WITH log
          WITH log WHERE $oldLeaderId IS NOT NULL
          MATCH (oldLeader:Active:Member {id: $oldLeaderId})
          CREATE (oldLeader)-[:HAS_HISTORY]->(log)
          RETURN COUNT(log)
        }

        WITH log, hubFellowship
        CALL {
          WITH log
          WITH log WHERE $oldHubId IS NOT NULL
          MATCH (hub:Hub {id: $oldHubId})
          MERGE (hub)-[:OLD_HISTORY]->(log)
          RETURN COUNT(log)
        }

        WITH log, hubFellowship
        CALL {
          WITH log
          WITH log WHERE $newHubId IS NOT NULL
          MATCH (hub:Hub {id: $newHubId})
          MERGE (hub)-[:HAS_HISTORY]->(log)
          RETURN COUNT(log)
        }

      RETURN hubFellowship
      """
      columnName: "hubFellowship"
    )
}
 extend type Member {
  memberSearch(key: String!, limit: Int! = 5): [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|DOES_ARRIVALS_FOR|IS_ADMIN_FOR|IS_SHEEP_SEEKER_FOR*1..7]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      WHERE toLower(members.firstName+ ' ' + members.middleName + ' ' + members.lastName) CONTAINS toLower($key)
      OR toLower(members.firstName + ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName) LIMIT $limit
      """
      columnName: "memberSearch"
    )
  basontaMemberSearch(key: String!, limit: Int! = 5): [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:BELONGS_TO]->(basonta:Basonta)
      MATCH (this)-[:LEADS|IS_ADMIN_FOR]->(creativeLevel)<-[:HAS_MINISTRY]-(bacentaLevel)-[:HAS*2..4]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      WHERE creativeLevel:Hub OR creativeLevel:HubCouncil OR creativeLevel:Ministry OR creativeLevel:CreativeArts
      MATCH (members)-[:BELONGS_TO]->(basonta)
      WHERE toLower(members.firstName+ ' ' + members.middleName + ' ' + members.lastName) CONTAINS toLower($key)
      OR toLower(members.firstName + ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName) LIMIT $limit
      """
      columnName: "basontaMemberSearch"
    )
  basontaMemberSearchFromHub(
    hubId: ID!
    key: String!
    limit: Int! = 5
  ): [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|IS_ADMIN_FOR]->(creativeChurch)<-[:HAS_MINISTRY]-(bacentaChurch)-[:HAS*2..4]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      WHERE creativeChurch:Hub OR creativeChurch:HubCouncil OR creativeChurch:Ministry OR creativeChurch:CreativeArts
      AND bacentaChurch:Governorship OR bacentaChurch:Council OR bacentaChurch:Stream OR bacentaChurch:Campus

      MATCH (hub:Hub {id: $hubId})<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(creative:CreativeArts)
      MATCH (members)-[:BELONGS_TO]->(creative)
      WHERE toLower(members.firstName+ ' ' + members.middleName + ' ' + members.lastName) CONTAINS toLower($key)
      OR toLower(members.firstName + ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName) LIMIT $limit
      """
      columnName: "basontaMemberSearchFromHub"
    )
  fellowshipSearch(key: String!, limit: Int! = 5): [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|DOES_ARRIVALS_FOR|IS_ADMIN_FOR|IS_SHEEP_SEEKER_FOR*1..8]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) CONTAINS toLower($key)
      RETURN DISTINCT fellowship LIMIT $limit
      """
      columnName: "fellowshipSearch"
    )
  bacentaSearch(key: String!, limit: Int! = 5): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|DOES_ARRIVALS_FOR|IS_ADMIN_FOR|IS_SHEEP_SEEKER_FOR*1..7]->(bacenta:Bacenta)
      WHERE toLower(bacenta.name) CONTAINS toLower($key)
      RETURN DISTINCT bacenta LIMIT $limit
      """
      columnName: "bacentaSearch"
    )
  governorshipSearch(key: String!, limit: Int! = 5): [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|DOES_ARRIVALS_FOR|IS_ADMIN_FOR|IS_SHEEP_SEEKER_FOR*1..6]->(governorship:Governorship)
      WHERE toLower(governorship.name) CONTAINS toLower($key)
      RETURN DISTINCT governorship LIMIT $limit
      """
      columnName: "governorshipSearch"
    )
  councilSearch(key: String!, limit: Int! = 5): [Council!]!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|DOES_ARRIVALS_FOR|IS_ADMIN_FOR|IS_SHEEP_SEEKER_FOR*1..5]->(council:Council)
      WHERE toLower(council.name) CONTAINS toLower($key)
      RETURN DISTINCT council LIMIT $limit
      """
      columnName: "councilSearch"
    )
  streamSearch(key: String!, limit: Int! = 5): [Stream!]!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|DOES_ARRIVALS_FOR|IS_ADMIN_FOR|IS_SHEEP_SEEKER_FOR*1..4]->(stream:Stream)
      WHERE toLower(stream.name) CONTAINS toLower($key)
      RETURN DISTINCT stream LIMIT $limit
      """
      columnName: "streamSearch"
    )
  campusSearch(key: String!, limit: Int! = 5): [Campus!]!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|DOES_ARRIVALS_FOR|IS_ADMIN_FOR*1..3]->(campus:Campus)
      WHERE toLower(campus.name) CONTAINS toLower($key)
      RETURN DISTINCT campus LIMIT $limit
      """
      columnName: "campusSearch"
    )
  oversightSearch(key: String!, limit: Int! = 5): [Oversight!]!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR*1..2]->(oversight:Oversight)
      WHERE toLower(oversight.name) CONTAINS toLower($key)
      RETURN DISTINCT oversight LIMIT $limit
      """
      columnName: "oversightSearch"
    )

  creativeArtsSearch(key: String!, limit: Int! = 5): [CreativeArts!]!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|HAS_MINISTRY|IS_ADMIN_FOR*1..4]->(creativeArts:CreativeArts)
      WHERE toLower(creativeArts.name) CONTAINS toLower($key)
      RETURN DISTINCT creativeArts LIMIT $limit
      """
      columnName: "creativeArtsSearch"
    )
  ministrySearch(key: String!, limit: Int! = 5): [Ministry!]!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|HAS_MINISTRY|IS_ADMIN_FOR*1..5]->(ministry:Ministry)
      WHERE toLower(ministry.name) CONTAINS toLower($key)
      RETURN DISTINCT ministry LIMIT $limit
      """
      columnName: "ministrySearch"
    )
  hubCouncilSearch(key: String!, limit: Int! = 5): [HubCouncil!]!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|HAS_MINISTRY|IS_ADMIN_FOR*1..6]->(hub:HubCouncil)
      WHERE toLower(hub.name) CONTAINS toLower($key)
      RETURN DISTINCT hub LIMIT $limit
      """
      columnName: "hubCouncilSearch"
    )
  hubSearch(key: String!, limit: Int! = 5): [Hub!]!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|HAS_MINISTRY|IS_ADMIN_FOR*1..7]->(hub:Hub)
      WHERE toLower(hub.name) CONTAINS toLower($key)
      RETURN DISTINCT hub LIMIT $limit
      """
      columnName: "hubSearch"
    )
  hubFellowshipSearch(key: String!, limit: Int! = 5): [HubFellowship!]!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|HAS_MINISTRY|IS_ADMIN_FOR*1..8]->(hub:HubFellowship)
      WHERE toLower(hub.name) CONTAINS toLower($key)
      RETURN DISTINCT hub LIMIT $limit
      """
      columnName: "hubFellowshipSearch"
    )
}

extend type Denomination {
  memberSearch(key: String!, limit: Int!): [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*7]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName) LIMIT $limit
      """
      columnName: "memberSearch"
    )
  fellowshipSearch(key: String!, limit: Int!): [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*7]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) CONTAINS toLower($key)
      RETURN DISTINCT fellowship LIMIT $limit
      """
      columnName: "fellowshipSearch"
    )
  bacentaSearch(key: String!, limit: Int!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*6]->(bacenta:Bacenta)
      WHERE toLower(bacenta.name) CONTAINS toLower($key)
      RETURN DISTINCT bacenta LIMIT $limit
      """
      columnName: "bacentaSearch"
    )
  governorshipSearch(key: String!, limit: Int!): [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(governorship:Governorship)
      WHERE toLower(governorship.name) CONTAINS toLower($key)
      RETURN DISTINCT governorship LIMIT $limit
      """
      columnName: "governorshipSearch"
    )
  councilSearch(key: String!, limit: Int!): [Council!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(council:Council)
      WHERE toLower(council.name) CONTAINS toLower($key)
      RETURN DISTINCT council LIMIT $limit
      """
      columnName: "councilSearch"
    )
  streamSearch(key: String!, limit: Int!): [Stream!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(stream:Stream)
      WHERE toLower(stream.name) CONTAINS toLower($key)
      RETURN DISTINCT stream LIMIT $limit
      """
      columnName: "streamSearch"
    )
  campusSearch(key: String!, limit: Int!): [Campus!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(campus:Campus)
      WHERE toLower(campus.name) CONTAINS toLower($key)
      RETURN DISTINCT campus LIMIT $limit
      """
      columnName: "campusSearch"
    )
  oversightSearch(key: String!, limit: Int!): [Oversight!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(oversight:Oversight)
      WHERE toLower(oversight.name) CONTAINS toLower($key)
      RETURN DISTINCT oversight LIMIT $limit
      """
      columnName: "oversightSearch"
    )
}

extend type Oversight {
  memberSearch(key: String!, limit: Int!): [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*7]->(:Fellowship)<-[:BELONGS_TO]-(members:Active:Member)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName) LIMIT $limit
      """
      columnName: "memberSearch"
    )
  fellowshipSearch(key: String!, limit: Int!): [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*6]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) CONTAINS toLower($key)
      RETURN DISTINCT fellowship LIMIT $limit
      """
      columnName: "fellowshipSearch"
    )
  bacentaSearch(key: String!, limit: Int!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(bacenta:Bacenta)
      WHERE toLower(bacenta.name) CONTAINS toLower($key)
      RETURN DISTINCT bacenta LIMIT $limit
      """
      columnName: "bacentaSearch"
    )
  governorshipSearch(key: String!, limit: Int!): [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(governorship:Governorship)
      WHERE toLower(governorship.name) CONTAINS toLower($key)
      RETURN DISTINCT governorship LIMIT $limit
      """
      columnName: "governorshipSearch"
    )
  councilSearch(key: String!, limit: Int!): [Council!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(council:Council)
      WHERE toLower(council.name) CONTAINS toLower($key)
      RETURN DISTINCT council LIMIT $limit
      """
      columnName: "councilSearch"
    )
  streamSearch(key: String!, limit: Int!): [Stream!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(stream:Stream)
      WHERE toLower(stream.name) CONTAINS toLower($key)
      RETURN DISTINCT stream LIMIT $limit
      """
      columnName: "streamSearch"
    )
  campusSearch(key: String!, limit: Int!): [Campus!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(campus:Campus)
      WHERE toLower(campus.name) CONTAINS toLower($key)
      RETURN DISTINCT campus LIMIT $limit
      """
      columnName: "campusSearch"
    )
}

extend type Campus {
  memberSearch(key: String!, limit: Int!): [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName) LIMIT $limit
      """
      columnName: "memberSearch"
    )
  fellowshipSearch(key: String!, limit: Int!): [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) CONTAINS toLower($key)
      RETURN DISTINCT fellowship LIMIT $limit
      """
      columnName: "fellowshipSearch"
    )
  bacentaSearch(key: String!, limit: Int!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacenta:Bacenta)
      WHERE toLower(bacenta.name) CONTAINS toLower($key)
      RETURN DISTINCT bacenta LIMIT $limit
      """
      columnName: "bacentaSearch"
    )
  governorshipSearch(key: String!, limit: Int!): [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(governorship:Governorship)
      WHERE toLower(governorship.name) CONTAINS toLower($key)
      RETURN DISTINCT governorship LIMIT $limit
      """
      columnName: "governorshipSearch"
    )
  councilSearch(key: String!, limit: Int!): [Council!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(council:Council)
      WHERE toLower(council.name) CONTAINS toLower($key)
      RETURN DISTINCT council LIMIT $limit
      """
      columnName: "councilSearch"
    )
  streamSearch(key: String!, limit: Int!): [Stream!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(stream:Stream)
      WHERE toLower(stream.name) CONTAINS toLower($key)
      RETURN DISTINCT stream LIMIT $limit
      """
      columnName: "streamSearch"
    )
  creativeArtsSearch(key: String!, limit: Int!): [CreativeArts!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(creativeArts:CreativeArts)
      WHERE toLower(creativeArts.name) CONTAINS toLower($key)
      RETURN DISTINCT creativeArts LIMIT $limit
      """
      columnName: "creativeArtsSearch"
    )
  ministrySearch(key: String!, limit: Int!): [Ministry!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(creativeArts:CreativeArts)-[:HAS]->(ministry:Ministry)
      WHERE toLower(ministry.name) CONTAINS toLower($key)
      RETURN DISTINCT ministry LIMIT $limit
      """
      columnName: "ministrySearch"
    )
  hubSearch(key: String!, limit: Int!): [Hub!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(creativeArts:CreativeArts)-[:HAS]->(ministry:Ministry)-[:HAS]->(hub:Hub)
      WHERE toLower(hub.name) CONTAINS toLower($key)
      RETURN DISTINCT hub LIMIT $limit
      """
      columnName: "hubSearch"
    )
}

extend type Stream {
  memberSearch(key: String!, limit: Int!): [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)  LIMIT $limit
      """
      columnName: "memberSearch"
    )
  fellowshipSearch(key: String!, limit: Int!): [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) CONTAINS toLower($key)
      RETURN DISTINCT fellowship LIMIT $limit
      """
      columnName: "fellowshipSearch"
    )
  bacentaSearch(key: String!, limit: Int!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacenta:Bacenta)
      WHERE toLower(bacenta.name) CONTAINS toLower($key)
      RETURN DISTINCT bacenta LIMIT $limit
      """
      columnName: "bacentaSearch"
    )
  governorshipSearch(key: String!, limit: Int!): [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(governorship:Governorship)
      WHERE toLower(governorship.name) CONTAINS toLower($key)
      RETURN DISTINCT governorship LIMIT $limit
      """
      columnName: "governorshipSearch"
    )
  councilSearch(key: String!, limit: Int!): [Council!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(council:Council)
      WHERE toLower(council.name) CONTAINS toLower($key)
      RETURN DISTINCT council LIMIT $limit
      """
      columnName: "councilSearch"
    )
  ministrySearch(key: String!, limit: Int!): [Ministry!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(ministry:Ministry)
      WHERE toLower(ministry.name) CONTAINS toLower($key)
      RETURN DISTINCT ministry LIMIT $limit
      """
      columnName: "ministrySearch"
    )
  hubSearch(key: String!, limit: Int!): [Hub!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(ministry:Ministry)-[:HAS]->(hub:Hub)
      WHERE toLower(hub.name) CONTAINS toLower($key)
      RETURN DISTINCT hub LIMIT $limit
      """
      columnName: "hubSearch"
    )
}

extend type Council {
  memberSearch(key: String!, limit: Int!): [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)  LIMIT $limit
      """
      columnName: "memberSearch"
    )
  fellowshipSearch(key: String!, limit: Int!): [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) CONTAINS toLower($key)
      RETURN DISTINCT fellowship LIMIT $limit
      """
      columnName: "fellowshipSearch"
    )
  bacentaSearch(key: String!, limit: Int!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacenta:Bacenta)
      WHERE toLower(bacenta.name) CONTAINS toLower($key)
      RETURN DISTINCT bacenta LIMIT $limit
      """
      columnName: "bacentaSearch"
    )
  governorshipSearch(key: String!, limit: Int!): [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(governorship:Governorship)
      WHERE toLower(governorship.name) CONTAINS toLower($key)
      RETURN DISTINCT governorship LIMIT $limit
      """
      columnName: "governorshipSearch"
    )
  hubSearch(key: String!, limit: Int!): [Hub!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(hub:Hub)
      WHERE toLower(hub.name) CONTAINS toLower($key)
      RETURN DISTINCT hub LIMIT $limit
      """
      columnName: "hubSearch"
    )
}

extend type Governorship {
  memberSearch(key: String!, limit: Int!): [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)  LIMIT $limit
      """
      columnName: "memberSearch"
    )
  fellowshipSearch(key: String!, limit: Int!): [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Bacenta)-[:HAS]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) CONTAINS toLower($key)
      RETURN DISTINCT fellowship LIMIT $limit
      """
      columnName: "fellowshipSearch"
    )
  bacentaSearch(key: String!, limit: Int!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(bacenta:Bacenta)
      WHERE toLower(bacenta.name) CONTAINS toLower($key)
      RETURN DISTINCT bacenta LIMIT $limit
      """
      columnName: "bacentaSearch"
    )
}

extend type Bacenta {
  memberSearch(key: String!, limit: Int!): [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(members:Active:Member)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)  LIMIT $limit
      """
      columnName: "memberSearch"
    )
  fellowshipSearch(key: String!, limit: Int!): [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) CONTAINS toLower($key)
      RETURN DISTINCT fellowship LIMIT $limit
      """
      columnName: "fellowshipSearch"
    )
}

extend type Fellowship {
  memberSearch(key: String!, limit: Int!): [Member!]!
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)  LIMIT $limit
      """
      columnName: "memberSearch"
    )
}

extend type HubFellowship {
  memberSearch(key: String!, limit: Int!): [Member!]!
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)  LIMIT $limit
      """
      columnName: "memberSearch"
    )
}

extend type Hub {
  memberSearch(key: String!, limit: Int!): [Member!]!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS]-(hubcouncil:HubCouncil)
      MATCH (hubcouncil)<-[:HAS_MINISTRY]-(council:Council)
      MATCH (hubcouncil)<-[:HAS*2]-(creative:CreativeArts)
      MATCH (creative)<-[:BELONGS_TO]-(members:Active:Member)-[:BELONGS_TO]->(:Fellowship)<-[:HAS*3]-(council)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)  LIMIT $limit
      """
      columnName: "memberSearch"
    )
}

extend type Query {
  ###Member Searches%####
  oversightMemberSearch(searchKey: String!, oversightId: ID!): [Member!]!
    @cypher(
      statement: """
      MATCH (oversight:Oversight {id: $oversightId})-[:HAS]->(gathering:Campus)-[:HAS]->(stream:Stream)-[:HAS]->(:Council)-[:HAS]->(:Governorship)-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(member:Active:Member)
      WHERE toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.middleName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.lastName) CONTAINS toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)
      RETURN member LIMIT 5
      """
      columnName: "oversightMemberSearch"
    )

  campusMemberSearch(searchKey: String!, campusId: ID!): [Member!]!
    @authentication(
      jwt: {
        roles_INCLUDES: ["adminCampus", "leaderCampus", "arrivalsAdminCampus"]
      }
    )
    @cypher(
      statement: """
      MATCH (gathering:Campus {id: $campusId})-[:HAS]->(stream:Stream)-[:HAS]->(:Council)-[:HAS]->(:Governorship)-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(member:Active:Member)
      WHERE toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.middleName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.lastName) CONTAINS toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)
      RETURN member LIMIT 5
      """
      columnName: "campusMemberSearch"
    )
  streamMemberSearch(searchKey: String!, streamId: ID!): [Member!]!
    @authentication(
      jwt: {
        roles_INCLUDES: ["adminStream", "leaderStream", "arrivalsAdminStream"]
      }
    )
    @cypher(
      statement: """
      MATCH (stream:Stream {id: $streamId})-[:HAS]->(:Council)-[:HAS]->(:Governorship)-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(member:Active:Member)
      WHERE toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.middleName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.lastName) CONTAINS toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)
      WITH member WHERE member IS NOT NULL
      RETURN DISTINCT(member) LIMIT 5
      """
      columnName: "streamMemberSearch"
    )
  councilMemberSearch(searchKey: String!, councilId: ID!): [Member!]!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminCouncil"
          "leaderCouncil"
          "arrivalsAdminCouncil"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS]->(:Governorship)-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO*]-(member:Active:Member)
      WHERE toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.middleName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.lastName) CONTAINS toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)
      WITH member WHERE member IS NOT NULL
      RETURN DISTINCT(member) LIMIT 5
      """
      columnName: "councilMemberSearch"
    )
  governorshipMemberSearch(searchKey: String!, governorshipId: ID!): [Member!]!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminGovernorship"
          "leaderGovernorship"
          "arrivalsAdminGovernorship"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (governorship:Governorship {id:$governorshipId})
      MATCH (governorship)-[:HAS]->(:Bacenta)-[:HAS]->(fellowship:Fellowship)<-[:BELONGS_TO]-(member:Active:Member)
      WHERE toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.middleName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.lastName) CONTAINS toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)

      RETURN member LIMIT 5
      """
      columnName: "governorshipMemberSearch"
    )
  bacentaMemberSearch(searchKey: String!, bacentaId: ID!): [Member!]!
    @authentication(jwt: { roles_INCLUDES: ["leaderBacenta"] })
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id: $bacentaId})-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(member:Active:Member)
      WHERE toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.middleName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.lastName) CONTAINS toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)

      RETURN member LIMIT 5
      """
      columnName: "bacentaMemberSearch"
    )
  fellowshipMemberSearch(searchKey: String!, fellowshipId: ID!): [Member!]!
    @authentication(jwt: { roles_INCLUDES: ["leaderFellowship"] })
    @cypher(
      statement: """
      MATCH (fellowship:Fellowship {id: $fellowshipId})<-[:BELONGS_TO]-(member:Active:Member)
      WHERE toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.middleName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.lastName) CONTAINS toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)

      RETURN member LIMIT 5
      """
      columnName: "fellowshipMemberSearch"
    )
  creativeArtsMemberSearch(searchKey: String!, creativeArtsId: ID!): [Member!]!
    @authentication(
      jwt: { roles_INCLUDES: ["leaderCreativeArts", "adminCreativeArts"] }
    )
    @cypher(
      statement: """
      MATCH (creativeArts:CreativeArts {id: $creativeArtsId})-[:HAS]->(ministry:Ministry)-[:HAS]->(:Hub)-[:HAS]->(:HubFellowship)<-[:BELONGS_TO]-(member:Active:Member)
      WHERE toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.middleName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.lastName) CONTAINS toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)
      RETURN member LIMIT 5
      """
      columnName: "creativeArtsMemberSearch"
    )
  ministryMemberSearch(searchKey: String!, ministryId: ID!): [Member!]!
    @authentication(
      jwt: { roles_INCLUDES: ["leaderMinistry", "adminMinistry"] }
    )
    @cypher(
      statement: """
      MATCH (ministry:Ministry {id: $ministryId})-[:HAS]->(:Hub)-[:HAS]->(:HubFellowship)<-[:BELONGS_TO]-(member:Active:Member)
      WHERE toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.middleName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member lastName) CONTAINS toLower($searchKey)
      OR toLower(member.firstName + ' ' + member middleName+ ' '+ member lastName) CONTAINS toLower($searchKey)
      RETURN member LIMIT 5
      """
      columnName: "ministryMemberSearch"
    )
  hubMemberSearch(searchKey: String!, hubId: ID!): [Member!]!
    @authentication(jwt: { roles_INCLUDES: ["leaderHub"] })
    @cypher(
      statement: """
      MATCH (hub:Hub {id: $hubId})-[:HAS]->(:HubFellowship)<-[:BELONGS_TO]-(member:Active:Member)
      WHERE toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.middleName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member lastName) CONTAINS toLower($searchKey)
      OR toLower(member.firstName + ' ' + member middleName+ ' '+ member lastName) CONTAINS toLower($searchKey)
      RETURN member LIMIT 5
      """
      columnName: "hubMemberSearch"
    )

  ### Fellowship Search ###
  oversightFellowshipSearch(
    searchKey: String!
    oversightId: ID!
  ): [Fellowship!]!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminOversight"
          "leaderOversight"
          "arrivalsAdminOversight"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (oversight:Oversight {id: $oversightId})-[:HAS]->(:Campus)-[:HAS]->(stream:Stream)-[:HAS]->(:Council)-[:HAS]->(:Governorship)-[:HAS]->(:Bacenta)-[:HAS]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(fellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT fellowship LIMIT 5
      """
      columnName: "oversightFellowshipSearch"
    )

  campusFellowshipSearch(searchKey: String!, campusId: ID!): [Fellowship!]!
    @authentication(
      jwt: {
        roles_INCLUDES: ["adminCampus", "leaderCampus", "arrivalsAdminCampus"]
      }
    )
    @cypher(
      statement: """
      MATCH (gathering:Campus {id: $campusId})-[:HAS*5]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(fellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT fellowship LIMIT 5
      """
      columnName: "campusFellowshipSearch"
    )

  streamFellowshipSearch(searchKey: String!, streamId: ID!): [Fellowship!]!
    @authentication(
      jwt: {
        roles_INCLUDES: ["adminStream", "leaderStream", "arrivalsAdminStream"]
      }
    )
    @cypher(
      statement: """
      MATCH (stream:Stream {id: $streamId})-[:HAS*4]->(fellowship:Fellowship)

      WHERE toLower(fellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(fellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT fellowship LIMIT 5
      """
      columnName: "streamFellowshipSearch"
    )

  councilFellowshipSearch(searchKey: String!, councilId: ID!): [Fellowship!]!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminCouncil"
          "leaderCouncil"
          "arrivalsAdminCouncil"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS*3]->(fellowship:Fellowship)

      WHERE toLower(fellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(fellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT fellowship LIMIT 5
      """
      columnName: "councilFellowshipSearch"
    )
  governorshipFellowshipSearch(
    searchKey: String!
    governorshipId: ID!
  ): [Fellowship!]!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminGovernorship"
          "leaderGovernorship"
          "arrivalsAdminGovernorship"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (governorship:Governorship {id:$governorshipId})-[:HAS*2]->(fellowship:Fellowship)

      WHERE toLower(fellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(fellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT fellowship LIMIT 5
      """
      columnName: "governorshipFellowshipSearch"
    )
  bacentaFellowshipSearch(searchKey: String!, bacentaId: ID!): [Fellowship!]!
    @authentication(jwt: { roles_INCLUDES: ["leaderBacenta"] })
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id: $bacentaId})-[:HAS]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(fellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT fellowship LIMIT 5
      """
      columnName: "bacentaFellowshipSearch"
    )

  creativeArtsHubFellowshipSearch(
    searchKey: String!
    creativeArtsId: ID!
  ): [HubFellowship!]!
    @authentication(
      jwt: { roles_INCLUDES: ["leaderCreativeArts", "adminCreativeArts"] }
    )
    @cypher(
      statement: """
      MATCH (creativeArts:CreativeArts {id: $creativeArtsId})-[:HAS]->(ministry:Ministry)-[:HAS]->(hub:Hub)-[:HAS]->(hubFellowship:HubFellowship)
      WHERE toLower(hubFellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(hubFellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT hubFellowship LIMIT 5
      """
      columnName: "creativeArtsHubFellowshipSearch"
    )
  ministryHubFellowshipSearch(
    searchKey: String!
    ministryId: ID!
  ): [HubFellowship!]!
    @authentication(
      jwt: { roles_INCLUDES: ["leaderMinistry", "adminMinistry"] }
    )
    @cypher(
      statement: """
      MATCH (ministry:Ministry {id: $ministryId})-[:HAS]->(hub:Hub)-[:HAS]->(hubFellowship:HubFellowship)
      WHERE toLower(hubFellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(hubFellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT hubFellowship LIMIT 5
      """
      columnName: "ministryHubFellowshipSearch"
    )
  hubHubFellowshipSearch(searchKey: String!, hubId: ID!): [HubFellowship!]!
    @authentication(jwt: { roles_INCLUDES: ["leaderHub"] })
    @cypher(
      statement: """
      MATCH (hub:Hub {id: $hubId})-[:HAS]->(hubFellowship:HubFellowship)
      WHERE toLower(hubFellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(hubFellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT hubFellowship LIMIT 5
      """
      columnName: "hubHubFellowshipSearch"
    )

  ### Bacenta Search ###

  oversightBacentaSearch(searchKey: String!, oversightId: ID!): [Bacenta!]!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminOversight"
          "leaderOversight"
          "arrivalsAdminOversight"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (oversight:Oversight {id: $oversightId})-[:HAS]->(gathering:Campus)-[:HAS]->(stream:Stream)-[:HAS]->(:Council)-[:HAS]->(:Governorship)-[:HAS]->(bacenta:Bacenta)
      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN bacenta LIMIT 5
      """
      columnName: "oversightBacentaSearch"
    )

  campusBacentaSearch(searchKey: String!, campusId: ID!): [Bacenta]
    @authentication(
      jwt: {
        roles_INCLUDES: ["adminCampus", "leaderCampus", "arrivalsAdminCampus"]
      }
    )
    @cypher(
      statement: """
      MATCH (gathering:Campus {id: $campusId})-[:HAS]->(stream:Stream)-[:HAS]->(:Council)-[:HAS]->(:Governorship)-[:HAS]->(bacenta:Bacenta)
      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN bacenta LIMIT 5
      """
      columnName: "campusBacentaSearch"
    )
  streamBacentaSearch(searchKey: String!, streamId: ID!): [Bacenta]
    @authentication(
      jwt: {
        roles_INCLUDES: ["adminStream", "leaderStream", "arrivalsAdminStream"]
      }
    )
    @cypher(
      statement: """
      MATCH (stream:Stream {id: $streamId})-[:HAS*3]->(bacenta:Bacenta)

      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN bacenta LIMIT 5
      """
      columnName: "streamBacentaSearch"
    )
  councilBacentaSearch(searchKey: String!, councilId: ID!): [Bacenta]
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminCouncil"
          "leaderCouncil"
          "arrivalsAdminCouncil"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS*2]->(bacenta:Bacenta)

      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN bacenta LIMIT 5
      """
      columnName: "councilBacentaSearch"
    )
  governorshipBacentaSearch(
    searchKey: String!
    governorshipId: ID!
  ): [Fellowship!]!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminGovernorship"
          "leaderGovernorship"
          "arrivalsAdminGovernorship"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (governorship:Governorship {id:$governorshipId})
      MATCH (governorship)-[:HAS]->(bacenta:Bacenta)

      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta name) CONTAINS toLower($searchKey)
      RETURN bacenta LIMIT 5
      """
      columnName: "governorshipBacentaSearch"
    )

  ### Governorship Search ###
  oversightGovernorshipSearch(
    searchKey: String!
    oversightId: ID!
  ): [Governorship!]!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminOversight"
          "leaderOversight"
          "arrivalsAdminOversight"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (oversight:Oversight {id: $oversightId})-[:HAS]->(gathering:Campus)-[:HAS]->(stream:Stream)-[:HAS]->(:Council)-[:HAS]->(governorship:Governorship)
      WHERE toLower(governorship.name) STARTS WITH toLower($searchKey)
      OR toLower(governorship.name) CONTAINS toLower($searchKey)
      RETURN governorship LIMIT 5
      """
      columnName: "oversightGovernorshipSearch"
    )

  campusGovernorshipSearch(searchKey: String!, campusId: ID!): [Governorship!]!
    @authentication(
      jwt: {
        roles_INCLUDES: ["adminCampus", "leaderCampus", "arrivalsAdminCampus"]
      }
    )
    @cypher(
      statement: """
      MATCH (gathering:Campus {id: $campusId})-[:HAS]->(stream:Stream)-[:HAS]->(:Council)-[:HAS]->(governorship:Governorship)
      WHERE toLower(governorship.name) STARTS WITH toLower($searchKey)
      OR toLower(governorship.name) CONTAINS toLower($searchKey)
      RETURN governorship LIMIT 5
      """
      columnName: "campusGovernorshipSearch"
    )
  streamGovernorshipSearch(searchKey: String!, streamId: ID!): [Governorship!]!
    @authentication(
      jwt: {
        roles_INCLUDES: ["adminStream", "leaderStream", "arrivalsAdminStream"]
      }
    )
    @cypher(
      statement: """
      MATCH (stream:Stream {id: $streamId})-[:HAS]->(council:Council)-[:HAS]->(governorship:Governorship)

      WHERE toLower(governorship.name) STARTS WITH toLower($searchKey)
      OR toLower(governorship.name) CONTAINS toLower($searchKey)
      RETURN governorship LIMIT 5
      """
      columnName: "streamGovernorshipSearch"
    )
  councilGovernorshipSearch(
    searchKey: String!
    councilId: ID!
  ): [Governorship!]!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminCouncil"
          "leaderCouncil"
          "arrivalsAdminCouncil"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS]->(governorship:Governorship)

      WHERE toLower(governorship.name) STARTS WITH toLower($searchKey)
      OR toLower(governorship.name) CONTAINS toLower($searchKey)
      RETURN governorship LIMIT 5
      """
      columnName: "councilGovernorshipSearch"
    )

  ### Council Search ###
  oversightCouncilSearch(searchKey: String!, oversightId: ID!): [Council!]!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminOversight"
          "leaderOversight"
          "arrivalsAdminOversight"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (oversight:Oversight {id: $oversightId})-[:HAS]->(gathering:Campus)-[:HAS]->(stream:Stream)-[:HAS]->(council:Council)
      WHERE toLower(council.name) STARTS WITH toLower($searchKey)
      OR toLower(council.name) CONTAINS toLower($searchKey)
      RETURN council LIMIT 5
      """
      columnName: "oversightCouncilSearch"
    )

  campusCouncilSearch(searchKey: String!, campusId: ID!): [Council!]!
    @authentication(
      jwt: {
        roles_INCLUDES: ["adminCampus", "leaderCampus", "arrivalsAdminCampus"]
      }
    )
    @cypher(
      statement: """
      MATCH (gathering:Campus {id: $campusId})-[:HAS]->(stream:Stream)-[:HAS]->(council:Council)
      WHERE toLower(council.name) STARTS WITH toLower($searchKey)
      OR toLower(council.name) CONTAINS toLower($searchKey)
      RETURN council LIMIT 5
      """
      columnName: "campusCouncilSearch"
    )
  streamCouncilSearch(searchKey: String!, streamId: ID!): [Council!]!
    @authentication(
      jwt: {
        roles_INCLUDES: ["adminStream", "leaderStream", "arrivalsAdminStream"]
      }
    )
    @cypher(
      statement: """
      MATCH (stream:Stream {id: $streamId})-[:HAS]->(council:Council)
      MATCH (council:Council)
      WHERE toLower(council.name) STARTS WITH toLower($searchKey)
      OR toLower(council.name) CONTAINS toLower($searchKey)
      RETURN council LIMIT 5
      """
      columnName: "streamCouncilSearch"
    )

  ### Stream Search ###
  oversightStreamSearch(searchKey: String!, oversightId: ID!): [Stream!]!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminOversight"
          "leaderOversight"
          "arrivalsAdminOversight"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (oversight:Oversight {id: $oversightId})-[:HAS]->(gathering:Campus)-[:HAS]->(stream:Stream)
      WHERE toLower(stream.name) STARTS WITH toLower($searchKey)
      OR toLower(stream.name) CONTAINS toLower($searchKey)
      RETURN stream LIMIT 5
      """
      columnName: "oversightStreamSearch"
    )
  campusStreamSearch(searchKey: String!, campusId: ID!): [Stream!]!
    @authentication(
      jwt: {
        roles_INCLUDES: ["adminCampus", "leaderCampus", "arrivalsAdminCampus"]
      }
    )
    @cypher(
      statement: """
      MATCH (gathering:Campus {id: $campusId})-[:HAS]->(stream:Stream)
      WHERE toLower(stream.name) STARTS WITH toLower($searchKey)
      OR toLower(stream.name) CONTAINS toLower($searchKey)
      RETURN stream LIMIT 5
      """
      columnName: "campusStreamSearch"
    )

  ### Campus Search ###
  oversightCampusSearch(searchKey: String!, oversightId: ID!): [Campus!]!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminOversight"
          "leaderOversight"
          "arrivalsAdminOversight"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (oversight:Oversight {id: $oversightId})-[:HAS]->(gathering:Campus)
      WHERE toLower(gathering.name) STARTS WITH toLower($searchKey)
      OR toLower(gathering.name) CONTAINS toLower($searchKey)
      RETURN gathering LIMIT 5
      """
      columnName: "oversightCampusSearch"
    )

  ### Creative Arts Search ###
  campusCreativeArtsSearch(searchKey: String!, campusId: ID!): [CreativeArts!]!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus", "leaderCampus"] })
    @cypher(
      statement: """
      MATCH (gathering:Campus {id: $campusId})-[:HAS_MINISTRY]->(creativeArts:CreativeArts)
      WHERE toLower(creativeArts.name) STARTS WITH toLower($searchKey)
      OR toLower(creativeArts.name) CONTAINS toLower($searchKey)
      RETURN creativeArts LIMIT 5
      """
      columnName: "campusCreativeArtsSearch"
    )

  ### Ministry Search ###
  campusMinistrySearch(searchKey: String!, campusId: ID!): [Ministry!]!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus", "leaderCampus"] })
    @cypher(
      statement: """
      MATCH (gathering:Campus {id: $campusId})-[:HAS_MINISTRY]->(creativeArts:CreativeArts)-[:HAS]->(ministry:Ministry)
      WHERE toLower(ministry.name) STARTS WITH toLower($searchKey)
      OR toLower(ministry.name) CONTAINS toLower($searchKey)
      RETURN ministry LIMIT 5
      """
      columnName: "campusMinistrySearch"
    )
  streamMinistrySearch(searchKey: String!, streamId: ID!): [Ministry!]!
    @authentication(jwt: { roles_INCLUDES: ["adminStream", "leaderStream"] })
    @cypher(
      statement: """
      MATCH (stream:Stream {id: $streamId})-[:HAS_MINISTRY]->(creativeArts:CreativeArts)-[:HAS]->(ministry:Ministry)
      WHERE toLower(ministry.name) STARTS WITH toLower($searchKey)
      OR toLower(ministry name) CONTAINS toLower($searchKey)
      RETURN ministry LIMIT 5
      """
      columnName: "streamMinistrySearch"
    )
  creativeArtsMinistrySearch(
    searchKey: String!
    creativeArtsId: ID!
  ): [Ministry!]!
    @authentication(
      jwt: { roles_INCLUDES: ["leaderCreativeArts", "adminCreativeArts"] }
    )
    @cypher(
      statement: """
      MATCH (creativeArts:CreativeArts {id: $creativeArtsId})-[:HAS]->(ministry:Ministry)
      WHERE toLower(ministry.name) STARTS WITH toLower($searchKey)
      OR toLower(ministry name) CONTAINS toLower($searchKey)
      RETURN ministry LIMIT 5
      """
      columnName: "creativeArtsMinistrySearch"
    )

  ### Hub Search ###
  campusHubSearch(searchKey: String!, campusId: ID!): [Hub!]!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus", "leaderCampus"] })
    @cypher(
      statement: """
      MATCH (gathering:Campus {id: $campusId})-[:HAS_MINISTRY]->(creativeArts:CreativeArts)-[:HAS]->(ministry:Ministry)-[:HAS]->(hub:Hub)
      WHERE toLower(hub.name) STARTS WITH toLower($searchKey)
      OR toLower(hub name) CONTAINS toLower($searchKey)
      RETURN hub LIMIT 5
      """
      columnName: "campusHubSearch"
    )
  streamHubSearch(searchKey: String!, streamId: ID!): [Hub!]!
    @authentication(jwt: { roles_INCLUDES: ["adminStream", "leaderStream"] })
    @cypher(
      statement: """
      MATCH (stream:Stream {id: $streamId})-[:HAS_MINISTRY]->(ministry:Ministry)-[:HAS]->(hub:Hub)
      WHERE toLower(hub name) STARTS WITH toLower($searchKey)
      OR toLower(hub name) CONTAINS toLower($searchKey)
      RETURN hub LIMIT 5
      """
      columnName: "streamHubSearch"
    )
  creativeArtsHubSearch(searchKey: String!, creativeArtsId: ID!): [Hub!]!
    @authentication(
      jwt: { roles_INCLUDES: ["leaderCreativeArts", "adminCreativeArts"] }
    )
    @cypher(
      statement: """
      MATCH (creativeArts:CreativeArts {id: $creativeArtsId})-[:HAS]->(ministry:Ministry)-[:HAS]->(hub:Hub)
      WHERE toLower(hub name) STARTS WITH toLower($searchKey)
      OR toLower(hub name) CONTAINS toLower($searchKey)
      RETURN hub LIMIT 5
      """
      columnName: "creativeArtsHubSearch"
    )
  ministryHubSearch(searchKey: String!, ministryId: ID!): [Hub!]!
    @authentication(
      jwt: { roles_INCLUDES: ["leaderMinistry", "adminMinistry"] }
    )
    @cypher(
      statement: """
      MATCH (ministry:Ministry {id: $ministryId})-[:HAS]->(hub:Hub)
      WHERE toLower(hub name) STARTS WITH toLower($searchKey)
      OR toLower(hub name) CONTAINS toLower($searchKey)
      RETURN hub LIMIT 5
      """
      columnName: "ministryHubSearch"
    )
  councilHubSearch(searchKey: String!, councilId: ID!): [Hub!]!
    @authentication(jwt: { roles_INCLUDES: ["leaderCouncil", "adminCouncil"] })
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS]->(hub:Hub)
      WHERE toLower(hub name) STARTS WITH toLower($searchKey)
      OR toLower(hub name) CONTAINS toLower($searchKey)
      RETURN hub LIMIT 5
      """
      columnName: "councilHubSearch"
    )
}
 type ServiceDay {
  day: String!
  dayNumber: Int!
  bacenta: Bacenta @relationship(type: "MEETS_ON", direction: IN)
}

extend type Stream {
  servicesThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(this)

      RETURN DISTINCT bacentas
      """
      columnName: "servicesThisWeek"
    )
  servicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "servicesThisWeekCount"
    )
  cancelledServicesThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
       WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(this)

      RETURN DISTINCT bacentas
      """
      columnName: "cancelledServicesThisWeek"
    )
  cancelledServicesThisWeekCount: Int
    @cypher(
      statement: """
       MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
       WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "cancelledServicesThisWeekCount"
    )
  formDefaultersThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT bacentas) as services, this
       MATCH (defaulters:Active:Bacenta)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek AND  time() > time('20:30'))
       RETURN DISTINCT defaulters
      """
      columnName: "formDefaultersThisWeek"
    )
  formDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT bacentas) as services, this
       MATCH (defaulters:Active:Bacenta)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek AND  time() > time('20:30'))
       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "formDefaultersThisWeekCount"
    )
  bankingDefaultersThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(this)

      RETURN DISTINCT bacentas
      """
      columnName: "bankingDefaultersThisWeek"
    )
  bankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bankingDefaultersThisWeekCount"
    )
  bankedThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(this)

      RETURN DISTINCT bacentas
      """

      columnName: "bankedThisWeek"
    )
  bankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bankedThisWeekCount"
    )
  governorshipServicesThisWeek: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(council:Council)<-[:HAS]-(this)

      RETURN DISTINCT governorships
      """
      columnName: "governorshipServicesThisWeek"
    )
  governorshipServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(council:Council)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT governorships)
      """
      columnName: "governorshipServicesThisWeekCount"
    )
  councilServicesThisWeek: [Council!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(councils) WHERE councils:Council OR councils:ClosedCouncil

       WITH DISTINCT councils, this
       MATCH (councils)<-[:HAS]-(this)

      RETURN DISTINCT councils
      """
      columnName: "councilServicesThisWeek"
    )
  councilServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(councils) WHERE councils:Council OR councils:ClosedCouncil

       WITH DISTINCT councils, this
       MATCH (councils)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT councils)
      """
      columnName: "councilServicesThisWeekCount"
    )
}
extend type Council {
  servicesThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(this)

      RETURN bacentas ORDER BY governorship.name
      """
      columnName: "servicesThisWeek"
    )
  servicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "servicesThisWeekCount"
    )
  cancelledServicesThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(this)

      RETURN bacentas ORDER BY governorship.name
      """
      columnName: "cancelledServicesThisWeek"
    )
  cancelledServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "cancelledServicesThisWeekCount"
    )
  formDefaultersThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT bacentas) as services, this
       MATCH (defaulters:Active:Bacenta)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this, governorship
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek AND  time() > time('20:30'))
        WITH DISTINCT defaulters, governorship
       RETURN defaulters ORDER BY governorship.name
      """
      columnName: "formDefaultersThisWeek"
    )
  formDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT bacentas) as services, this
       MATCH (defaulters:Active:Bacenta)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek AND  time() > time('20:30'))
       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "formDefaultersThisWeekCount"
    )
  bankingDefaultersThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(this)

      RETURN bacentas ORDER BY governorship.name
      """
      columnName: "bankingDefaultersThisWeek"
    )
  bankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bankingDefaultersThisWeekCount"
    )
  bankedThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(this)

      RETURN bacentas ORDER BY governorship.name
      """
      columnName: "bankedThisWeek"
    )
  bankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bankedThisWeekCount"
    )
  governorshipServicesThisWeek: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(this)

      RETURN DISTINCT governorships
      """
      columnName: "governorshipServicesThisWeek"
    )
  governorshipServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
      MATCH (governorships)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT governorships)
      """
      columnName: "governorshipServicesThisWeekCount"
    )
}

extend type Governorship {
  servicesThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(this)

      RETURN DISTINCT bacentas
      """
      columnName: "servicesThisWeek"
    )
  servicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "servicesThisWeekCount"
    )
  cancelledServicesThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(this)

      RETURN DISTINCT bacentas
      """
      columnName: "cancelledServicesThisWeek"
    )
  cancelledServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "cancelledServicesThisWeekCount"
    )
  formDefaultersThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT bacentas) as services, this
       MATCH (defaulters:Active:Bacenta)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek AND  time() > time('20:30'))

       RETURN DISTINCT defaulters
      """
      columnName: "formDefaultersThisWeek"
    )
  formDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT bacentas) as services, this
       MATCH (defaulters:Active:Bacenta)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek AND  time() > time('20:30'))

       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "formDefaultersThisWeekCount"
    )
  bankingDefaultersThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(this)

      RETURN DISTINCT bacentas
      """
      columnName: "bankingDefaultersThisWeek"
    )
  bankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bankingDefaultersThisWeekCount"
    )
  bankedThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(this)

      RETURN DISTINCT bacentas
      """
      columnName: "bankedThisWeek"
    )
  bankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bankedThisWeekCount"
    )
}

interface Record {
  id: ID
  createdAt: DateTime!
  created_by: Member @declareRelationship
}

interface HadService {
  week: Int!
  attendance: Int!
  income: Float!
}

type ServiceRecord implements Record {
  id: ID!
  createdAt: DateTime!
  created_by: Member @relationship(type: "LOGGED_BY", direction: OUT)
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
      columnName: "week"
    )
  attendance: Int
  income: Float
  cash: Float
  onlineGiving: Float
  numberOfTithers: Int
  foreignCurrency: String
  familyPicture: String
  treasurerSelfie: String
  bankingSlip: String
  bankingSlipUploader: Member
    @relationship(type: "UPLOADED_SLIP_FOR", direction: IN)
  transactionId: ID #deprecated
  treasurers: [Member!]! @relationship(type: "WAS_TREASURER_FOR", direction: IN)
  serviceLog: ServiceLog! @relationship(type: "HAS_SERVICE", direction: IN)
  noServiceReason: String
  name: String
  description: String
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(church)
      WHERE church:Bacenta OR church:Governorship OR church:Council OR church:Stream
      MATCH (church)<-[:HAS*1..4]-(stream:Stream)
      RETURN stream.name
      """
      columnName: "stream_name"
    )
  bankedBy: Member
    @cypher(
      statement: """
      MATCH (this)
      WHERE NOT  (this:NoService)
      MATCH (this)<-[:CONFIRMED_BANKING_FOR | :UPLOADED_SLIP_FOR | :OFFERING_BANKED_BY]-(member:Member)
      RETURN member
      """
      columnName: "bankedBy"
    )
}

type NoService implements Record {
  id: ID!
  createdAt: DateTime!
  created_by: Member! @relationship(type: "LOGGED_BY", direction: OUT)
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int!
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
      columnName: "week"
    )
  serviceLog: ServiceLog @relationship(type: "HAS_SERVICE", direction: IN)
  noServiceReason: String!
}

type ServiceLog {
  id: ID
  historyRecord: String #leader was transferred to
  createdAt: TimeGraph @relationship(type: "RECORDED_ON", direction: OUT)
  loggedBy: Member @relationship(type: "LOGGED_BY", direction: OUT)
  serviceRecords: [ServiceRecord!]!
    @relationship(type: "HAS_SERVICE", direction: OUT)
  aggregateServiceRecord: [AggregateServiceRecord!]!
    @relationship(type: "HAS_SERVICE_AGGREGATE", direction: OUT)
  bussingRecords: [BussingRecord!]!
    @relationship(type: "HAS_BUSSING", direction: OUT)
  leaders: [Member!]! @relationship(type: "HAS_HISTORY", direction: IN)
  fellowship: [Bacenta!]! @relationship(type: "HAS_HISTORY", direction: IN)
  governorship: [Governorship!]!
    @relationship(type: "HAS_HISTORY", direction: IN)
  council: [Council!]! @relationship(type: "HAS_HISTORY", direction: IN)
  stream: [Stream!]! @relationship(type: "HAS_HISTORY", direction: IN)
  ministry: [Ministry!]! @relationship(type: "HAS_HISTORY", direction: IN)
  hub: [Hub!]! @relationship(type: "HAS_HISTORY", direction: IN)
}

extend type Mutation {
  RecordService(
    churchId: ID!
    serviceDate: String!
    attendance: Int!
    income: Float!
    foreignCurrency: String
    numberOfTithers: Int
    treasurers: [ID]!
    treasurerSelfie: String!
    familyPicture: String!
  ): ServiceRecord!

  RecordSpecialService(
    serviceName: String!
    serviceDescription: String!
    churchId: ID!
    serviceDate: String!
    attendance: Int!
    income: Float!
    foreignCurrency: String
    numberOfTithers: Int
    treasurers: [ID]!
    treasurerSelfie: String!
    familyPicture: String!
  ): ServiceRecord!

  RecordCancelledService(
    churchId: ID!
    serviceDate: String!
    noServiceReason: String!
  ): NoService!

  UndoCancelledService(serviceRecordId: ID!): Bacenta!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminCampus"
          "adminStream"
          "adminCouncil"
          "adminGovernorship"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (this:NoService {id: $serviceRecordId})<-[:HAS_SERVICE]-(serviceLog:ServiceLog)<-[:HAS_HISTORY]-(bacenta:Bacenta)
      DETACH DELETE this
      RETURN bacenta
      """
      columnName: "bacenta"
    )
}

extend type Campus {
  activeStreamCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(stream:Stream:Active) RETURN COUNT(DISTINCT stream)
      """
      columnName: "activeStreamCount"
    )
  streamServicesThisWeek: [Stream!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS]-(this)

      RETURN DISTINCT streams
      """
      columnName: "streams"
    )
  streamServicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT streams)
      """
      columnName: "streamServicesThisWeekCount"
    )
  streamCancelledServicesThisWeek: [Stream!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS]-(this)


      RETURN DISTINCT streams
      """
      columnName: "streamCancelledServicesThisWeek"
    )
  streamCancelledServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT streams)
      """
      columnName: "streamCancelledServicesThisWeekCount"
    )
  streamFormDefaultersThisWeek: [Stream!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week

      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams:Active:Stream)
       MATCH (streams)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT streams) as services, this
       MATCH (defaulters:Active:Stream)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
       RETURN DISTINCT defaulters
      """
      columnName: "streamFormDefaultersThisWeek"
    )
  streamFormDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams:Active:Stream)
       MATCH (streams)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT streams) as services, this
       MATCH (defaulters:Active:Stream)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "streamFormDefaultersThisWeekCount"
    )
  streamBankingDefaultersThisWeek: [Stream!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS]-(this)

      RETURN DISTINCT streams
      """
      columnName: "streamBankingDefaultersThisWeek"
    )
  streamBankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT streams)
      """
      columnName: "streamBankingDefaultersThisWeekCount"
    )
  streamBankedThisWeek: [Stream!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS]-(this)

      RETURN DISTINCT streams
      """
      columnName: "streamBankedThisWeek"
    )
  streamBankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT streams)
      """
      columnName: "streamBankedThisWeekCount"
    )
}

extend type Campus {
  servicesThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      RETURN DISTINCT bacentas
      """
      columnName: "servicesThisWeek"
    )
  servicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "servicesThisWeekCount"
    )
  cancelledServicesThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      RETURN DISTINCT bacentas
      """
      columnName: "cancelledServicesThisWeek"
    )
  cancelledServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "cancelledServicesThisWeekCount"
    )
  formDefaultersThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT bacentas) as services, this
       MATCH (defaulters:Active:Bacenta)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek AND  time() > time('20:30'))
       RETURN DISTINCT defaulters
      """
      columnName: "formDefaultersThisWeek"
    )
  formDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT bacentas) as services, this
       MATCH (defaulters:Active:Bacenta)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek AND  time() > time('20:30'))
       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "formDefaultersThisWeekCount"
    )
  bankingDefaultersThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      RETURN DISTINCT bacentas
      """
      columnName: "bankingDefaultersThisWeek"
    )
  bankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bankingDefaultersThisWeekCount"
    )
  bankedThisWeek: [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      RETURN DISTINCT bacentas
      """
      columnName: "bankedThisWeek"
    )
  bankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

       WITH DISTINCT bacentas, this
       MATCH (bacentas)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bankedThisWeekCount"
    )
  governorshipServicesThisWeek: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      RETURN DISTINCT governorships
      """
      columnName: "governorshipServicesThisWeek"
    )
  governorshipServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT governorships)
      """
      columnName: "governorshipServicesThisWeekCount"
    )
  councilServicesThisWeek: [Council!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(councils) WHERE councils:Council OR councils:ClosedCouncil

       WITH DISTINCT councils, this
       MATCH (councils)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      RETURN DISTINCT councils
      """
      columnName: "councilServicesThisWeek"
    )
  councilServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(councils) WHERE councils:Council OR councils:ClosedCouncil

       WITH DISTINCT councils, this
       MATCH (councils)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT councils)
      """
      columnName: "councilServicesThisWeekCount"
    )
}

extend type Oversight {
  activeStreamCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(stream:Stream:Active) RETURN COUNT(DISTINCT stream)
      """
      columnName: "activeStreamCount"
    )
  streamServicesThisWeek: [Stream!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS*2]-(this)

      RETURN DISTINCT streams
      """
      columnName: "streams"
    )
  streamServicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS*2]-(this)

      RETURN COUNT(DISTINCT streams)
      """
      columnName: "streamServicesThisWeekCount"
    )
  streamCancelledServicesThisWeek: [Stream!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS*2]-(this)


      RETURN DISTINCT streams
      """
      columnName: "streamCancelledServicesThisWeek"
    )
  streamCancelledServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS*2]-(this)

      RETURN COUNT(DISTINCT streams)
      """
      columnName: "streamCancelledServicesThisWeekCount"
    )
  streamFormDefaultersThisWeek: [Stream!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week

      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams:Active:Stream)
       MATCH (streams)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT streams) as services, this
       MATCH (defaulters:Active:Stream)<-[:HAS*2]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
       RETURN DISTINCT defaulters
      """
      columnName: "streamFormDefaultersThisWeek"
    )
  streamFormDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams:Active:Stream)
       MATCH (streams)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT streams) as services, this
       MATCH (defaulters:Active:Stream)<-[:HAS*2]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "streamFormDefaultersThisWeekCount"
    )
  streamBankingDefaultersThisWeek: [Stream!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS*2]-(this)

      RETURN DISTINCT streams
      """
      columnName: "streamBankingDefaultersThisWeek"
    )
  streamBankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS*2]-(this)

      RETURN COUNT(DISTINCT streams)
      """
      columnName: "streamBankingDefaultersThisWeekCount"
    )
  streamBankedThisWeek: [Stream!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS*2]-(this)

      RETURN DISTINCT streams
      """
      columnName: "streamBankedThisWeek"
    )
  streamBankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS*2]-(this)

      RETURN COUNT(DISTINCT streams)
      """
      columnName: "streamBankedThisWeekCount"
    )
}

extend type Denomination {
  activeStreamCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(stream:Stream:Active) RETURN COUNT(DISTINCT stream)
      """
      columnName: "activeStreamCount"
    )
  streamServicesThisWeek: [Stream!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS*3]-(this)

      RETURN DISTINCT streams
      """
      columnName: "streamServicesThisWeek"
    )
  streamServicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS*3]-(this)

      RETURN COUNT(DISTINCT streams)
      """
      columnName: "streamServicesThisWeekCount"
    )
  streamCancelledServicesThisWeek: [Stream!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS*3]-(this)


      RETURN DISTINCT streams
      """
      columnName: "streamCancelledServicesThisWeek"
    )
  streamCancelledServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS*3]-(this)

      RETURN COUNT(DISTINCT streams)
      """
      columnName: "streamCancelledServicesThisWeekCount"
    )
  streamFormDefaultersThisWeek: [Stream!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week

      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams:Active:Stream)
       MATCH (streams)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT streams) as services, this
       MATCH (defaulters:Active:Stream)<-[:HAS*3]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
       RETURN DISTINCT defaulters
      """
      columnName: "streamFormDefaultersThisWeek"
    )
  streamFormDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams:Active:Stream)
       MATCH (streams)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT streams) as services, this
       MATCH (defaulters:Active:Stream)<-[:HAS*3]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "streamFormDefaultersThisWeekCount"
    )
  streamBankingDefaultersThisWeek: [Stream!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS*3]-(this)

      RETURN DISTINCT streams
      """
      columnName: "streamBankingDefaultersThisWeek"
    )
  streamBankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS*3]-(this)

      RETURN COUNT(DISTINCT streams)
      """
      columnName: "streamBankingDefaultersThisWeekCount"
    )
  streamBankedThisWeek: [Stream!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS*3]-(this)

      RETURN DISTINCT streams
      """
      columnName: "streamBankedThisWeek"
    )
  streamBankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(streams) WHERE streams:Stream OR streams:ClosedStream

       WITH DISTINCT streams, this
       MATCH (streams)<-[:HAS*3]-(this)

      RETURN COUNT(DISTINCT streams)
      """
      columnName: "streamBankedThisWeekCount"
    )
}
 extend type Mutation {
  BankServiceOffering(
    serviceRecordId: ID!
    mobileNetwork: String!
    mobileNumber: String!
    momoName: String!
  ): ServiceRecord!
  BankRehearsalOffering(
    rehearsalRecordId: ID!
    mobileNetwork: String!
    mobileNumber: String!
    momoName: String!
  ): RehearsalRecord!
  SendPaymentOTP(
    serviceRecordId: String!
    reference: String
    otp: String!
  ): ServiceRecord!
  ConfirmOfferingPayment(serviceRecordId: ID!): ServiceRecord!
  SubmitBankingSlip(serviceRecordId: ID!, bankingSlip: String!): ServiceRecord!
  ManuallyConfirmOfferingPayment(serviceRecordId: ID!): ServiceRecord!
}

extend type RehearsalRecord {
  offeringBankedBy: Member
    @relationship(type: "OFFERING_BANKED_BY", direction: OUT)
  sourceNumber: String
  sourceNetwork: String
  desc: String
  transactionTime: DateTime
}

extend type RehearsalRecord {
  transactionTime: DateTime
  transactionReference: ID
  transactionOTP: String
  transactionStatus: String
  transactionError: String
  confirmedBy: ID!
  bankingProof: Boolean
    @cypher(
      statement: """
      MATCH (this)
      WITH this WHERE this.bankingSlip IS NOT NULL
      OR  this.transactionStatus = 'success'
      OR this.tellerConfirmationTime IS NOT NULL
      RETURN true
      """
      columnName: "bankingProof"
    )
}

extend type ServiceRecord {
  # Self Banking Properties
  offeringBankedBy: Member
    @relationship(type: "OFFERING_BANKED_BY", direction: OUT)
  sourceNumber: String
  sourceNetwork: String
  desc: String
  transactionTime: DateTime
}

extend type ServiceRecord {
  transactionTime: DateTime
  transactionReference: ID
  transactionOTP: String
  transactionStatus: String
  transactionError: String
  confirmedBy: ID!
  bankingProof: Boolean
    @cypher(
      statement: """
      MATCH (this)
      WITH this WHERE this.bankingSlip IS NOT NULL
      OR  this.transactionStatus = 'success'
      OR this.tellerConfirmationTime IS NOT NULL
      RETURN true
      """
      columnName: "bankingProof"
    )
}

extend type Governorship {
  servicesNotBanked: [ServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(record:ServiceRecord)
      WHERE record.noServiceReason IS NULL
        AND record.bankingSlip IS NULL
        AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
        AND record.tellerConfirmationTime IS NULL

      RETURN record
      """
      columnName: "servicesNotBanked"
    )
}

extend type Council {
  governorshipBankedThisWeek: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord) WHERE NOT record:NoService

       WITH DISTINCT record, this
        WHERE record.bankingSlip IS NOT NULL
          OR record.transactionStatus = 'success'
          OR record.tellerConfirmationTime IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(this)

      RETURN DISTINCT governorships
      """
      columnName: "governorshipBankedThisWeek"
    )
  governorshipBankedThisWeekCount: Int
    @cypher(
      statement: """
       MATCH (this)
       WITH date() as today, this
       WITH  today.weekDay as theDay, today, this
       WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
       WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

       MATCH (date:TimeGraph)
       USING INDEX date:TimeGraph(date)
       WHERE date.date IN dates
       MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord) WHERE NOT record:NoService

       WITH DISTINCT record, this
        WHERE record.bankingSlip IS NOT NULL
          OR record.transactionStatus = 'success'
          OR record.tellerConfirmationTime IS NOT NULL
        MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

        WITH DISTINCT governorships, this
         MATCH (governorships)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT governorships) as count
      """
      columnName: "governorshipBankedThisWeekCount"
    )
  governorshipBankingDefaultersThisWeek: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(this)

      RETURN DISTINCT governorships
      """
      columnName: "governorshipBankingDefaultersThisWeek"
    )
  governorshipBankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
       WITH date() as today, this
       WITH  today.weekDay as theDay, today, this
       WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
       WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

       MATCH (date:TimeGraph)
       USING INDEX date:TimeGraph(date)
       WHERE date.date IN dates
       MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

        WITH DISTINCT record, this
         WHERE record.noServiceReason IS NULL
           AND record.bankingSlip IS NULL
           AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
           AND record.tellerConfirmationTime IS NULL
        MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

        WITH DISTINCT governorships, this
        MATCH (governorships)<-[:HAS]-(this)

        WITH COUNT(DISTINCT governorships) as count
       RETURN
       CASE
       WHEN count < 1 THEN null
       ELSE count
       END AS result
      """
      columnName: "governorshipBankingDefaultersThisWeekCount"
    )
  governorshipBankingDefaulters: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship
      MATCH (record:ServiceRecord)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships)

      WHERE record.noServiceReason IS NULL
        AND record.bankingSlip IS NULL
        AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
        AND record.tellerConfirmationTime IS NULL


      RETURN DISTINCT governorships
      """
      columnName: "governorshipBankingDefaulters"
    )
  governorshipBankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship
      MATCH (record:ServiceRecord)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships)

       WHERE record.noServiceReason IS NULL
         AND record.bankingSlip IS NULL
         AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
         AND record.tellerConfirmationTime IS NULL

        WITH COUNT(DISTINCT governorships) as count
      RETURN
      CASE
      WHEN count < 1 THEN null
      ELSE count
      END AS result
      """
      columnName: "governorshipBankingDefaultersThisWeekCount"
    )
  servicesNotBanked: [ServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(record:ServiceRecord)
      WHERE record.noServiceReason IS NULL
        AND record.bankingSlip IS NULL
        AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
        AND record.tellerConfirmationTime IS NULL

      RETURN record
      """
      columnName: "servicesNotBanked"
    )
}

extend type Stream {
  governorshipBankedThisWeek: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord) WHERE NOT record:NoService

       WITH DISTINCT record, this
        WHERE record.bankingSlip IS NOT NULL
          OR record.transactionStatus = 'success'
          OR record.tellerConfirmationTime IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(this)

      RETURN DISTINCT governorships
      """
      columnName: "governorshipBankedThisWeek"
    )
  governorshipBankedThisWeekCount: Int
    @cypher(
      statement: """
       MATCH (this)
       WITH date() as today, this
       WITH  today.weekDay as theDay, today, this
       WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
       WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

       MATCH (date:TimeGraph)
       USING INDEX date:TimeGraph(date)
       WHERE date.date IN dates
       MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord) WHERE NOT record:NoService

       WITH DISTINCT record, this
        WHERE record.bankingSlip IS NOT NULL
          OR record.transactionStatus = 'success'
          OR record.tellerConfirmationTime IS NOT NULL
        MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

        WITH DISTINCT governorships, this
        MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(this)

      WITH COUNT(DISTINCT governorships) as count
       RETURN
       CASE
       WHEN count < 1 THEN null
       ELSE count
       END AS result
      """
      columnName: "governorshipBankedThisWeekCount"
    )
  governorshipBankingDefaultersThisWeek: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(this)

      RETURN DISTINCT governorships
      """
      columnName: "governorshipBankingDefaultersThisWeek"
    )
  governorshipBankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(this)

       WITH COUNT(DISTINCT governorships) as count
      RETURN
      CASE
      WHEN count < 1 THEN null
      ELSE count
      END AS result
      """
      columnName: "governorshipBankingDefaultersThisWeekCount"
    )
  governorshipBankingDefaulters: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Council)-[:HAS]->(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship
      MATCH (record:ServiceRecord)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships)

      WHERE record.noServiceReason IS NULL
        AND record.bankingSlip IS NULL
        AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
        AND record.tellerConfirmationTime IS NULL


      RETURN DISTINCT governorships
      """
      columnName: "governorshipBankingDefaulters"
    )
  governorshipBankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Council)-[:HAS]->(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship
      MATCH (record:ServiceRecord)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships)

      WHERE record.noServiceReason IS NULL
        AND record.bankingSlip IS NULL
        AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
        AND record.tellerConfirmationTime IS NULL

        WITH COUNT(DISTINCT governorships) as count
      RETURN
      CASE
      WHEN count < 1 THEN null
      ELSE count
      END AS result
      """
      columnName: "governorshipBankingDefaultersThisWeekCount"
    )
  councilBankedThisWeek: [Council!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord) WHERE NOT record:NoService

       WITH DISTINCT record, this
        WHERE record.bankingSlip IS NOT NULL
          OR record.transactionStatus = 'success'
          OR record.tellerConfirmationTime IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council) WHERE council:Council OR council:ClosedCouncil

       WITH DISTINCT council, this
      MATCH (council:Council)<-[:HAS]-(this)

      RETURN DISTINCT council
      """
      columnName: "councilBankedThisWeek"
    )
  councilBankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord) WHERE NOT record:NoService

       WITH DISTINCT record, this
        WHERE record.bankingSlip IS NOT NULL
          OR record.transactionStatus = 'success'
          OR record.tellerConfirmationTime IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council) WHERE council:Council OR council:ClosedCouncil

       WITH DISTINCT council, this
       MATCH (council:Council)<-[:HAS]-(this)

      WITH COUNT(DISTINCT council) as count
      RETURN
      CASE
      WHEN count < 1 THEN null
      ELSE count
      END AS result
      """
      columnName: "councilBankedThisWeekCount"
    )
  councilBankingDefaulters: [Council!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(council) WHERE council:Council OR council:ClosedCouncil
      MATCH (record:ServiceRecord)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council)

      WHERE record.noServiceReason IS NULL
        AND record.bankingSlip IS NULL
        AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
        AND record.tellerConfirmationTime IS NULL


      RETURN DISTINCT council
      """
      columnName: "councilBankingDefaulters"
    )
  councilBankingDefaultersCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(council) WHERE council:Council OR council:ClosedCouncil
      MATCH (record:ServiceRecord)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council)

      WHERE record.noServiceReason IS NULL
        AND record.bankingSlip IS NULL
        AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
        AND record.tellerConfirmationTime IS NULL

        WITH COUNT(DISTINCT council) as count
      RETURN
      CASE
      WHEN count < 1 THEN null
      ELSE count
      END AS result
      """
      columnName: "councilBankingDefaultersCount"
    )

  servicesNotBanked: [ServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(record:ServiceRecord)
      WHERE record.noServiceReason IS NULL
        AND record.bankingSlip IS NULL
        AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
        AND record.tellerConfirmationTime IS NULL

      RETURN record
      """
      columnName: "servicesNotBanked"
    )

  councilBankingDefaultersThisWeek: [Council!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council) WHERE council:Council OR council:ClosedCouncil

       WITH DISTINCT council, this
      MATCH (council:Council)<-[:HAS]-(this)

      RETURN DISTINCT council
      """
      columnName: "councilBankingDefaultersThisWeek"
    )
  councilBankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council) WHERE council:Council OR council:ClosedCouncil

       WITH DISTINCT council, this
       MATCH (council:Council)<-[:HAS]-(this)

      WITH COUNT(DISTINCT council) as count
      RETURN
      CASE
      WHEN count < 1 THEN null
      ELSE count
      END AS result
      """
      columnName: "councilBankingDefaultersThisWeekCount"
    )
}

extend type Campus {
  governorshipBankedThisWeek: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord) WHERE NOT record:NoService

       WITH DISTINCT record, this
        WHERE record.bankingSlip IS NOT NULL
          OR record.transactionStatus = 'success'
          OR record.tellerConfirmationTime IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      RETURN DISTINCT governorships
      """
      columnName: "governorshipBankedThisWeek"
    )
  governorshipBankedThisWeekCount: Int
    @cypher(
      statement: """
       MATCH (this)
       WITH date() as today, this
       WITH  today.weekDay as theDay, today, this
       WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
       WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

       MATCH (date:TimeGraph)
       USING INDEX date:TimeGraph(date)
       WHERE date.date IN dates
       MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord) WHERE NOT record:NoService

       WITH DISTINCT record, this
        WHERE record.bankingSlip IS NOT NULL
          OR record.transactionStatus = 'success'
          OR record.tellerConfirmationTime IS NOT NULL
        MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

        WITH DISTINCT governorships, this
        MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      WITH COUNT(DISTINCT governorships) as count
       RETURN
       CASE
       WHEN count < 1 THEN null
       ELSE count
       END AS result
      """
      columnName: "governorshipBankedThisWeekCount"
    )
  governorshipBankingDefaultersThisWeek: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      RETURN DISTINCT governorships
      """
      columnName: "governorshipBankingDefaultersThisWeek"
    )
  governorshipBankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
       MATCH (this)
       WITH date() as today, this
       WITH  today.weekDay as theDay, today, this
       WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
       WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

       MATCH (date:TimeGraph)
       USING INDEX date:TimeGraph(date)
       WHERE date.date IN dates
       MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

        WITH DISTINCT record, this
         WHERE record.noServiceReason IS NULL
           AND record.bankingSlip IS NULL
           AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
           AND record.tellerConfirmationTime IS NULL
        MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

        WITH DISTINCT governorships, this
        MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      WITH COUNT(DISTINCT governorships) as count
       RETURN
       CASE
       WHEN count < 1 THEN null
       ELSE count
       END AS result
      """
      columnName: "governorshipBankingDefaultersThisWeekCount"
    )

  governorshipBankingDefaulters: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Stream)-[:HAS]->(:Council)-[:HAS]->(governorships)
      WHERE governorships:Governorship OR governorships:ClosedGovernorship
      MATCH (record:ServiceRecord)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships)

      WHERE record.noServiceReason IS NULL
        AND record.bankingSlip IS NULL
        AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
        AND record.tellerConfirmationTime IS NULL


      RETURN DISTINCT governorships
      """
      columnName: "governorshipBankingDefaulters"
    )
  governorshipBankingDefaultersCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Stream)-[:HAS]->(:Council)-[:HAS]->(governorships)
      WHERE governorships:Governorship OR governorships:ClosedGovernorship
       MATCH (record:ServiceRecord)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships)

       WHERE record.noServiceReason IS NULL
         AND record.bankingSlip IS NULL
         AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
         AND record.tellerConfirmationTime IS NULL

      WITH COUNT(DISTINCT governorships) as count
      RETURN
      CASE
      WHEN count < 1 THEN null
      ELSE count
      END AS result
      """
      columnName: "governorshipBankingDefaultersCount"
    )

  councilBankingDefaulters: [Council!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Stream)-[:HAS]->(council) WHERE council:Council OR council:ClosedCouncil
      MATCH (record:ServiceRecord)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council)

      WHERE record.noServiceReason IS NULL
        AND record.bankingSlip IS NULL
        AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
        AND record.tellerConfirmationTime IS NULL


      RETURN DISTINCT council
      """
      columnName: "councilBankingDefaulters"
    )
  councilBankingDefaultersCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Stream)-[:HAS]->(council) WHERE council:Council OR council:ClosedCouncil
      MATCH (record:ServiceRecord)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council)

      WHERE record.noServiceReason IS NULL
        AND record.bankingSlip IS NULL
        AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
        AND record.tellerConfirmationTime IS NULL

      WITH COUNT(DISTINCT council) as count
      RETURN
      CASE
      WHEN count < 1 THEN null
      ELSE count
      END AS result
      """
      columnName: "councilBankingDefaultersCount"
    )
  councilBankedThisWeek: [Council!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord) WHERE NOT record:NoService

       WITH DISTINCT record, this
        WHERE record.bankingSlip IS NOT NULL
          OR record.transactionStatus = 'success'
          OR record.tellerConfirmationTime IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council) WHERE council:Council OR council:ClosedCouncil

       WITH DISTINCT council, this
       MATCH (council:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      RETURN DISTINCT council
      """
      columnName: "councilBankedThisWeek"
    )
  councilBankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord) WHERE NOT record:NoService

       WITH DISTINCT record, this
        WHERE record.bankingSlip IS NOT NULL
          OR record.transactionStatus = 'success'
          OR record.tellerConfirmationTime IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council) WHERE council:Council OR council:ClosedCouncil

       WITH DISTINCT council, this
       MATCH (council:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)

      WITH COUNT(DISTINCT council) as count
      RETURN
      CASE
      WHEN count < 1 THEN null
      ELSE count
      END AS result
      """
      columnName: "councilBankedThisWeekCount"
    )
  councilBankingDefaultersThisWeek: [Council!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council) WHERE council:Council OR council:ClosedCouncil

       WITH DISTINCT council, this
       MATCH (council:Council)<-[:HAS]-(this)

      RETURN DISTINCT council
      """
      columnName: "councilBankingDefaultersThisWeek"
    )
  councilBankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council) WHERE council:Council OR council:ClosedCouncil

       WITH DISTINCT council, this
       MATCH (council:Council)<-[:HAS]-(this)

      WITH COUNT(DISTINCT council) as count
      RETURN
      CASE
      WHEN count < 1 THEN null
      ELSE count
      END AS result
      """
      columnName: "councilBankingDefaultersThisWeekCount"
    )
}

extend type Oversight {
  governorshipBankedThisWeek: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord) WHERE NOT record:NoService

       WITH DISTINCT record, this
        WHERE record.bankingSlip IS NOT NULL
          OR record.transactionStatus = 'success'
          OR record.tellerConfirmationTime IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(:Campus)<-[:HAS]-(this)

      RETURN DISTINCT governorships
      """
      columnName: "governorshipBankedThisWeek"
    )
  governorshipBankedThisWeekCount: Int
    @cypher(
      statement: """
       MATCH (this)
       WITH date() as today, this
       WITH  today.weekDay as theDay, today, this
       WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
       WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

       MATCH (date:TimeGraph)
       USING INDEX date:TimeGraph(date)
       WHERE date.date IN dates
       MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord) WHERE NOT record:NoService

       WITH DISTINCT record, this
        WHERE record.bankingSlip IS NOT NULL
          OR record.transactionStatus = 'success'
          OR record.tellerConfirmationTime IS NOT NULL
        MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

        WITH DISTINCT governorships, this
        MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(:Campus)<-[:HAS]-(this)

      WITH COUNT(DISTINCT governorships) as count
       RETURN
       CASE
       WHEN count < 1 THEN null
       ELSE count
       END AS result
      """
      columnName: "governorshipBankedThisWeekCount"
    )
  governorshipBankingDefaultersThisWeek: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(:Campus)<-[:HAS]-(this)

      RETURN DISTINCT governorships
      """
      columnName: "governorshipBankingDefaultersThisWeek"
    )
  governorshipBankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(:Campus)<-[:HAS]-(this)

      WITH COUNT(DISTINCT governorships) as count
      RETURN
      CASE
      WHEN count < 1 THEN null
      ELSE count
      END AS result
      """
      columnName: "governorshipBankingDefaultersThisWeekCount"
    )

  governorshipBankingDefaulters: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Campus)-[:HAS]->(:Stream)-[:HAS]->(:Council)-[:HAS]->(governorships)
      WHERE governorships:Governorship OR governorships:ClosedGovernorship
      MATCH (record:ServiceRecord)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships)

      WHERE record.noServiceReason IS NULL
        AND record.bankingSlip IS NULL
        AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
        AND record.tellerConfirmationTime IS NULL


      RETURN DISTINCT governorships
      """
      columnName: "governorshipBankingDefaulters"
    )
  governorshipBankingDefaultersCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Campus)-[:HAS]->(:Stream)-[:HAS]->(:Council)-[:HAS]->(governorships)
      WHERE governorships:Governorship OR governorships:ClosedGovernorship
       MATCH (record:ServiceRecord)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships)

       WHERE record.noServiceReason IS NULL
         AND record.bankingSlip IS NULL
         AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
         AND record.tellerConfirmationTime IS NULL

      WITH COUNT(DISTINCT governorships) as count
      RETURN
      CASE
      WHEN count < 1 THEN null
      ELSE count
      END AS result
      """
      columnName: "governorshipBankingDefaultersCount"
    )

  councilBankedThisWeek: [Council!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord) WHERE NOT record:NoService

       WITH DISTINCT record, this
        WHERE record.bankingSlip IS NOT NULL
          OR record.transactionStatus = 'success'
          OR record.tellerConfirmationTime IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council) WHERE council:Council OR council:ClosedCouncil

       WITH DISTINCT council, this
       MATCH (council:Council)<-[:HAS]-(:Stream)<-[:HAS]-(:Campus)<-[:HAS]-(this)

      RETURN DISTINCT council
      """
      columnName: "councilBankedThisWeek"
    )
  councilBankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord) WHERE NOT record:NoService

       WITH DISTINCT record, this
        WHERE record.bankingSlip IS NOT NULL
          OR record.transactionStatus = 'success'
          OR record.tellerConfirmationTime IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council) WHERE council:Council OR council:ClosedCouncil

       WITH DISTINCT council, this
       MATCH (council:Council)<-[:HAS]-(:Stream)<-[:HAS]-(:Campus)<-[:HAS]-(this)

      WITH COUNT(DISTINCT council) as count
      RETURN
      CASE
      WHEN count < 1 THEN null
      ELSE count
      END AS result
      """
      columnName: "councilBankedThisWeekCount"
    )
  councilBankingDefaulters: [Council!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Campus)-[:HAS]->(:Stream)-[:HAS]->(council) WHERE council:Council OR council:ClosedCouncil
      MATCH (record:ServiceRecord)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council)

      WHERE record.noServiceReason IS NULL
        AND record.bankingSlip IS NULL
        AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
        AND record.tellerConfirmationTime IS NULL


      RETURN DISTINCT council
      """
      columnName: "councilBankingDefaulters"
    )
  councilBankingDefaultersCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Campus)-[:HAS]->(:Stream)-[:HAS]->(council) WHERE council:Council OR council:ClosedCouncil
      MATCH (record:ServiceRecord)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council)

      WHERE record.noServiceReason IS NULL
        AND record.bankingSlip IS NULL
        AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
        AND record.tellerConfirmationTime IS NULL

      WITH COUNT(DISTINCT council) as count
      RETURN
      CASE
      WHEN count < 1 THEN null
      ELSE count
      END AS result
      """
      columnName: "councilBankingDefaultersCount"
    )

  councilBankingDefaultersThisWeek: [Council!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council) WHERE council:Council OR council:ClosedCouncil

       WITH DISTINCT council, this
       MATCH (council:Council)<-[:HAS]-(:Stream)<-[:HAS]-(:Campus)<-[:HAS]-(this)

      RETURN DISTINCT council
      """
      columnName: "councilBankingDefaultersThisWeek"
    )
  councilBankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(council) WHERE council:Council OR council:ClosedCouncil

       WITH DISTINCT council, this
       MATCH (council:Council)<-[:HAS]-(:Stream)<-[:HAS]-(:Campus)<-[:HAS]-(this)

      WITH COUNT(DISTINCT council) as count
      RETURN
      CASE
      WHEN count < 1 THEN null
      ELSE count
      END AS result
      """
      columnName: "councilBankingDefaultersThisWeekCount"
    )
}
 extend type Stream {
  tellers: [Member!]! @relationship(type: "IS_TELLER_FOR", direction: IN)
}

extend type ServiceRecord {
  tellerConfirmationTime: DateTime
  bankingConfirmer: Member
    @relationship(type: "CONFIRMED_BANKING_FOR", direction: IN)
}

extend type Member {
  isTellerForStream: [Stream!]!
    @relationship(type: "IS_TELLER_FOR", direction: OUT)
}

extend type Mutation {
  MakeStreamTeller(streamId: ID!, tellerId: ID!): Member!
  RemoveStreamTeller(streamId: ID!, tellerId: ID!): Member!
  ConfirmBanking(governorshipId: ID!): Governorship!
}

extend type Stream {
  governorshipBankingDefaultersThisWeek: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY|HAS*1..2]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(this)

      RETURN DISTINCT governorships
      """
      columnName: "governorshipBankingDefaultersThisWeek"
    )
  governorshipBankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY|HAS*1..2]-(governorships) WHERE governorships:Governorship OR governorships:ClosedGovernorship

       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT governorships)
      """
      columnName: "governorshipBankingDefaultersThisWeekCount"
    )
}

extend type AggregateServiceRecord {
  foreignCurrency: [String]
}

extend type Governorship {
  aggregateServiceRecordForWeek(week: Int!): AggregateServiceRecord!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      MATCH (agg) WHERE agg.week = $week AND agg.year = date().year

      WITH agg, this
      WITH date() as today, this, agg
      WITH  today.weekDay as theDay, today, this, agg
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this, agg
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this, agg

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY|HAS*1..2]-(this)

      WITH DISTINCT record, agg
      WITH collect(record.foreignCurrency) as list, SUM(record.income) AS income, SUM(record.attendance) AS attendance, agg

      RETURN {
        id: agg.id,
        attendance: attendance,
        income: income,
        week: agg.week,
        year: agg.year,
        foreignCurrency: list
      }
      """
      columnName: "aggregateServiceRecordForWeek"
    )
  banked: Boolean!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

      WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
      MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta

      WITH DISTINCT fellowships, this
      MATCH (fellowships)<-[:HAS]-(:Bacenta)<-[:HAS]-(this)

      WITH COUNT(DISTINCT fellowships) as bankingDefaulters
      RETURN
      CASE bankingDefaulters
      WHEN 0 THEN true
      ELSE false
      END AS banked
      """
      columnName: "banked"
    )

  bankedBy: Member
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
        AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(bacentas) WHERE bacentas:Bacenta OR bacentas:ClosedBacenta


      WITH DISTINCT  this, record
      MATCH (teller:Member)-[:CONFIRMED_BANKING_FOR]->(record:ServiceRecord)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships)<-[:HAS]-(:Bacenta)<-[:HAS]-(this)


      RETURN DISTINCT teller
      """
      columnName: "bankedBy"
    )
}
 type SwellDate implements TimeGraphNode {
  id: ID!
    @cypher(
      statement: """
      MATCH (this)
      RETURN toString(this.date)
      """
      columnName: "id"
    )
  date: Date
  swell: Boolean
    @cypher(
      statement: """
      MATCH (this)
      UNWIND labels(this) AS swellStatus
      WITH swellStatus WHERE swellStatus ='SwellDate'
      RETURN true
      """
      columnName: "swell"
    )
  bussingDate: [BussingRecord!]! @relationship(type: "BUSSED_ON", direction: IN)
}

extend type Member {
  isArrivalsAdminForCouncil: [Council!]!
    @relationship(type: "DOES_ARRIVALS_FOR", direction: OUT)
  isArrivalsAdminForGovernorship: [Governorship!]!
    @relationship(type: "DOES_ARRIVALS_FOR", direction: OUT)
  isArrivalsAdminForStream: [Stream!]!
    @relationship(type: "DOES_ARRIVALS_FOR", direction: OUT)
  isArrivalsAdminForCampus: [Campus!]!
    @relationship(type: "DOES_ARRIVALS_FOR", direction: OUT)
  isArrivalsCounterForStream: [Stream!]!
    @relationship(type: "COUNTS_ARRIVALS_FOR", direction: OUT)
}

extend type Oversight {
  graduatedBacentas: [Bacenta!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*5]->(bacentas:Green:Bacenta) RETURN bacentas"
      columnName: "graduatedBacentas"
    )
  icBacentas: [Bacenta!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*5]->(bacentas:Red:Bacenta) RETURN bacentas"
      columnName: "icBacentas"
    )
  icBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*5]->(bacentas:Red:Bacenta) RETURN COUNT(DISTINCT bacentas)"
      columnName: "icBacentaCount"
    )
  activeIcBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*5]->(bacentas:Red:Bacenta:Active) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeIcBacentaCount"
    )
  vacationIcBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*5]-(bacentas:Red:Bacenta:Vacation) RETURN COUNT(bacentas)"
      columnName: "vacationIcBacentaCount"
    )
}

extend type Campus {
  arrivalsAdmin: Member @relationship(type: "DOES_ARRIVALS_FOR", direction: IN)
  bacentasNoActivity(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      WHERE NOT EXISTS {
        MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        }
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasNoActivity"
    )
  bacentasNoActivityCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
       WHERE NOT EXISTS {
         MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
         WHERE date(date.date)=date($arrivalDate)
         }
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasNoActivityCount"
    )
  bacentasMobilising(arrivalDate: String): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND bussing.mobilisationPicture IS NOT NULL
        AND bussing.leaderDeclaration IS NULL
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasMobilising"
    )
  bacentasMobilisingCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND bussing.mobilisationPicture IS NOT NULL
        AND bussing.leaderDeclaration IS NULL
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasMobilisingCount"
    )
  bacentasOnTheWay(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND EXISTS {
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NULL
        }
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasOnTheWay"
    )
  bacentasOnTheWayCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND EXISTS {
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NULL
        }
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasOnTheWayCount"
    )
  bussingMembersOnTheWayCount(arrivalDate: String!): Int
    @cypher(
      statement: """
       MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NULL
      WITH DISTINCT record
      RETURN SUM(record.leaderDeclaration)
      """
      columnName: "bussingMembersOnTheWayCount"
    )
  bacentasNotCounted(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date(date.date)=date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
      WHERE NOT EXISTS {
       MATCH (record)-[:COUNTED_BY]->(:Member)
      }
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasNotCounted"
    )
  vehiclesNotCountedCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date(date.date)=date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
      WHERE NOT EXISTS {
       MATCH (record)-[:COUNTED_BY]->(:Member)
      }
      RETURN COUNT(DISTINCT record)
      """
      columnName: "vehiclesNotCountedCount"
    )
  bacentasBelow8(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND bussing.attendance < 8
        WITH bacentas, bussing ORDER BY bussing.attendance ASC
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasBelow8"
    )
  bacentasBelow8Count(arrivalDate: String!): Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND bussing.attendance < 8
        WITH bacentas, bussing ORDER BY bussing.attendance ASC
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasBelow8Count"
    )
  bacentasHaveArrived(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
       WHERE date(date.date)=date($arrivalDate)
        AND EXISTS {
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NOT NULL AND record.attendance > 0
        }
        WITH bacentas, bussing ORDER BY bussing.attendance DESC
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasHaveArrived"
    )
  bacentasHaveArrivedCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND EXISTS {
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NOT NULL AND record.attendance > 0
        }
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasHaveArrivedCount"
    )
  bussingMembersHaveArrivedCount(arrivalDate: String!): Int
    @cypher(
      statement: """
       MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
         WHERE date(date.date)=date($arrivalDate)
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NOT NULL
        WITH DISTINCT record
      RETURN SUM(record.attendance)
      """
      columnName: "bussingMembersHaveArrivedCount"
    )
  bussesOnTheWayCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
         WHERE date(date.date)=date($arrivalDate)
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NULL
        AND record.leaderDeclaration IS NOT NULL
        AND record.vehicle <> 'Car'
      RETURN COUNT(DISTINCT record)
      """
      columnName: "bussesOnTheWayCount"
    )
  bussesThatArrivedCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
         WHERE date(date.date)=date($arrivalDate)
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NOT NULL
        AND record.attendance > 0
        AND record.vehicle <> 'Car'
      RETURN COUNT(DISTINCT record)
      """
      columnName: "bussesThatArrivedCount"
    )
  graduatedBacentas: [Bacenta!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(bacentas:Green:Bacenta) RETURN bacentas"
      columnName: "graduatedBacentas"
    )
  icBacentas: [Bacenta!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(bacentas:Red:Bacenta) RETURN bacentas"
      columnName: "icBacentas"
    )
  icBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(bacentas:Red:Bacenta) RETURN COUNT(DISTINCT bacentas)"
      columnName: "icBacentaCount"
    )
  activeIcBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(bacentas:Red:Bacenta:Active) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeIcBacentaCount"
    )
  vacationIcBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*4]-(bacentas:Red:Bacenta:Vacation) RETURN COUNT(DISTINCT bacentas)"
      columnName: "vacationIcBacentaCount"
    )
}

extend type Stream {
  arrivalsAdmin: Member @relationship(type: "DOES_ARRIVALS_FOR", direction: IN)
  arrivalsCounters: [Member!]!
    @relationship(type: "COUNTS_ARRIVALS_FOR", direction: IN)
  bacentasNoActivity(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      WHERE NOT EXISTS {
        MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        }
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasNoActivity"
    )
  bacentasNoActivityCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
       WHERE NOT EXISTS {
         MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
         WHERE date(date.date)=date($arrivalDate)
         }
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasNoActivityCount"
    )
  bacentasMobilising(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND bussing.mobilisationPicture IS NOT NULL
        AND bussing.leaderDeclaration IS NULL
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasMobilising"
    )
  bacentasMobilisingCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND bussing.mobilisationPicture IS NOT NULL
        AND bussing.leaderDeclaration IS NULL
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasMobilisingCount"
    )
  bacentasOnTheWay(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND EXISTS {
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NULL
        }
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasOnTheWay"
    )
  bacentasOnTheWayCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND EXISTS {
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NULL
        }
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasOnTheWayCount"
    )
  bussesOnTheWayCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
         WHERE date(date.date)=date($arrivalDate)
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NULL
        AND record.leaderDeclaration IS NOT NULL
        AND record.vehicle <> 'Car'
      RETURN COUNT(DISTINCT record)
      """
      columnName: "bussesOnTheWayCount"
    )
  bussingMembersOnTheWayCount(arrivalDate: String!): Int
    @cypher(
      statement: """
       MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NULL
      WITH DISTINCT record
      RETURN SUM(record.leaderDeclaration)
      """
      columnName: "bussingMembersOnTheWayCount"
    )
  bacentasNotCounted(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date(date.date)=date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
      WHERE NOT EXISTS {
       MATCH (record)-[:COUNTED_BY]->(:Member)
      }
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasNotCounted"
    )
  vehiclesNotCountedCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date(date.date)=date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
      WHERE NOT EXISTS {
       MATCH (record)-[:COUNTED_BY]->(:Member)
      }
      RETURN COUNT(DISTINCT record)
      """
      columnName: "vehiclesNotCountedCount"
    )
  bacentasBelow8(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND bussing.attendance < 8
        WITH bacentas, bussing ORDER BY bussing.attendance ASC
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasBelow8"
    )
  bacentasBelow8Count(arrivalDate: String!): Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND bussing.attendance < 8
        WITH bacentas, bussing ORDER BY bussing.attendance ASC
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasBelow8Count"
    )
  bacentasHaveArrived(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND EXISTS {
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NOT NULL AND record.attendance > 0
        }
        WITH bacentas, bussing ORDER BY bussing.attendance DESC
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasHaveArrived"
    )
  bacentasHaveArrivedCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND EXISTS {
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NOT NULL AND record.attendance > 0
        }
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasHaveArrivedCount"
    )
  bussingMembersHaveArrivedCount(arrivalDate: String!): Int
    @cypher(
      statement: """
       MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
         WHERE date(date.date)=date($arrivalDate)
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NOT NULL
        WITH DISTINCT record
      RETURN SUM(record.attendance)
      """
      columnName: "bussingMembersHaveArrivedCount"
    )
  bussesThatArrivedCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
         WHERE date(date.date)=date($arrivalDate)
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NOT NULL
        AND record.attendance > 0
        AND record.vehicle <> 'Car'
      RETURN COUNT(DISTINCT record)
      """
      columnName: "bussesThatArrivedCount"
    )
  graduatedBacentas: [Bacenta!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(bacentas:Green:Bacenta) RETURN bacentas"
      columnName: "graduatedBacentas"
    )
  icBacentas: [Bacenta!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(bacentas:Red:Bacenta) RETURN bacentas"
      columnName: "icBacentas"
    )
  icBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(bacentas:Red:Bacenta) RETURN COUNT(DISTINCT bacentas)"
      columnName: "icBacentaCount"
    )
  activeIcBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(bacentas:Red:Bacenta:Active) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeIcBacentaCount"
    )
  vacationIcBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]-(bacentas:Red:Bacenta:Vacation) RETURN COUNT(DISTINCT bacentas)"
      columnName: "vacationIcBacentaCount"
    )
}

extend type Council {
  arrivalsAdmin: Member @relationship(type: "DOES_ARRIVALS_FOR", direction: IN)
  bacentasNoActivity(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      WHERE NOT EXISTS {
        MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        }
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasNoActivity"
    )
  bacentasNoActivityCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
       WHERE NOT EXISTS {
         MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
         WHERE date(date.date)=date($arrivalDate)
         }
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasNoActivityCount"
    )
  bacentasMobilising(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND bussing.mobilisationPicture IS NOT NULL
        AND bussing.leaderDeclaration IS NULL
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasMobilising"
    )
  bacentasMobilisingCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND bussing.mobilisationPicture IS NOT NULL
        AND bussing.leaderDeclaration IS NULL
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasMobilisingCount"
    )
  bacentasOnTheWay(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND EXISTS {
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NULL
        }
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasOnTheWay"
    )
  bacentasOnTheWayCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND EXISTS {
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NULL
        }
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasOnTheWayCount"
    )
  bussesOnTheWayCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
         WHERE date(date.date)=date($arrivalDate)
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NULL
        AND record.leaderDeclaration IS NOT NULL
        AND record.vehicle <> 'Car'
      RETURN COUNT(DISTINCT record)
      """
      columnName: "bussesOnTheWayCount"
    )
  bussingMembersOnTheWayCount(arrivalDate: String!): Int
    @cypher(
      statement: """
       MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NULL
      WITH DISTINCT record
      RETURN SUM(record.leaderDeclaration)
      """
      columnName: "bussingMembersOnTheWayCount"
    )
  bacentasNotCounted(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date(date.date)=date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
      WHERE NOT EXISTS {
       MATCH (record)-[:COUNTED_BY]->(:Member)
      }
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasNotCounted"
    )
  vehiclesNotCountedCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date(date.date)=date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
      WHERE NOT EXISTS {
       MATCH (record)-[:COUNTED_BY]->(:Member)
      }
      RETURN COUNT(DISTINCT record)
      """
      columnName: "vehiclesNotCountedCount"
    )
  bacentasBelow8(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND bussing.attendance < 8
        WITH bacentas, bussing ORDER BY bussing.attendance ASC
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasBelow8"
    )
  bacentasBelow8Count(arrivalDate: String!): Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND bussing.attendance < 8
        WITH bacentas, bussing ORDER BY bussing.attendance ASC
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasBelow8Count"
    )
  bacentasHaveArrived(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND EXISTS {
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NOT NULL AND record.attendance > 0
        }
        WITH bacentas, bussing ORDER BY bussing.attendance DESC
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasHaveArrived"
    )
  bacentasHaveArrivedCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND EXISTS {
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NOT NULL AND record.attendance > 0
        }
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasHaveArrivedCount"
    )
  bussingMembersHaveArrivedCount(arrivalDate: String!): Int
    @cypher(
      statement: """
       MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
         WHERE date(date.date)=date($arrivalDate)
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NOT NULL
      WITH DISTINCT record
      RETURN SUM(record.attendance)
      """
      columnName: "bussingMembersHaveArrivedCount"
    )
  bussesThatArrivedCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
         WHERE date(date.date)=date($arrivalDate)
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NOT NULL
        AND record.attendance > 0
        AND record.vehicle <> 'Car'
      RETURN COUNT(DISTINCT record)
      """
      columnName: "bussesThatArrivedCount"
    )
  graduatedBacentas: [Bacenta!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(bacentas:Green:Bacenta) RETURN bacentas"
      columnName: "graduatedBacentas"
    )
  icBacentas: [Bacenta!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(bacentas:Red:Bacenta) RETURN bacentas"
      columnName: "icBacentas"
    )
  icBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(bacentas:Red:Bacenta) RETURN COUNT(DISTINCT bacentas)"
      columnName: "icBacentaCount"
    )
  activeIcBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(bacentas:Red:Bacenta:Active) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeIcBacentaCount"
    )
  vacationIcBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]-(bacentas:Red:Bacenta:Vacation) RETURN COUNT(DISTINCT bacentas)"
      columnName: "vacationIcBacentaCount"
    )
}

extend type Governorship {
  #Arrivals in the Governorship
  arrivalsAdmin: Member @relationship(type: "DOES_ARRIVALS_FOR", direction: IN)
  bacentasNoActivity(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)
      WHERE NOT EXISTS {
        MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        }
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasNoActivity"
    )
  bacentasNoActivityCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)
       WHERE NOT EXISTS {
         MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
         WHERE date(date.date)=date($arrivalDate)
         }
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasNoActivityCount"
    )
  bacentasMobilising(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND bussing.mobilisationPicture IS NOT NULL
        AND bussing.leaderDeclaration IS NULL
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasMobilising"
    )
  bacentasMobilisingCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND bussing.mobilisationPicture IS NOT NULL
        AND bussing.leaderDeclaration IS NULL
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasMobilisingCount"
    )
  bacentasOnTheWay(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND EXISTS {
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NULL
        }
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasOnTheWay"
    )
  bacentasOnTheWayCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND EXISTS {
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NULL
        }
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasOnTheWayCount"
    )
  bussesOnTheWayCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
         WHERE date(date.date)=date($arrivalDate)
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NULL
        AND record.leaderDeclaration IS NOT NULL
        AND record.vehicle <> 'Car'
      RETURN COUNT(DISTINCT record)
      """
      columnName: "bussesOnTheWayCount"
    )
  bussingMembersOnTheWayCount(arrivalDate: String!): Int
    @cypher(
      statement: """
       MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NULL
      WITH DISTINCT record
      RETURN SUM(record.leaderDeclaration)
      """
      columnName: "bussingMembersOnTheWayCount"
    )
  bacentasNotCounted(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
       MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date(date.date)=date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
      WHERE NOT EXISTS {
       MATCH (record)-[:COUNTED_BY]->(:Member)
      }
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasNotCounted"
    )
  vehiclesNotCountedCount(arrivalDate: String!): Int
    @cypher(
      statement: """
       MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date(date.date)=date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
      WHERE NOT EXISTS {
       MATCH (record)-[:COUNTED_BY]->(:Member)
      }
      RETURN COUNT(DISTINCT record)
      """
      columnName: "vehiclesNotCountedCount"
    )
  bacentasBelow8(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND bussing.attendance < 8
        WITH bacentas, bussing ORDER BY bussing.attendance ASC
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasBelow8"
    )
  bacentasBelow8Count(arrivalDate: String!): Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND bussing.attendance < 8
        WITH bacentas, bussing ORDER BY bussing.attendance ASC
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasBelow8Count"
    )
  bacentasHaveArrived(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND EXISTS {
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NOT NULL AND record.attendance > 0
        }
        WITH bacentas, bussing ORDER BY bussing.attendance DESC
      RETURN DISTINCT bacentas
      """
      columnName: "bacentasHaveArrived"
    )
  bacentasHaveArrivedCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WHERE date(date.date)=date($arrivalDate)
        AND EXISTS {
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NOT NULL AND record.attendance > 0
        }
      RETURN COUNT(DISTINCT bacentas)
      """
      columnName: "bacentasHaveArrivedCount"
    )
  bussingMembersHaveArrivedCount(arrivalDate: String!): Int
    @cypher(
      statement: """
       MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)
       MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
         WHERE date(date.date)=date($arrivalDate)
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NOT NULL
        WITH DISTINCT record
      RETURN SUM(record.attendance)
      """
      columnName: "bussingMembersHaveArrivedCount"
    )
  bussesThatArrivedCount(arrivalDate: String!): Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
         WHERE date(date.date)=date($arrivalDate)
        MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.arrivalTime IS NOT NULL
        AND record.attendance > 0
        AND record.vehicle <> 'Car'
      RETURN COUNT(DISTINCT record)
      """
      columnName: "bussesThatArrivedCount"
    )
  graduatedBacentas: [Bacenta!]!
    @cypher(
      statement: "MATCH (this)-[:HAS]->(bacentas:Green:Bacenta) RETURN bacentas"
      columnName: "graduatedBacentas"
    )
  icBacentas: [Bacenta!]!
    @cypher(
      statement: "MATCH (this)-[:HAS]->(bacentas:Red:Bacenta) RETURN bacentas"
      columnName: "icBacentas"
    )
  icBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]->(bacentas:Red:Bacenta) RETURN COUNT(DISTINCT bacentas)"
      columnName: "icBacentaCount"
    )
  activeIcBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]->(bacentas:Red:Bacenta:Active) RETURN COUNT(DISTINCT bacentas)"
      columnName: "activeIcBacentaCount"
    )
  vacationIcBacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]-(bacentas:Red:Bacenta:Vacation) RETURN COUNT(DISTINCT bacentas)"
      columnName: "vacationIcBacentaCount"
    )
}

extend type Bacenta {
  sprinterTopUp: Float!
  urvanTopUp: Float!
  outbound: Boolean!

  graduationStatus: String!
    @cypher(
      statement: """
      MATCH (this)
      UNWIND labels(this) AS status
      WITH status WHERE status = 'Green' OR status = 'Red'
      RETURN status
      """
      columnName: "graduationStatus"
    )

  mobileNetwork: String
  momoNumber: String
  momoName: String

  #Arrivals Data
  arrivalsCodeOfTheDay: String!
    @cypher(
      statement: "MATCH (arrivals:ArrivalsCodeOfTheDay) RETURN arrivals.code"
      columnName: "arrivalsCodeOfTheDay"
    )
  bussing(limit: Int!): [BussingRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      RETURN bussing ORDER BY date.date DESC LIMIT $limit
      """
      columnName: "bussing"
    )
  bussingThisWeek(limit: Int! = 1, bussingDate: String!): BussingRecord
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date(date.date).week = date($bussingDate).week AND date(date.date).year = date($bussingDate).year
      RETURN bussing ORDER BY date.date DESC LIMIT $limit
      """
      columnName: "bussingThisWeek"
    )
  code: Int!
}

type BussingRecord implements Record {
  id: ID!

  week: Int!
    @cypher(
      statement: """
      MATCH (this)-[:BUSSED_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
      columnName: "week"
    )
  # Mobilisation
  createdAt: DateTime! #mobilisation time is the time the record was created
  serviceDate: TimeGraph! @relationship(type: "BUSSED_ON", direction: OUT)
  mobilisationPicture: String!
  created_by: Member! @relationship(type: "LOGGED_BY", direction: OUT)

  #On The Way
  attendance: Int
  leaderDeclaration: Int
  bussingPictures: [String!]!
    @cypher(
      statement: """
      MATCH (this)-[:INCLUDES_RECORD]->(record:VehicleRecord)
      WHERE record.picture IS NOT NULL
      RETURN collect(record.picture)
      """
      columnName: "bussingPictures"
    )
  numberOfBusses: Int #Legacy Property for before we started collecting Spinter/Urvan details
  numberOfSprinters: Int
  numberOfUrvans: Int
  numberOfCars: Int
  bussingCost: Float
  bussingTopUp: Float

  #Money Things
  mobileNetwork: String
  momoNumber: String
  momoName: String

  counted_by: [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:INCLUDES_RECORD]->(record:VehicleRecord)-[:COUNTED_BY]->(member:Member)
      RETURN DISTINCT member
      """
      columnName: "counted_by"
    )

  vehicleRecords: [VehicleRecord!]!
    @relationship(type: "INCLUDES_RECORD", direction: OUT)
  serviceLog: ServiceLog! @relationship(type: "HAS_BUSSING", direction: IN)
}

type VehicleRecord {
  id: ID!
  created_by: Member! @relationship(type: "LOGGED_BY", direction: OUT)
  createdAt: DateTime! #mobilisation time is the time the record was created
  leaderDeclaration: Int!
  attendance: Int
  picture: String!
  vehicle: String!

  momoNumber: String
  momoName: String
  mobileNetwork: String
  vehicleTopUp: Float
  vehicleCost: Float!

  counted_by: Member @relationship(type: "COUNTED_BY", direction: OUT)

  #Arrived
  comments: String
  arrivalTime: DateTime
  paystackTransferCode: String
  transactionStatus: String
  transactionReference: String
  outbound: Boolean!

  bussingRecord: BussingRecord!
    @relationship(type: "INCLUDES_RECORD", direction: IN)
}

extend type Mutation {
  #Arrivals Roles
  MakeGovernorshipArrivalsAdmin(
    arrivalsAdminId: ID!
    oldArrivalsAdminId: ID
    governorshipId: ID!
  ): Member!
  RemoveGovernorshipArrivalsAdmin(
    arrivalsAdminId: ID!
    newArrivalsAdminId: ID!
    governorshipId: ID!
  ): Member
  MakeCouncilArrivalsAdmin(
    arrivalsAdminId: ID!
    oldArrivalsAdminId: ID
    councilId: ID!
  ): Member!
  RemoveCouncilArrivalsAdmin(
    arrivalsAdminId: ID!
    newArrivalsAdminId: ID!
    councilId: ID!
  ): Member
  MakeStreamArrivalsAdmin(
    arrivalsAdminId: ID!
    oldArrivalsAdminId: ID
    streamId: ID!
  ): Member!
  RemoveStreamArrivalsAdmin(
    arrivalsAdminId: ID!
    newArrivalsAdminId: ID!
    streamId: ID!
  ): Member
  MakeCampusArrivalsAdmin(
    arrivalsAdminId: ID!
    oldArrivalsAdminId: ID!
    campusId: ID!
  ): Member!
  RemoveCampusArrivalsAdmin(
    arrivalsAdminId: ID!
    newArrivalsAdminId: ID
    campusId: ID!
  ): Member

  MakeStreamArrivalsCounter(arrivalsCounterId: ID!, streamId: ID!): Member!
  RemoveStreamArrivalsCounter(arrivalsCounterId: ID!, streamId: ID!): Member

  ## GENERATE CODE OF THE DAY
  GenerateCodeOfTheDay: String!
    @authentication(
      jwt: {
        roles_INCLUDES: ["adminStream", "adminCampus", "arrivalsAdminCampus"]
      }
    )
    @cypher(
      statement: """
      MATCH (arr:ArrivalsCodeOfTheDay)
      SET arr.code = apoc.text.random(5, 'A-Z0-9')
      RETURN arr.code
      """
      columnName: "code"
    )
  SetCodeOfTheDay(code: String!): String!
    @authentication(
      jwt: { roles_INCLUDES: ["adminCampus", "arrivalsAdminCampus"] }
    )
    @cypher(
      statement: """
      MATCH (arr:ArrivalsCodeOfTheDay)
      SET arr.code = $code
      RETURN arr.code
      """
      columnName: "code"
    )

  UpdateBacentaBussingDetails(
    bacentaId: ID!
    target: Int!
    sprinterTopUp: Float!
    urvanTopUp: Float!
    outbound: Boolean!
  ): Bacenta!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminCampus"
          "arrivalsAdminCampus"
          "adminStream"
          "arrivalsAdminStream"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id: $bacentaId})

      WITH bacenta
      MATCH (bacenta)
        SET bacenta.sprinterTopUp = $sprinterTopUp,
          bacenta.urvanTopUp = $urvanTopUp,
          bacenta.outbound = $outbound

      WITH DISTINCT bacenta
      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = bacenta.name + ' Bussing Details were updated'

      WITH log,bacenta
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      MERGE (date:TimeGraph {date: date()})

      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (bacenta)-[:HAS_HISTORY]->(log)

      RETURN bacenta
      """
      columnName: "bacenta"
    )

  UpdateBusPaymentDetails(
    bacentaId: ID!
    mobileNetwork: String!
    momoName: String!
    momoNumber: String!
  ): Bacenta!
    @authentication(jwt: { roles_INCLUDES: ["leaderBacenta"] })
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id: $bacentaId})
        SET bacenta.mobileNetwork = $mobileNetwork,
        bacenta.momoName = $momoName,
        bacenta.momoNumber = $momoNumber
      REMOVE bacenta.recipientCode

      WITH bacenta
      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = bacenta.name + ' Bus Payment Details were updated'

      WITH log,bacenta
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (bacenta)-[:HAS_HISTORY]->(log)

      RETURN bacenta
      """
      columnName: "bacenta"
    )

  UploadMobilisationPicture(
    bacentaId: ID!
    serviceDate: String!
    mobilisationPicture: String!
  ): BussingRecord!

  #Bussing Records Entries
  RecordVehicleFromBacenta(
    bacentaId: ID!
    bussingRecordId: ID!
    leaderDeclaration: Int!
    vehicle: String!
    picture: String!
  ): VehicleRecord!

  SetVehicleSupport(vehicleRecordId: ID!): VehicleRecord!

  ConfirmVehicleByAdmin(
    vehicleRecordId: ID!
    attendance: Int!
    vehicle: String!
    comments: String
  ): VehicleRecord!
    @authentication(jwt: { roles_INCLUDES: ["arrivalsCounterStream"] })
    @cypher(
      statement: """
      MATCH (vehicleRecord:VehicleRecord {id: $vehicleRecordId}) WHERE vehicleRecord.arrivalTime IS NULL
        SET vehicleRecord.attendance = $attendance,
        vehicleRecord.vehicle = $vehicle,
        vehicleRecord.comments = $comments

         WITH vehicleRecord
          MATCH (admin:Member {auth_id: $auth.jwt.sub})
          MERGE (vehicleRecord)-[:COUNTED_BY]->(admin)

      RETURN vehicleRecord
      """
      columnName: "vehicleRecord"
    )

  SetSwellDate(date: String!): TimeGraph!
  SendVehicleSupport(
    vehicleRecordId: ID!
    momoName: String!
    momoNumber: String!
    vehicleTopUp: Int!
    outbound: Boolean!
  ): VehicleRecord!
}

extend type Mutation {
  SetStreamArrivalTimes(
    id: ID!
    mobilisationStartTime: String!
    mobilisationEndTime: String!
    arrivalStartTime: String!
    arrivalEndTime: String!
  ): Stream!
    @cypher(
      statement: """
      MATCH (stream:Stream {id: $id})
      SET stream.mobilisationStartTime = $mobilisationStartTime,
        stream.mobilisationEndTime = $mobilisationEndTime,
        stream.arrivalStartTime = $arrivalStartTime,
        stream.arrivalEndTime = $arrivalEndTime
      RETURN stream
      """
      columnName: "stream"
    )
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminStream"
          "arrivalsAdminStream"
          "adminCampus"
          "arrivalsAdminCampus"
        ]
      }
    )
}

#SETTING AND ENDING TIME THINGS
extend type Stream {
  mobilisationStartTime: DateTime
  mobilisationEndTime: DateTime
  arrivalStartTime: DateTime
  arrivalEndTime: DateTime
}

extend type Mutation {
  SendMobileVerificationNumber(
    firstName: String!
    phoneNumber: String!
    otp: String!
  ): String!

  SetStreamArrivalTimes(
    id: ID!
    mobilisationStartTime: String!
    mobilisationEndTime: String!
    arrivalStartTime: String!
    arrivalEndTime: String!
  ): Stream!
    @cypher(
      statement: """
      MATCH (stream:Stream {id: $id})
      SET stream.mobilisationStartTime = $mobilisationStartTime,
        stream.mobilisationEndTime = $mobilisationEndTime,
        stream.arrivalStartTime = $arrivalStartTime,
        stream.arrivalEndTime = $arrivalEndTime
      RETURN stream
      """
      columnName: "stream"
    )
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminStream"
          "arrivalsAdminStream"
          "adminCampus"
          "arrivalsAdminCampus"
        ]
      }
    )
}

type ArrivalsSheetData {
  date: Date
  stream: String
  councilHead: String
  bacenta: String
  leader: String
  bacentaCode: String
  attendance: Int
  confirmedAttendance: Int
  vehicle: String
  outbound: String
  topUp: Float
  vehicleCost: Float
  momoNumber: String
  comments: String
  arrivalTime: DateTime
  council: String
  governorship: String
  society: String
  momoName: String
}

extend type Stream {
  arrivalsPaymentData(arrivalsDate: String): [ArrivalsSheetData!]!
}
 extend type Campus {
  vehiclesHaveBeenPaidCount(arrivalDate: String!): Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date.date = date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.vehicleTopUp > 0 AND record.transactionStatus = 'success'
      WITH DISTINCT record
      RETURN COUNT(record)
      """
      columnName: "result"
    )
  vehiclesToBePaidCount(arrivalDate: String!): Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date.date = date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.vehicleTopUp > 0 AND record.transactionStatus IS NULL
      WITH DISTINCT record
      RETURN COUNT(record)
      """
      columnName: "result"
    )
  vehicleAmountHasBeenPaid(arrivalDate: String!): Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date.date = date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.vehicleTopUp > 0 AND record.transactionStatus = 'success'
      WITH DISTINCT record
      RETURN SUM(record.vehicleTopUp)
      """
      columnName: "result"
    )
  vehicleAmountToBePaid(arrivalDate: String!): Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date.date = date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.vehicleTopUp > 0 AND record.transactionStatus IS NULL
      WITH DISTINCT record
      RETURN SUM(record.vehicleTopUp)
      """
      columnName: "result"
    )
  bacentasToBePaid(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date.date = date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.vehicleTopUp > 0
      WITH DISTINCT bacentas
      RETURN bacentas
      """
      columnName: "result"
    )
}

extend type Stream {
  vehiclesHaveBeenPaidCount(arrivalDate: String!): Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date.date = date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.vehicleTopUp > 0 AND record.transactionStatus = 'success'
      WITH DISTINCT record
      RETURN COUNT(record)
      """
      columnName: "result"
    )
  vehiclesToBePaidCount(arrivalDate: String!): Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date.date = date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.vehicleTopUp > 0 AND record.transactionStatus IS NULL
      WITH DISTINCT record
      RETURN COUNT(record)
      """
      columnName: "result"
    )
  vehicleAmountHasBeenPaid(arrivalDate: String!): Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date.date = date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.vehicleTopUp > 0 AND record.transactionStatus = 'success'
      WITH DISTINCT record
      RETURN SUM(record.vehicleTopUp)
      """
      columnName: "result"
    )
  vehicleAmountToBePaid(arrivalDate: String!): Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date.date = date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.vehicleTopUp > 0 AND record.transactionStatus IS NULL
      WITH DISTINCT record
      RETURN SUM(record.vehicleTopUp)
      """
      columnName: "result"
    )
  bacentasToBePaid(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date.date = date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.vehicleTopUp > 0
      WITH DISTINCT bacentas
      RETURN bacentas
      """
      columnName: "result"
    )
}

extend type Council {
  arrivalsPayers: [Member!]!
    @relationship(type: "IS_ARRIVALS_PAYER_FOR", direction: IN)
  vehiclesHaveBeenPaidCount(arrivalDate: String!): Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date.date = date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.vehicleTopUp > 0 AND record.transactionStatus = 'success'
      WITH DISTINCT record
      RETURN COUNT(record)
      """
      columnName: "result"
    )
  vehiclesToBePaidCount(arrivalDate: String!): Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date.date = date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.vehicleTopUp > 0 AND record.transactionStatus IS NULL
      WITH DISTINCT record
      RETURN COUNT(record)
      """
      columnName: "result"
    )
  vehicleAmountHasBeenPaid(arrivalDate: String!): Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date.date = date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.vehicleTopUp > 0 AND record.transactionStatus = 'success'
      WITH DISTINCT record
      RETURN SUM(record.vehicleTopUp)
      """
      columnName: "result"
    )
  vehicleAmountToBePaid(arrivalDate: String!): Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date.date = date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.vehicleTopUp > 0 AND record.transactionStatus IS NULL
      WITH DISTINCT record
      RETURN SUM(record.vehicleTopUp)
      """
      columnName: "result"
    )
  bacentasToBePaid(arrivalDate: String!): [Bacenta!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacentas:Active:Bacenta)
      MATCH (bacentas)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
      WHERE date.date = date($arrivalDate)
      MATCH (bussing)-[:INCLUDES_RECORD]->(record:VehicleRecord)
        WHERE record.vehicleTopUp > 0
      WITH DISTINCT bacentas
      RETURN bacentas
      """
      columnName: "result"
    )
}

extend type VehicleRecord {
  paymentConfirmationTime: DateTime
  paymentConfirmer: Member
    @relationship(type: "CONFIRMED_BPAYMENT_FOR", direction: IN)
}

extend type Member {
  isArrivalsPayerForCouncil: [Council!]!
    @relationship(type: "IS_ARRIVALS_PAYER_FOR", direction: OUT)
}

extend type Mutation {
  MakeCouncilArrivalsPayer(councilId: ID!, arrivalsPayerId: ID!): Member!
  RemoveCouncilArrivalsPayer(councilId: ID!, arrivalsPayerId: ID!): Member!
}
 type AggregateServiceRecord implements HadService {
  id: ID!
  week: Int!
  year: Int!
  attendance: Int!
  income: Float!
  dollarIncome: Float!
  numberOfServices: Int
}

type AggregateBussingRecord {
  id: ID!
  week: Int!
  year: Int!
  attendance: Int
  leaderDeclaration: Int!
  numberOfSprinters: Int!
  numberOfUrvans: Int!
  numberOfCars: Int!
  bussingTopUp: Float
}

extend type Bacenta {
  aggregateServiceRecords(limit: Int! = 4): [AggregateServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(aggregate:AggregateServiceRecord)
      WHERE aggregate.year = date().year OR aggregate.year = date().year -1
      RETURN aggregate ORDER BY aggregate.year DESC, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateServiceRecords"
    )
  aggregateBussingRecords(limit: Int! = 4): [AggregateBussingRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      WHERE aggregate.year = date().year OR aggregate.year = date().year -1
      RETURN aggregate ORDER BY aggregate.year DESC, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateBussingRecords"
    )
}

extend type Governorship {
  aggregateServiceRecords(limit: Int! = 4): [AggregateServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(aggregate:AggregateServiceRecord)
      WHERE aggregate.year = date().year OR aggregate.year = date().year -1
      RETURN aggregate ORDER BY aggregate.year DESC, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateServiceRecords"
    )
  aggregateBussingRecords(limit: Int! = 4): [AggregateBussingRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      WHERE aggregate.year = date().year OR aggregate.year = date().year -1
      RETURN aggregate ORDER BY aggregate.year DESC, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateBussingRecords"
    )
}

extend type Council {
  aggregateServiceRecords(limit: Int! = 4): [AggregateServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(aggregate:AggregateServiceRecord)
      WHERE aggregate.year = date().year OR aggregate.year = date().year -1
      RETURN aggregate ORDER BY aggregate.year DESC, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateServiceRecords"
    )
  aggregateBussingRecords(limit: Int! = 4): [AggregateBussingRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      WHERE aggregate.year = date().year OR aggregate.year = date().year -1
      RETURN aggregate ORDER BY aggregate.year DESC, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateBussingRecords"
    )
}

extend type Stream {
  aggregateServiceRecords(limit: Int! = 4): [AggregateServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(aggregate:AggregateServiceRecord)
      WHERE aggregate.year = date().year OR aggregate.year = date().year -1
      RETURN aggregate ORDER BY aggregate.year DESC, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateServiceRecords"
    )
  aggregateBussingRecords(limit: Int! = 4): [AggregateBussingRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      WHERE aggregate.year = date().year OR aggregate.year = date().year -1
      RETURN aggregate ORDER BY aggregate.year DESC, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateBussingRecords"
    )
}

extend type Campus {
  aggregateServiceRecords(limit: Int! = 4): [AggregateServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(aggregate:AggregateServiceRecord)
      WHERE aggregate.year = date().year OR aggregate.year = date().year -1
      RETURN aggregate ORDER BY aggregate.year DESC, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateServiceRecords"
    )
  aggregateBussingRecords(limit: Int! = 4): [AggregateBussingRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      WHERE aggregate.year = date().year OR aggregate.year = date().year -1
      RETURN aggregate ORDER BY aggregate.year DESC, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateBussingRecords"
    )
}

extend type Oversight {
  aggregateServiceRecords(limit: Int! = 4): [AggregateServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(aggregate:AggregateServiceRecord)
      WHERE aggregate.year = date().year OR aggregate year = date().year -1
      RETURN aggregate ORDER BY aggregate.year DESC, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateServiceRecords"
    )
  aggregateBussingRecords(limit: Int! = 4): [AggregateBussingRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      WHERE aggregate.year = date().year OR aggregate year = date().year -1
      RETURN aggregate ORDER BY aggregate.year DESC, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateBussingRecords"
    )
}

extend type Denomination {
  aggregateServiceRecords(limit: Int! = 4): [AggregateServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(aggregate:AggregateServiceRecord)
      WHERE aggregate.year = date().year OR aggregate year = date().year -1
      RETURN aggregate ORDER BY aggregate.year DESC, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateServiceRecords"
    )
  aggregateBussingRecords(limit: Int! = 4): [AggregateBussingRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      WHERE aggregate.year = date().year OR aggregate year = date().year -1
      RETURN aggregate ORDER BY aggregate.year DESC, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateBussingRecords"
    )
}

type AggregateRehearsalRecord implements HadService {
  id: ID!
  week: Int!
  year: Int!
  attendance: Int!
  income: Float!
  dollarIncome: Float!
  numberOfServices: Int
}

type AggregateStageAttendanceRecord {
  id: ID!
  week: Int!
  year: Int!
  attendance: Int!
  numberOfServices: Int
}

extend type Hub {
  aggregateServiceRecords(limit: Int! = 4): [AggregateServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(aggregate:AggregateServiceRecord)
      WHERE aggregate.year = date().year OR aggregate year = date().year -1
      RETURN aggregate ORDER BY aggregate.year DESC, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateServiceRecords"
    )
}

extend type HubCouncil {
  aggregateServiceRecords(limit: Int! = 4): [AggregateServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(aggregate:AggregateServiceRecord)
      WHERE aggregate year = date().year OR aggregate year = date().year -1
      RETURN aggregate ORDER BY aggregate year DESC, aggregate week DESC LIMIT $limit
      """
      columnName: "aggregateServiceRecords"
    )
  aggregateRehearsalRecords(limit: Int! = 4): [AggregateRehearsalRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(aggregate:AggregateRehearsalRecord)
      WHERE aggregate year = date().year OR aggregate year = date().year -1
      RETURN aggregate ORDER BY aggregate year DESC, aggregate week DESC LIMIT $limit
      """
      columnName: "aggregateRehearsalRecords"
    )
}

extend type Ministry {
  aggregateServiceRecords(limit: Int! = 4): [AggregateServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(aggregate:AggregateServiceRecord)
      WHERE aggregate year = date().year OR aggregate year = date().year -1
      RETURN aggregate ORDER BY aggregate year DESC, aggregate week DESC LIMIT $limit
      """
      columnName: "aggregateServiceRecords"
    )
  aggregateRehearsalRecords(limit: Int! = 4): [AggregateRehearsalRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(aggregate:AggregateRehearsalRecord)
      WHERE aggregate year = date().year OR aggregate year = date().year -1
      RETURN aggregate ORDER BY aggregate year DESC, aggregate week DESC LIMIT $limit
      """
      columnName: "aggregateRehearsalRecords"
    )
}

extend type CreativeArts {
  aggregateServiceRecords(limit: Int! = 4): [AggregateServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(aggregate:AggregateServiceRecord)
      WHERE aggregate year = date().year OR aggregate year = date().year -1
      RETURN aggregate ORDER BY aggregate year DESC, aggregate week DESC LIMIT $limit
      """
      columnName: "aggregateServiceRecords"
    )
  aggregateRehearsalRecords(limit: Int! = 4): [AggregateRehearsalRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(aggregate:AggregateRehearsalRecord)
      WHERE aggregate year = date().year OR aggregate year = date().year -1
      RETURN aggregate ORDER BY aggregate year DESC, aggregate week DESC LIMIT $limit
      """
      columnName: "aggregateRehearsalRecords"
    )
  aggregateStageAttendanceRecords(
    limit: Int! = 4
  ): [AggregateStageAttendanceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(aggregate:AggregateStageAttendanceRecord)
      WHERE aggregate year = date().year OR aggregate year = date().year -1
      RETURN aggregate ORDER BY aggregate year DESC, aggregate week DESC LIMIT $limit
      """
      columnName: "aggregateStageAttendanceRecords"
    )
}
 type Campaign {
  name: String!
  type: String!
}

extend type Oversight {
  campaigns: [String!]!
}

extend type Campus {
  campaigns: [String!]!
}

extend type Stream {
  campaigns: [String!]!
}

extend type Council {
  campaigns: [String!]!
}

extend type Governorship {
  campaigns: [String!]!
}

extend type Bacenta {
  campaigns: [String!]!
}

extend type Fellowship {
  campaigns: [String!]!
}
 extend type ServiceRecord {
  church_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_SERVICE]-(:ServiceLog:HistoryLog)<-[:HAS_HISTORY]-(church)
      WHERE church:Fellowship OR church:Bacenta OR church:Governorship OR church:Council OR church:Stream OR church:Campus
      RETURN church.name
      """
      columnName: "church_name"
    )
}

type Stats {
  attendance: Float
  income: Float
}

type MemberConversion {
  howYouJoined: String
  percentage: Float!
  number: Int!
}

extend type Fellowship {
  avgWeekdayStats(days: Int!): Stats!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(record:ServiceRecord)
      MATCH (record) WHERE NOT (record:NoService)
      MATCH (record)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      MATCH (date)
      WHERE date.date > date() - duration({days: $days})
      RETURN {
        attendance: toInteger(round(avg(record.attendance))),
        income: round(avg(record.income), 2)
        }
      """
      columnName: "avgWeekdayStats"
    )

  peakFellowshipAttendance(days: Int!): ServiceRecord
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(record:ServiceRecord)
      MATCH (record)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH date, record, this
            MATCH (date)
            WHERE date.date > date() - duration({days: $days})
      WITH  max(record.attendance) as max, this
      MATCH (fellowship)-[:HAS_HISTORY]->(s:ServiceLog)-[:HAS_SERVICE]->(record:ServiceRecord)
      WHERE record.attendance = max
      RETURN  record LIMIT 1
      """
      columnName: "record"
    )

  peakFellowshipIncome(days: Int!): ServiceRecord
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(record:ServiceRecord)
      MATCH (record)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH date, record, this
            MATCH (date)
            WHERE date.date > date() - duration({days: $days})
      WITH  max(record.income) as max, this
      MATCH (fellowship)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(record:ServiceRecord)
      WHERE record.income = max
      RETURN record LIMIT 1
      """
      columnName: "record"
    )
  aggregateMemberConversion: [MemberConversion!]!
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)
      WITH this,COUNT(DISTINCT members) AS total

      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)

      WITH total, members.howYouJoined as howYouJoined, COUNT(DISTINCT members) AS numberOfMembers
      WITH total, howYouJoined, ROUND(100.0*numberOfMembers/total,2)  AS conversion_percent, numberOfMembers
      WITH COLLECT({howYouJoined:howYouJoined, percentage:conversion_percent, number: numberOfMembers}) AS data
      UNWIND data as row
      RETURN DISTINCT row
      """
      columnName: "row"
    )
}

extend type Bacenta {
  peakFellowshipAttendance(days: Int!): ServiceRecord!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(fellowship) WHERE fellowship:Fellowship OR fellowship:ClosedFellowship
      MATCH (fellowship)-[:HAS_HISTORY]-(:ServiceLog)-[:HAS_SERVICE]->(record:ServiceRecord)
      MATCH (record)-[:SERVICE_HELD_ON]->(date:TimeGraph)
            MATCH (date)
            WHERE date.date > date() - duration({days: $days})
      WITH  max(record.attendance) as max, record
      MATCH (record)
      WHERE record.attendance = max
      RETURN record ORDER BY record.attendance DESC LIMIT 1
      """
      columnName: "record"
    )

  peakFellowshipIncome(days: Int!): ServiceRecord!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(fellowship) WHERE fellowship:Fellowship OR fellowship:ClosedFellowship
      MATCH (fellowship)-[:HAS_HISTORY]-(:ServiceLog)-[:HAS_SERVICE]->(record:ServiceRecord)
      MATCH (record)-[:SERVICE_HELD_ON]->(date:TimeGraph)
            MATCH (date)
            WHERE date.date > date() - duration({days: $days})
      WITH  max(record.income) as max, record
      MATCH (record)
      WHERE record.income = max
      RETURN  record ORDER BY record.income DESC LIMIT 1
      """
      columnName: "record"
    )

  avgWeekdayStats(days: Int!): Stats!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      MATCH (agg)
      WHERE agg.week IN weeks
      WITH sum(agg.attendance) AS attendance, sum(agg.income) as income, this, agg.week as weeknumber
      RETURN  {
        attendance: round(avg(attendance)),
        income: round(avg(income), 2)
        }
      """
      columnName: "avgWeekdayStats"
    )

  avgBussingAttendance(days: Int!): Float
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]-(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)
      MATCH (bussing) WHERE bussing.attendance IS NOT NULL
      MATCH (bussing)-[:BUSSED_ON]->(date:TimeGraph)
      MATCH (date)
       WHERE date.date > date() - duration({days: $days})
      WITH sum(bussing.attendance) AS sum, this, date(date.date).week as weeknumber
      RETURN round(avg(sum)) AS average
      """
      columnName: "average"
    )

  aggregateMemberConversion: [MemberConversion!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(members:Active:Member)
      WITH this,COUNT(DISTINCT members) AS total

      MATCH (this)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(members:Active:Member)

      WITH total, members.howYouJoined as howYouJoined, COUNT(DISTINCT members) AS numberOfMembers
      WITH total, howYouJoined, ROUND(100.0*numberOfMembers/total,2)  AS conversion_percent, numberOfMembers
      WITH COLLECT({howYouJoined:howYouJoined, percentage:conversion_percent, number: numberOfMembers}) AS data
      UNWIND data as row
      RETURN DISTINCT row
      """
      columnName: "row"
    )
}

extend type Governorship {
  avgWeekdayStats(days: Int!): Stats!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, sum(agg.income) as income, this, agg.week as weeknumber
      RETURN  {
        attendance: round(avg(attendance)),
        income: round(avg(income), 2)
        }
      """
      columnName: "avgWeekdayStats"
    )

  avgBacentaBussingAttendance(days: Int!): Float
    @cypher(
      statement: """
       MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS]->(bacenta:Bacenta)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH  agg.attendance as attendance, bacenta, agg.week as weeknumber
       RETURN round(avg(attendance)) AS average
      """
      columnName: "average"
    )

  avgBussingAttendance(days: Int): Float
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, this, agg.week as weeknumber
       RETURN round(avg(attendance)) AS average
      """
      columnName: "average"
    )
  aggregateMemberConversion: [MemberConversion!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      WITH this,COUNT(DISTINCT members) AS total

      MATCH (this)-[:HAS*]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)

      WITH total, members.howYouJoined as howYouJoined, COUNT(DISTINCT members) AS numberOfMembers
      WITH total, howYouJoined, ROUND(100.0*numberOfMembers/total,2)  AS conversion_percent, numberOfMembers
      WITH COLLECT({howYouJoined:howYouJoined, percentage:conversion_percent, number: numberOfMembers}) AS data
      UNWIND data as row
      RETURN DISTINCT row
      """
      columnName: "row"
    )
}

extend type Council {
  avgFellowshipWeekdayStats(days: Int!): Stats!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Governorship)-[:HAS]->(:Bacenta)-[:HAS]->(fellowship)
          WHERE fellowship:Fellowship OR fellowship:ClosedFellowship
      MATCH (fellowship)-[:HAS_HISTORY]-(:ServiceLog)-[:HAS_SERVICE]->(record:ServiceRecord)
      MATCH (record) WHERE NOT (record:NoService)
      MATCH (record)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      MATCH (date)
      WHERE date.date > date() - duration({days: $days})
      WITH sum(record.attendance) AS attendance, sum(record.income) as income, fellowship, date(date.date).week as weeknumber
      RETURN {
        attendance: toInteger(round(avg(attendance))),
        income: round(avg(income), 2)
        }
      """
      columnName: "avgFellowshipWeekdayStats"
    )

  avgBacentaWeekdayStats(days: Int!): Stats!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS]->(:Governorship)-[:HAS]->(bacenta:Bacenta)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, sum(agg.income) as income, bacenta, agg.week as weeknumber
      RETURN  {
        attendance: round(avg(attendance)),
        income: round(avg(income), 2)
        }
      """
      columnName: "avgBacentaWeekdayStats"
    )

  avgGovernorshipWeekdayStats(days: Int!): Stats!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS]->(governorship:Governorship)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, sum(agg.income) as income, governorship, agg.week as weeknumber
      RETURN  {
        attendance: round(avg(attendance)),
        income: round(avg(income), 2)
        }
      """
      columnName: "avgGovernorshipWeekdayStats"
    )

  avgWeekdayStats(days: Int!): Stats!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, sum(agg.income) as income, this, agg.week as weeknumber
      RETURN  {
        attendance: round(avg(attendance)),
        income: round(avg(income), 2)
        }
      """
      columnName: "avgWeekdayStats"
    )

  avgBacentaBussingAttendance(days: Int!): Float
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS]->(:Governorship)-[:HAS]->(bacenta:Bacenta)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, bacenta, agg.week as weeknumber
      RETURN round(avg(attendance)) AS average
      """
      columnName: "average"
    )

  avgGovernorshipBussingAttendance(days: Int!): Float
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS]->(governorship:Governorship)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, governorship, agg.week as weeknumber
      RETURN round(avg(attendance)) AS average
      """
      columnName: "average"
    )

  avgBussingAttendance(days: Int!): Float
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, this, agg.week as weeknumber
      RETURN round(avg(attendance)) AS average
      """
      columnName: "average"
    )

  aggregateMemberConversion: [MemberConversion!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      WITH this,COUNT(DISTINCT members) AS total

      MATCH (this)-[:HAS*2]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)

      WITH total, members.howYouJoined as howYouJoined, COUNT(DISTINCT members) AS numberOfMembers
      WITH total, howYouJoined, ROUND(100.0*numberOfMembers/total,2)  AS conversion_percent, numberOfMembers
      WITH COLLECT({howYouJoined:howYouJoined, percentage:conversion_percent, number: numberOfMembers}) AS data
      UNWIND data as row
      RETURN DISTINCT row
      """
      columnName: "row"
    )
}

extend type Stream {
  avgWeekdayStats(days: Int!): Stats
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, sum(agg.income) as income, this, agg.week as weeknumber
      RETURN  {
        attendance: round(avg(attendance)),
        income: round(avg(income), 2)
        }
      """
      columnName: "avgWeekdayStats"
    )

  avgCouncilWeekdayStats(days: Int!): Stats
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS]->(council:Council)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, sum(agg.income) as income, council, agg.week as weeknumber
      RETURN  {
        attendance: round(avg(attendance)),
        income: round(avg(income), 2)
        }
      """
      columnName: "avgCouncilWeekdayStats"
    )

  avgCouncilBussingAttendance(days: Int!): Float
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

       MATCH (this)-[:HAS]->(council:Council)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, council, agg.week as weeknumber
      RETURN round(avg(attendance)) AS average
      """
      columnName: "average"
    )

  avgBussingAttendance(days: Int!): Float
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, this, agg.week as weeknumber
      RETURN round(avg(attendance)) AS average
      """
      columnName: "average"
    )
  aggregateMemberConversion: [MemberConversion!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      WITH this,COUNT(DISTINCT members) AS total

      MATCH (this)-[:HAS*3]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)

      WITH total, members.howYouJoined as howYouJoined, COUNT(DISTINCT members) AS numberOfMembers
      WITH total, howYouJoined, ROUND(100.0*numberOfMembers/total,2)  AS conversion_percent, numberOfMembers
      WITH COLLECT({howYouJoined:howYouJoined, percentage:conversion_percent, number: numberOfMembers}) AS data
      UNWIND data as row
      RETURN DISTINCT row
      """
      columnName: "row"
    )
}

extend type Campus {
  avgGovernorshipBussingAttendance(days: Int!): Float
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS]->(:Stream)-[:HAS]->(:Council)-[:HAS]->(governorship:Governorship)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, governorship, agg.week as weeknumber
      RETURN round(avg(attendance)) AS average
      """
      columnName: "average"
    )

  avgGovernorshipWeekdayStats(days: Int!): Stats!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS]->(:Stream)-[:HAS]->(:Council)-[:HAS]->(governorship:Governorship)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, sum(agg.income) as income, governorship, agg.week as weeknumber
      RETURN  {
        attendance: round(avg(attendance)),
        income: round(avg(income), 2)
        }
      """
      columnName: "avgGovernorshipWeekdayStats"
    )

  avgCouncilBussingAttendance(days: Int!): Float!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS]->(:Stream)-[:HAS]->(council:Council)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, council, agg.week as weeknumber
      RETURN round(avg(attendance)) AS average
      """
      columnName: "average"
    )

  avgStreamWeekdayStats(days: Int!): Stats!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS]->(stream:Stream)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, sum(agg.income) as income, stream, agg.week as weeknumber
      RETURN  {
        attendance: round(avg(attendance)),
        income: round(avg(income), 2)
        }
      """
      columnName: "avgStreamWeekdayStats"
    )

  avgStreamBussingAttendance(days: Int!): Float
    @cypher(
      statement: """
       MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS]->(stream:Stream)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, stream, agg.week as weeknumber
      RETURN round(avg(attendance)) AS average
      """
      columnName: "average"
    )

  avgBussingAttendance(days: Int!): Float
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, this, agg.week as weeknumber
      RETURN round(avg(attendance)) AS average
      """
      columnName: "average"
    )

  avgWeekdayStats(days: Int!): Stats!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, sum(agg.income) as income, this, agg.week as weeknumber
      RETURN  {
        attendance: round(avg(attendance)),
        income: round(avg(income), 2)
        }
      """
      columnName: "avgWeekdayStats"
    )
  aggregateMemberConversion: [MemberConversion!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      WITH this,COUNT(DISTINCT members) AS total

      MATCH (this)-[:HAS*4]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)

      WITH total, members.howYouJoined as howYouJoined, COUNT(DISTINCT members) AS numberOfMembers
      WITH total, howYouJoined, ROUND(100.0*numberOfMembers/total,2)  AS conversion_percent, numberOfMembers
      WITH COLLECT({howYouJoined:howYouJoined, percentage:conversion_percent, number: numberOfMembers}) AS data
      UNWIND data as row
      RETURN DISTINCT row
      """
      columnName: "row"
    )
}

extend type Oversight {
  avgCampusWeekdayStats(days: Int!): Stats!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS]->(campus:Campus)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, sum(agg.income) as income, campus, agg.week as weeknumber
      RETURN  {
        attendance: round(avg(attendance)),
        income: round(avg(income), 2)
        }
      """
      columnName: "avgCampusWeekdayStats"
    )

  avgCampusBussingAttendance(days: Int!): Float
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH date(today) - duration({days: $days}) AS startDate, this
      WITH  range(date(startDate).week, date().week) as weeks, this

      MATCH (this)-[:HAS]->(campus:Campus)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      MATCH (agg)
      WHERE agg.week IN weeks and agg.year = date().year
      WITH sum(agg.attendance) AS attendance, campus, agg.week as weeknumber
      RETURN round(avg(attendance)) AS average
      """
      columnName: "average"
    )
  aggregateMemberConversion: [MemberConversion!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)
      WITH this,COUNT(DISTINCT members) AS total

      MATCH (this)-[:HAS*5]->(:Bacenta)<-[:BELONGS_TO]-(members:Active:Member)

      WITH total, members.howYouJoined as howYouJoined, COUNT(DISTINCT members) AS numberOfMembers
      WITH total, howYouJoined, ROUND(100.0*numberOfMembers/total,2)  AS conversion_percent, numberOfMembers
      WITH COLLECT({howYouJoined:howYouJoined, percentage:conversion_percent, number: numberOfMembers}) AS data
      UNWIND data as row
      RETURN DISTINCT row
      """
      columnName: "row"
    )
}
 extend type Mutation {
  RecordServiceNoIncome(
    churchId: ID!
    serviceDate: String!
    attendance: Int!
    familyPicture: String!
  ): ServiceRecord!
}

extend type Fellowship {
  noIncomeTracking: Boolean!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*5]-(campus:Campus)
      RETURN campus.noIncomeTracking
      """
      columnName: "noIncomeTracking"
    )
}

extend type HubFellowship {
  noIncomeTracking: Boolean!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*5]-(campus:Campus)
      RETURN campus.noIncomeTracking
      """
      columnName: "noIncomeTracking"
    )
}
 extend type Hub {
  servicesThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(this)

      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )
  servicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  cancelledServicesThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(this)

      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )
  cancelledServicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  formDefaultersThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      OPTIONAL MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)
      WITH DISTINCT record, this

      OPTIONAL MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Active:HubFellowship)-[:MEETS_ON]->(day:ServiceDay)
      WITH collect(DISTINCT fellowships) as services, this
      MATCH (defaulters:Active:HubFellowship)<-[:HAS]-(this)
      WHERE NOT defaulters IN services

      WITH defaulters, this
      MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
       WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek AND  time() > time('20:30'))
      RETURN DISTINCT defaulters
      """
      columnName: "result"
    )
  formDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      OPTIONAL MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)
       WITH DISTINCT record, this

       OPTIONAL MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Active:HubFellowship)-[:MEETS_ON]->(day:ServiceDay)
       WITH collect(DISTINCT fellowships) as services, this
       MATCH (defaulters:Active:HubFellowship)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek AND  time() > time('20:30'))
       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )
  bankingDefaultersThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(this)

      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )
  bankingDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  bankedThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(this)

      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )
  bankedThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
}
extend type HubCouncil {
  activeHubCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(hubs:Active:Hub)
      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )

  servicesThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(this)

      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )
  servicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  cancelledServicesThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(this)

      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )
  cancelledServicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  formDefaultersThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      OPTIONAL MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)
      WITH DISTINCT record, this

      OPTIONAL MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Active:HubFellowship)-[:MEETS_ON]->(day:ServiceDay)
      WITH collect(DISTINCT fellowships) as services, this
      MATCH (defaulters:Active:HubFellowship)<-[:HAS]-(:Hub)<-[:HAS]-(this)
      WHERE NOT defaulters IN services

      WITH defaulters, this
      MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
       WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek AND  time() > time('20:30'))
      RETURN DISTINCT defaulters
      """
      columnName: "result"
    )
  formDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      OPTIONAL MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)
       WITH DISTINCT record, this

       OPTIONAL MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Active:HubFellowship)-[:MEETS_ON]->(day:ServiceDay)
       WITH collect(DISTINCT fellowships) as services, this
       MATCH (defaulters:Active:HubFellowship)<-[:HAS]-(:Hub)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek AND  time() > time('20:30'))
       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )
  bankingDefaultersThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(this)

      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )
  bankingDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  bankedThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(this)

      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )
  bankedThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )

  hubRehearsalsThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(this)

      RETURN DISTINCT hubs
      """
      columnName: "result"
    )
  hubRehearsalsThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )

  hubCancelledRehearsalsThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(this)

      RETURN DISTINCT hubs
      """
      columnName: "result"
    )
  hubCancelledRehearsalsThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )
  hubFormDefaultersThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs:Active:Hub)
       MATCH (hubs)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT hubs) as services, this
       MATCH (defaulters:Active:Hub)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
      RETURN DISTINCT defaulters
      """
      columnName: "result"
    )
  hubFormDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs:Active:Hub)
       MATCH (hubs)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT hubs) as services, this
       MATCH (defaulters:Active:Hub)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )
  hubBankingDefaultersThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(this)

      RETURN DISTINCT hubs
      """
      columnName: "result"
    )
  hubBankingDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )
  hubsBankedThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(this)

      RETURN DISTINCT hubs
      """
      columnName: "result"
    )
  hubsBankedThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )
}

extend type Ministry {
  servicesThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(this)

      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )
  servicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  cancelledServicesThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(this)

      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )
  cancelledServicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  formDefaultersThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      OPTIONAL MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)
      WITH DISTINCT record, this

      OPTIONAL MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Active:HubFellowship)-[:MEETS_ON]->(day:ServiceDay)
      WITH collect(DISTINCT fellowships) as services, this
      MATCH (defaulters:Active:HubFellowship)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(this)
      WHERE NOT defaulters IN services

      WITH defaulters, this
      MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
       WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek AND  time() > time('20:30'))
      RETURN DISTINCT defaulters
      """
      columnName: "result"
    )
  formDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      OPTIONAL MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)
       WITH DISTINCT record, this

       OPTIONAL MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Active:HubFellowship)-[:MEETS_ON]->(day:ServiceDay)
       WITH collect(DISTINCT fellowships) as services, this
       MATCH (defaulters:Active:HubFellowship)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek AND  time() > time('20:30'))
       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )
  bankingDefaultersThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(this)

      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )
  bankingDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  bankedThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(this)

      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )
  bankedThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )

  activeHubCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:HubCouncil)-[:HAS]->(hubs:Active:Hub)
      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )
  hubRehearsalsThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(:HubCouncil)<-[:HAS]-(this)

      RETURN DISTINCT hubs
      """
      columnName: "result"
    )
  hubRehearsalsThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(:HubCouncil)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )

  hubCancelledRehearsalsThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(:HubCouncil)<-[:HAS]-(this)

      RETURN DISTINCT hubs
      """
      columnName: "result"
    )
  hubCancelledRehearsalsThisWeekCount: Int!
    @cypher(
      statement: """
       MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncils:HubCouncil)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )
  hubFormDefaultersThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs:Active:Hub)
       MATCH (hubs)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT hubs) as services, this
       MATCH (defaulters:Active:Hub)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
       RETURN DISTINCT defaulters
      """
      columnName: "result"
    )
  hubFormDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs:Active:Hub)
       MATCH (hubs)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT hubs) as services, this
       MATCH (defaulters:Active:Hub)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )
  hubBankingDefaultersThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(this)

      RETURN DISTINCT hubs
      """
      columnName: "result"
    )
  hubBankingDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )
  hubsBankedThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(this)

      RETURN DISTINCT hubs
      """
      columnName: "result"
    )
  hubsBankedThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )

  hubCouncilRehearsalsThisWeek: [HubCouncil!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubCouncils) WHERE hubCouncils:HubCouncil OR hubCouncils:ClosedHubCouncil

       WITH DISTINCT hubCouncils, this
       MATCH (hubCouncils)<-[:HAS]-(this)

      RETURN DISTINCT hubCouncils
      """
      columnName: "result"
    )
  hubCouncilRehearsalsThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubCouncils) WHERE hubCouncils:HubCouncil OR hubCouncils:ClosedHubCouncil

       WITH DISTINCT hubCouncils, this
       MATCH (hubCouncils)<-[:HAS]-(:Ministry)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT hubCouncils)
      """
      columnName: "result"
    )
}

extend type CreativeArts {
  servicesThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(this)

      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )
  servicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  cancelledServicesThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(this)

      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )
  cancelledServicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  formDefaultersThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      OPTIONAL MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)
      WITH DISTINCT record, this

      OPTIONAL MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Active:HubFellowship)-[:MEETS_ON]->(day:ServiceDay)
      WITH collect(DISTINCT fellowships) as services, this
      MATCH (defaulters:Active:HubFellowship)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(this)
      WHERE NOT defaulters IN services

      WITH defaulters, this
      MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
       WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
      RETURN DISTINCT defaulters
      """
      columnName: "result"
    )
  formDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      OPTIONAL MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)
       WITH DISTINCT record, this

       OPTIONAL MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Active:HubFellowship)-[:MEETS_ON]->(day:ServiceDay)
       WITH collect(DISTINCT fellowships) as services, this
       MATCH (defaulters:Active:HubFellowship)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )
  bankingDefaultersThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(this)

      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )
  bankingDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  bankedThisWeek: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(this)

      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )
  bankedThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:ServiceRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships) WHERE fellowships:HubFellowship OR fellowships:ClosedFellowship

       WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Hub)<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
}

extend type CreativeArts {
  activeHubCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Ministry)-[:HAS]->(:HubCouncil)-[:HAS]->(hubs:Active:Hub)
      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )
  hubRehearsalsThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(this)

      RETURN DISTINCT hubs
      """
      columnName: "result"
    )
  hubRehearsalsThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )

  hubCancelledRehearsalsThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(ministry:Ministry)<-[:HAS]-(this)

      RETURN DISTINCT hubs
      """
      columnName: "result"
    )
  hubCancelledRehearsalsThisWeekCount: Int!
    @cypher(
      statement: """
       MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(ministry:Ministry)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )
  hubFormDefaultersThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs:Active:Hub)
       MATCH (hubs)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT hubs) as services, this
       MATCH (defaulters:Active:Hub)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
      RETURN DISTINCT defaulters
      """
      columnName: "result"
    )
  hubFormDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs:Active:Hub)
       MATCH (hubs)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT hubs) as services, this
       MATCH (defaulters:Active:Hub)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
      RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )
  hubBankingDefaultersThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(ministry:Ministry)<-[:HAS]-(this)

      RETURN DISTINCT hubs
      """
      columnName: "result"
    )
  hubBankingDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(ministry:Ministry)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )
  hubsBankedThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(ministry:Ministry)<-[:HAS]-(this)

      RETURN DISTINCT hubs
      """
      columnName: "result"
    )
  hubsBankedThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(ministry:Ministry)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )

  hubCouncilServicesThisWeek: [HubCouncil!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubCouncils) WHERE hubCouncils:HubCouncil OR hubCouncils:ClosedHubCouncil

       WITH DISTINCT hubCouncils, this
       MATCH (hubCouncils)<-[:HAS]-(:Ministry)<-[:HAS]-(this)

      RETURN DISTINCT hubCouncils
      """
      columnName: "result"
    )
  hubCouncilServicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubCouncils) WHERE hubCouncils:HubCouncil OR hubCouncils:ClosedHubCouncil

       WITH DISTINCT hubCouncils, this
       MATCH (hubCouncils)<-[:HAS]-(:Ministry)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT hubCouncils)
      """
      columnName: "result"
    )
  activeMinistryCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(ministry:Ministry) RETURN COUNT(DISTINCT ministry)
      """
      columnName: "result"
    )
  ministryServicesThisWeek: [Ministry!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries) WHERE ministries:Stream OR ministries:ClosedStream

       WITH DISTINCT ministries, this
       MATCH (ministries)<-[:HAS]-(this)

      RETURN DISTINCT ministries
      """
      columnName: "result"
    )
  ministryServicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries) WHERE ministries:Stream OR ministries:ClosedStream

       WITH DISTINCT ministries, this
       MATCH (ministries)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT ministries)
      """
      columnName: "result"
    )
  ministryCancelledServicesThisWeek: [Ministry!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries) WHERE ministries:Stream OR ministries:ClosedStream

       WITH DISTINCT ministries, this
       MATCH (ministries)<-[:HAS]-(this)


      RETURN DISTINCT ministries
      """
      columnName: "result"
    )
  ministryCancelledServicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries) WHERE ministries:Stream OR ministries:ClosedStream

       WITH DISTINCT ministries, this
       MATCH (ministries)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT ministries)
      """
      columnName: "result"
    )
  ministryFormDefaultersThisWeek: [Ministry!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week

      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries:Active:Ministry)
       MATCH (ministries)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT ministries) as services, this
       MATCH (defaulters:Active:Ministry)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
       RETURN DISTINCT defaulters
      """
      columnName: "result"
    )
  ministryFormDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries:Active:Ministry)
       MATCH (ministries)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT ministries) as services, this
       MATCH (defaulters:Active:Ministry)<-[:HAS]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )
  ministryBankingDefaultersThisWeek: [Ministry!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries) WHERE ministries:Ministry OR ministries:ClosedMinistry

       WITH DISTINCT ministries, this
       MATCH (ministries)<-[:HAS]-(this)

      RETURN DISTINCT ministries
      """
      columnName: "result"
    )
  ministryBankingDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries) WHERE ministries:Ministry OR ministries:ClosedMinistry

       WITH DISTINCT ministries, this
       MATCH (ministries)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT ministries)
      """
      columnName: "result"
    )
  ministriesBankedThisWeek: [Ministry!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries) WHERE ministries:Stream OR ministries:ClosedStream

       WITH DISTINCT ministries, this
       MATCH (ministries)<-[:HAS]-(this)

      RETURN DISTINCT ministries
      """
      columnName: "result"
    )
  ministriesBankedThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries) WHERE ministries:Stream OR ministries:ClosedStream

       WITH DISTINCT ministries, this
       MATCH (ministries)<-[:HAS]-(this)

      RETURN COUNT(DISTINCT ministries)
      """
      columnName: "result"
    )
}

extend type Campus {
  activeHubCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(:CreativeArts)-[:HAS]->(:Ministry)-[:HAS]->(:HubCouncil)-[:HAS]->(hubs:Active:Hub)
      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )

  hubRehearsalsThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN DISTINCT hubs
      """
      columnName: "result"
    )
  hubRehearsalsThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )

  hubCancelledRehearsalsThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(ministry:Ministry)<-[:HAS]-(creativeArts:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN DISTINCT hubs
      """
      columnName: "result"
    )
  hubCancelledRehearsalsThisWeekCount: Int!
    @cypher(
      statement: """
       MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(ministry:Ministry)<-[:HAS]-(creativeArts:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )
  hubFormDefaultersThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs:Active:Hub)
       MATCH (hubs)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT hubs) as services, this
       MATCH (defaulters:Active:Hub)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(ministry:Ministry)<-[:HAS]-(creativeArts:CreativeArts)<-[:HAS_MINISTRY]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
      RETURN DISTINCT defaulters
      """
      columnName: "result"
    )
  hubFormDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs:Active:Hub)
       MATCH (hubs)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT hubs) as services, this
       MATCH (defaulters:Active:Hub)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(ministry:Ministry)<-[:HAS]-(creativeArts:CreativeArts)<-[:HAS_MINISTRY]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )
  hubBankingDefaultersThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(ministry:Ministry)<-[:HAS]-(creativeArts:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN DISTINCT hubs
      """
      columnName: "result"
    )
  hubBankingDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(ministry:Ministry)<-[:HAS]-(creativeArts:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )
  hubsBankedThisWeek: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(ministry:Ministry)<-[:HAS]-(creativeArts:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN DISTINCT hubs
      """
      columnName: "result"
    )
  hubsBankedThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubs) WHERE hubs:Hub OR hubs:ClosedHub

       WITH DISTINCT hubs, this
       MATCH (hubs)<-[:HAS]-(hubCouncil:HubCouncil)<-[:HAS]-(ministry:Ministry)<-[:HAS]-(creativeArts:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "result"
    )

  hubCouncilServicesThisWeek: [HubCouncil!]!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubCouncils) WHERE hubCouncils:HubCouncil OR hubCouncils:ClosedHubCouncil

       WITH DISTINCT hubCouncils, this
       MATCH (hubCouncils)<-[:HAS]-(:Ministry)<-[:HAS]-(:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN DISTINCT hubCouncils
      """
      columnName: "result"
    )
  hubCouncilServicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      WITH date() as today, this
      WITH  today.weekDay as theDay, today, this
      WITH date(today) - duration({days: (theDay - 2)}) AS startDate, this
      WITH [day in range(0, 5) | startDate + duration({days: day})] AS dates, this

      MATCH (date:TimeGraph)
      USING INDEX date:TimeGraph(date)
      WHERE date.date IN dates
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT this, record WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(hubCouncils) WHERE hubCouncils:HubCouncil OR hubCouncils:ClosedHubCouncil

       WITH DISTINCT hubCouncils, this
       MATCH (hubCouncils)<-[:HAS]-(:Ministry)<-[:HAS]-(:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN COUNT(DISTINCT hubCouncils)
      """
      columnName: "result"
    )
  activeMinistryCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(creativeArts:CreativeArts)-[:HAS]->(ministry:Ministry) RETURN COUNT(DISTINCT ministry)
      """
      columnName: "result"
    )
  ministryServicesThisWeek: [Ministry!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries) WHERE ministries:Stream OR ministries:ClosedStream

       WITH DISTINCT ministries, this
       MATCH (ministries)<-[:HAS]-(:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN DISTINCT ministries
      """
      columnName: "result"
    )
  ministryServicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this WHERE record.attendance IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries) WHERE ministries:Stream OR ministries:ClosedStream

       WITH DISTINCT ministries, this
       MATCH (ministries)<-[:HAS]-(:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN COUNT(DISTINCT ministries)
      """
      columnName: "result"
    )
  ministryCancelledServicesThisWeek: [Ministry!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries) WHERE ministries:Stream OR ministries:ClosedStream

       WITH DISTINCT ministries, this
       MATCH (ministries)<-[:HAS]-(:CreativeArts)<-[:HAS_MINISTRY]-(this)


      RETURN DISTINCT ministries
      """
      columnName: "result"
    )
  ministryCancelledServicesThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this WHERE record.noServiceReason IS NOT NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries) WHERE ministries:Stream OR ministries:ClosedStream

       WITH DISTINCT ministries, this
       MATCH (ministries)<-[:HAS]-(:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN COUNT(DISTINCT ministries)
      """
      columnName: "result"
    )
  ministryFormDefaultersThisWeek: [Ministry!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week

      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries:Active:Ministry)
       MATCH (ministries)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT ministries) as services, this
       MATCH (defaulters:Active:Ministry)<-[:HAS]-(:CreativeArts)<-[:HAS_MINISTRY]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
       RETURN DISTINCT defaulters
      """
      columnName: "result"
    )
  ministryFormDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries:Active:Ministry)
       MATCH (ministries)-[:MEETS_ON]->(day:ServiceDay)

       WITH collect(DISTINCT ministries) as services, this
       MATCH (defaulters:Active:Ministry)<-[:HAS]-(:CreativeArts)<-[:HAS_MINISTRY]-(this)
       WHERE NOT defaulters IN services

       WITH defaulters, this
       MATCH (defaulters)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR (day.dayNumber = date().dayOfWeek)
       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )
  ministryBankingDefaultersThisWeek: [Ministry!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries) WHERE ministries:Ministry OR ministries:ClosedMinistry

       WITH DISTINCT ministries, this
       MATCH (ministries)<-[:HAS]-(:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN DISTINCT ministries
      """
      columnName: "result"
    )
  ministryBankingDefaultersThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
          AND record.bankingSlip IS NULL
          AND (record.transactionStatus IS NULL OR record.transactionStatus <> 'success')
          AND record.tellerConfirmationTime IS NULL
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries) WHERE ministries:Ministry OR ministries:ClosedMinistry

       WITH DISTINCT ministries, this
       MATCH (ministries)<-[:HAS]-(:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN COUNT(DISTINCT ministries)
      """
      columnName: "result"
    )
  ministriesBankedThisWeek: [Ministry!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries) WHERE ministries:Stream OR ministries:ClosedStream

       WITH DISTINCT ministries, this
       MATCH (ministries)<-[:HAS]-(:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN DISTINCT ministries
      """
      columnName: "result"
    )
  ministriesBankedThisWeekCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (date:TimeGraph) WHERE date.date.week = date().week
      MATCH (date)<-[:SERVICE_HELD_ON]-(record:RehearsalRecord)

       WITH DISTINCT record, this
        WHERE record.noServiceReason IS NULL
         AND (record.bankingSlip IS NOT NULL OR record.transactionStatus ='success' OR record.tellerConfirmationTime IS NOT NULL)
       MATCH (record)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(ministries) WHERE ministries:Stream OR ministries:ClosedStream

       WITH DISTINCT ministries, this
       MATCH (ministries)<-[:HAS]-(:CreativeArts)<-[:HAS_MINISTRY]-(this)

      RETURN COUNT(DISTINCT ministries)
      """
      columnName: "result"
    )
}
 extend type ServiceLog {
  equpmentRecord: [EquipmentRecord!]!
    @relationship(type: "HAS_EQUIPMENT_RECORD", direction: OUT)
}

interface EquipmentRecord {
  offeringBags: Int
  bluetoothSpeakers: Int
}

type GovernorshipEquipment implements EquipmentRecord {
  id: ID
  pulpits: Int
  offeringBags: Int!
  bluetoothSpeakers: Int!
}

type AggregatedEquipment implements EquipmentRecord {
  pulpits: Int!
  offeringBags: Int!
  bluetoothSpeakers: Int!
}

type BacentaEquipment implements EquipmentRecord {
  offeringBags: Int!
  bluetoothSpeakers: Int!
}

type FellowshipEquipment implements EquipmentRecord {
  id: ID!
  offeringBags: Int!
  bluetoothSpeakers: Int!
  serviceLog: ServiceLog
    @relationship(type: "HAS_EQUIPMENT_RECORD", direction: IN)
  equipmentDate: TimeGraph!
    @relationship(type: "HAS_EQUIPMENT_DATE", direction: OUT)
  createdAt: DateTime!
}

extend type Campus {
  equipmentRecord: AggregatedEquipment!
  equipmentStartDate: Date
  equipmentEndDate: Date
  fellowshipEquipmentFilledCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
      MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record
       MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)
       WITH DISTINCT fellowships, this
      MATCH (fellowships)<-[:HAS]-(:Bacenta)<-[:HAS]-(:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  fellowshipEquipmentFilled: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
      MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record
       MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)
       WITH DISTINCT fellowships, this
      MATCH (fellowships)<-[:HAS]-(:Bacenta)<-[:HAS]-(:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)
      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )

  fellowshipEquipmentNotFilled: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
      OPTIONAL  MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record

       OPTIONAL MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)

       WITH collect(DISTINCT fellowships) as filled, this
       MATCH (defaulters:Fellowship)<-[:HAS]-(bacenta:Bacenta)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)
       WHERE NOT defaulters IN filled

      RETURN DISTINCT defaulters
      """
      columnName: "result"
    )

  fellowshipEquipmentNotFilledCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
      OPTIONAL  MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record

      OPTIONAL  MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)

       WITH collect(DISTINCT fellowships) as filled, this
       MATCH (defaulters:Fellowship)<-[:HAS]-(bacenta:Bacenta)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)
       WHERE NOT defaulters IN filled

      RETURN  COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )

  governorshipEquipmentFilledCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
       MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record
        MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships) WHERE governorships:Governorship
       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)
      RETURN COUNT(DISTINCT governorships)
      """
      columnName: "result"
    )
  governorshipEquipmentFilled: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
       MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record
        MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships:Governorship)
       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)
      RETURN DISTINCT governorships
      """
      columnName: "result"
    )

  governorshipEquipmentNotFilled: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
      OPTIONAL MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record

      OPTIONAL MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships:Governorship)

       WITH collect(DISTINCT governorships) as filled, this
       MATCH (defaulters:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)
       WHERE NOT defaulters IN filled

       RETURN DISTINCT defaulters
      """
      columnName: "result"
    )

  governorshipEquipmentNotFilledCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
      OPTIONAL MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record

      OPTIONAL MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships:Governorship)

       WITH collect(DISTINCT governorships) as filled, this
       MATCH (defaulters:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(:Stream)<-[:HAS]-(this)
       WHERE NOT defaulters IN filled

       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )
}

extend type Stream {
  equipmentRecord: AggregatedEquipment!
  fellowshipEquipmentFilledCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
       MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record
        MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)
       WITH DISTINCT fellowships, this
      MATCH (fellowships)<-[:HAS]-(:Bacenta)<-[:HAS]-(:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(this)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  fellowshipEquipmentFilled: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
      MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record
        MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)
       WITH DISTINCT fellowships, this
      MATCH (fellowships)<-[:HAS]-(:Bacenta)<-[:HAS]-(:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(this)
      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )

  fellowshipEquipmentNotFilled: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
      OPTIONAL  MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record

      OPTIONAL  MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)

       WITH collect(DISTINCT fellowships) as filled, this
       MATCH (defaulters:Fellowship)<-[:HAS]-(bacenta:Bacenta)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(this)
       WHERE NOT defaulters IN filled

      RETURN DISTINCT defaulters
      """
      columnName: "result"
    )

  fellowshipEquipmentNotFilledCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
      OPTIONAL MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record

      OPTIONAL MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)

       WITH collect(DISTINCT fellowships) as filled, this
       MATCH (defaulters:Fellowship)<-[:HAS]-(bacenta:Bacenta)<-[:HAS]-(governorship:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(this)
       WHERE NOT defaulters IN filled

      RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )

  governorshipEquipmentFilledCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
       MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record
        MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships:Governorship)
       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(this)
      RETURN COUNT(DISTINCT governorships)
      """
      columnName: "result"
    )
  governorshipEquipmentFilled: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
       MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record
        MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships:Governorship)
       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(:Council)<-[:HAS]-(this)
      RETURN DISTINCT governorships
      """
      columnName: "result"
    )

  governorshipEquipmentNotFilled: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
      OPTIONAL MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record

       OPTIONAL MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships:Governorship)

       WITH collect(DISTINCT governorships) as filled, this
       MATCH (defaulters:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(this)
       WHERE NOT defaulters IN filled

       RETURN DISTINCT defaulters
      """
      columnName: "result"
    )

  governorshipEquipmentNotFilledCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
      OPTIONAL MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record

       OPTIONAL MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships:Governorship)

       WITH collect(DISTINCT governorships) as filled, this
       MATCH (defaulters:Governorship)<-[:HAS]-(:Council)<-[:HAS]-(this)
       WHERE NOT defaulters IN filled

       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )
}

extend type Council {
  equipmentRecord: AggregatedEquipment!
  fellowshipEquipmentFilledCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
       MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record
      MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)
       WITH DISTINCT fellowships, this
      MATCH (fellowships)<-[:HAS]-(:Bacenta)<-[:HAS]-(:Governorship)<-[:HAS]-(this)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  fellowshipEquipmentFilled: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
       MATCH (n:EquipmentDate)
       WITH max(n.date) as latestEquipmentDate, this
       MATCH (date:EquipmentDate {date:latestEquipmentDate})
        MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
        WITH DISTINCT date, this, record
       MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)
        WITH DISTINCT fellowships, this
       MATCH (fellowships)<-[:HAS]-(:Bacenta)<-[:HAS]-(:Governorship)<-[:HAS]-(this)
       RETURN DISTINCT fellowships
      """
      columnName: "result"
    )

  fellowshipEquipmentNotFilled: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
        MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record

       OPTIONAL MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)

       WITH collect(DISTINCT fellowships) as filled, this
       MATCH (defaulters:Fellowship)<-[:HAS]-(:Bacenta)<-[:HAS]-(:Governorship)<-[:HAS]-(this)
       WHERE NOT defaulters IN filled

      RETURN DISTINCT defaulters
      """
      columnName: "result"
    )

  fellowshipEquipmentNotFilledCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
        MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record

        OPTIONAL MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)

       WITH collect(DISTINCT fellowships) as filled, this
       MATCH (defaulters:Fellowship)<-[:HAS]-(:Bacenta)<-[:HAS]-(:Governorship)<-[:HAS]-(this)
       WHERE NOT defaulters IN filled

      RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )

  governorshipEquipmentFilledCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
       MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record
        MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships:Governorship)
       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(this)
      RETURN COUNT(DISTINCT governorships)
      """
      columnName: "result"
    )
  governorshipEquipmentFilled: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
       MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record
        MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships:Governorship)
       WITH DISTINCT governorships, this
       MATCH (governorships)<-[:HAS]-(this)
      RETURN DISTINCT governorships
      """
      columnName: "result"
    )

  governorshipEquipmentNotFilled: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
       OPTIONAL MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record

        OPTIONAL MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships:Governorship)

       WITH collect(DISTINCT governorships) as filled, this
       MATCH (defaulters:Governorship)<-[:HAS]-(this)
       WHERE NOT defaulters IN filled

       RETURN DISTINCT defaulters
      """
      columnName: "result"
    )

  governorshipEquipmentNotFilledCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
       OPTIONAL MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record

        OPTIONAL MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(governorships:Governorship)

       WITH collect(DISTINCT governorships) as filled, this
       MATCH (defaulters:Governorship)<-[:HAS]-(this)
       WHERE NOT defaulters IN filled

       RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )
}

extend type Governorship {
  equipmentRecord: GovernorshipEquipment!
  fellowshipEquipmentFilledCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
       MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record
        MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)
       WITH DISTINCT fellowships, this
      MATCH (fellowships)<-[:HAS]-(bacentas:Bacenta)<-[:HAS]-(this)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  fellowshipEquipmentFilled: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
       MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this
        MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)
       WITH DISTINCT fellowships, this
      MATCH (fellowships)<-[:HAS]-(bacentas:Bacenta)<-[:HAS]-(this)
      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )

  fellowshipEquipmentNotFilled: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
       MATCH (date:EquipmentDate {date:latestEquipmentDate})
       OPTIONAL MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record

       OPTIONAL MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)

       WITH collect(DISTINCT fellowships) as filled, this
       MATCH (defaulters:Fellowship)<-[:HAS]-(bacentas:Bacenta)<-[:HAS]-(this)
       WHERE NOT defaulters IN filled

      RETURN DISTINCT defaulters
      """
      columnName: "result"
    )

  fellowshipEquipmentNotFilledCount: Int!
    @cypher(
      statement: """
       MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
       MATCH (date:EquipmentDate {date:latestEquipmentDate})
       OPTIONAL MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record

       OPTIONAL MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)

       WITH collect(DISTINCT fellowships) as filled, this
       MATCH (defaulters:Fellowship)<-[:HAS]-(bacentas:Bacenta)<-[:HAS]-(this)
       WHERE NOT defaulters IN filled

      RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )
}

extend type Bacenta {
  equipmentRecord: BacentaEquipment!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (this)-[:HAS]-(:Fellowship)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_EQUIPMENT_RECORD]->(record:EquipmentRecord)
      MATCH (record)-[:HAS_EQUIPMENT_DATE]->(date:TimeGraph {date:date(latestEquipmentDate)})
      WITH DISTINCT record
      RETURN {
        offeringBags: toInteger(sum(record.offeringBags)),
        bluetoothSpeakers: toInteger(sum(record.bluetoothSpeakers))
      } as fellowshipEquipment
      """
      columnName: "result"
    )

  fellowshipEquipmentFilledCount: Int!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
       MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record
        MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)
       WITH DISTINCT fellowships, this
      MATCH (fellowships)<-[:HAS]-(this)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "result"
    )
  fellowshipEquipmentFilled: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
       MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record
        MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)
       WITH DISTINCT fellowships, this
      MATCH (fellowships)<-[:HAS]-(this)
      RETURN DISTINCT fellowships
      """
      columnName: "result"
    )

  fellowshipEquipmentNotFilled: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
        MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record

      OPTIONAL  MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)

       WITH collect(DISTINCT fellowships) as filled, this
       MATCH (defaulters:Fellowship)<-[:HAS]-(this)
       WHERE NOT defaulters IN filled

      RETURN DISTINCT defaulters
      """
      columnName: "result"
    )

  fellowshipEquipmentNotFilledCount: Int!
    @cypher(
      statement: """
       MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (date:EquipmentDate {date:latestEquipmentDate})
        MATCH (date)<-[:HAS_EQUIPMENT_DATE]-(record:EquipmentRecord)
       WITH DISTINCT date, this, record

      OPTIONAL  MATCH (record)<-[:HAS_EQUIPMENT_RECORD]-(:ServiceLog)<-[:HAS_HISTORY]-(fellowships:Fellowship)

       WITH collect(DISTINCT fellowships) as filled, this
       MATCH (defaulters:Fellowship)<-[:HAS]-(this)
       WHERE NOT defaulters IN filled

      RETURN COUNT(DISTINCT defaulters)
      """
      columnName: "result"
    )
}

extend type Fellowship {
  equipmentRecord: FellowshipEquipment
    @cypher(
      statement: """
      MATCH (this)
      MATCH (n:EquipmentDate)
      WITH max(n.date) as latestEquipmentDate, this
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_EQUIPMENT_RECORD]->(record:EquipmentRecord)
      MATCH (record)-[:HAS_EQUIPMENT_DATE]->(date:TimeGraph {date:date(latestEquipmentDate)})
      RETURN record
      """
      columnName: "result"
    )
}

###### CAMPAIGN TYPES #######

extend type Mutation {
  SetEquipmentDeadline(startDate: Date!, endDate: Date!, id: ID!): Campus
  CreateFellowshipEquipmentRecord(
    id: ID!
    offeringBags: Int!
    bluetoothSpeakers: Int!
    date: Date!
  ): Fellowship

  CreateGovernorshipEquipmentRecord(
    id: ID!
    pulpits: Int!
    date: Date!
  ): Governorship
}
 extend type Mutation {
  MakeStreamSheepSeeker(streamId: ID!, sheepseekerId: ID!): Member!
  RemoveStreamSheepSeeker(streamId: ID!, sheepseekerId: ID!): Member!
}

extend type Member {
  isSheepSeekerForStream: [Stream!]!
    @relationship(type: "IS_SHEEP_SEEKER_FOR", direction: OUT)
}

extend type Stream {
  sheepseekers: [Member!]!
    @relationship(type: "IS_SHEEP_SEEKER_FOR", direction: IN)
}
 extend type Mutation {
  RecordMultiplicationEvent(
    churchId: ID!
    preacherId: String!
    crusadeLocation: String!
    attendance: Int!
    income: Float!
    foreignCurrency: String
    souls: Int!
    miracles: Int!
    crusadePictures: [String!]!
    treasurerSelfie: String!
    crusadeDate: Date!
    treasurers: [ID]!
  ): MultiplicationRecord

  SubmitMultiplicationBankingSlip(
    multiplicationRecordId: String!
    bankingSlip: String!
  ): MultiplicationRecord
}

type MultiplicationRecord {
  id: ID!
  crusadeDate: TimeGraph! @relationship(type: "CRUSADE_HELD_ON", direction: OUT)
  preacher: Member! @relationship(type: "PREACHED_AT", direction: IN)
  crusadeLocation: String!
  attendance: Int!
  income: Float!
  foreignCurrency: String
  souls: Int!
  miracles: Int!
  crusadePictures: [String!]!
  treasurers: [Member!]!
  treasurerSelfie: String!
  bankingSlipUploader: Member
    @relationship(type: "UPLOADED_SLIP_FOR", direction: IN)
  bankingProof: Boolean
    @cypher(
      statement: """
      MATCH (this)
      WITH this WHERE this.bankingSlip IS NOT NULL
      OR  this.transactionStatus = 'success'
      OR this.tellerConfirmationTime IS NOT NULL
      RETURN true
      """
      columnName: "result"
    )
  createdAt: Date!
  created_by: Member! @relationship(type: "LOGGED_BY", direction: OUT)
  bankingSlip: String
}

type AggregateMultiplicationRecord {
  id: ID!
  week: Int!
  year: Int!
  attendance: Int!
  income: Float!
  souls: Int!
  miracles: Int!
}

extend type Member {
  preacher: [MultiplicationRecord!]!
    @relationship(type: "PREACHED_AT", direction: OUT)
  multiplicationTreasurers: [MultiplicationRecord!]!
    @relationship(type: "WAS_TREASURER_FOR", direction: OUT)
  multiplicationBankingSlipUploader: [MultiplicationRecord!]!
    @relationship(type: "UPLOADED_SLIP_FOR", direction: OUT)
}

extend type TimeGraph {
  multiplicationRecordDate: [MultiplicationRecord!]!
    @relationship(type: "CRUSADE_HELD_ON", direction: IN)
}

extend type Campus {
  multiplicationRecords(limit: Int): [MultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_RECORD]->(records:MultiplicationRecord)-[:CRUSADE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records, date
      RETURN records ORDER BY date.date DESC LIMIT $limit
      """
      columnName: "multiplicationRecords"
    )
  aggregateMultiplicationRecords(
    limit: Int! = 4
  ): [AggregateMultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      WHERE aggregate.year = date().year
      RETURN aggregate ORDER BY aggregate.year, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateMultiplicationRecords"
    )
  multiplicationStats(
    startDate: String!
    endDate: String!
  ): [MultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (multiplication:MultiplicationDate)
      WHERE date(multiplication.date) >= date($startDate) AND date(multiplication.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(multiplication.date)

      WITH collect(DISTINCT(date(multiplication.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "multiplicationRecords"
    )
  target: Int
    @cypher(
      statement: """
      MATCH (this)-[:CURRENT_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target)
      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
}

extend type Stream {
  multiplicationRecords(limit: Int): [MultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_RECORD]->(records:MultiplicationRecord)-[:CRUSADE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records, date
      RETURN records ORDER BY date.date DESC LIMIT $limit
      """
      columnName: "multiplicationRecords"
    )

  aggregateMultiplicationRecords(
    limit: Int! = 4
  ): [AggregateMultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      WHERE aggregate.year = date().year
      RETURN aggregate ORDER BY aggregate.year, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateMultiplicationRecords"
    )
  multiplicationStats(
    startDate: String!
    endDate: String!
  ): [MultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (multiplication:MultiplicationDate)
      WHERE date(multiplication.date) >= date($startDate) AND date(multiplication.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(multiplication.date)

      WITH collect(DISTINCT(date(multiplication.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "multiplicationRecords"
    )
  target: Int
    @cypher(
      statement: """
      MATCH (this)-[:CURRENT_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target)
      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
}

extend type Council {
  multiplicationRecords(limit: Int): [MultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_RECORD]->(records:MultiplicationRecord)-[:CRUSADE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records, date
      RETURN records ORDER BY date.date DESC LIMIT $limit
      """
      columnName: "multiplicationRecords"
    )

  aggregateMultiplicationRecords(
    limit: Int! = 4
  ): [AggregateMultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      WHERE aggregate.year = date().year
      RETURN aggregate ORDER BY aggregate.year, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateMultiplicationRecords"
    )
  multiplicationStats(
    startDate: String!
    endDate: String!
  ): [MultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (multiplication:MultiplicationDate)
      WHERE date(multiplication.date) >= date($startDate) AND date(multiplication.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(multiplication.date)

      WITH collect(DISTINCT(date(multiplication.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "multiplicationRecords"
    )
  target: Int
    @cypher(
      statement: """
      MATCH (this)-[:CURRENT_HISTORY]->(log:ServiceLog)-[:HAS_TARGET]->(target)
      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
}

extend type Governorship {
  multiplicationRecords(limit: Int): [MultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_RECORD]->(records:MultiplicationRecord)-[:CRUSADE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records, date
      RETURN records ORDER BY date.date DESC LIMIT $limit
      """
      columnName: "multiplicationRecords"
    )

  aggregateMultiplicationRecords(
    limit: Int! = 4
  ): [AggregateMultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      WHERE aggregate.year = date().year
      RETURN aggregate ORDER BY aggregate.year, aggregate.week DESC LIMIT $limit
      """
      columnName: "aggregateMultiplicationRecords"
    )
  multiplicationStats(
    startDate: String!
    endDate: String!
  ): [MultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (multiplication:MultiplicationDate)
      WHERE date(multiplication.date) >= date($startDate) AND date(multiplication.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(multiplication.date)

      WITH collect(DISTINCT(date(multiplication.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "multiplicationRecords"
    )
  target: Int
    @cypher(
      statement: """
      MATCH (this)
      MATCH (this)-[:CURRENT_HISTORY]->(log:ServiceLog)-[:HAS_TARGET]->(target)

      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
}

extend type Oversight {
  target: Int
    @cypher(
      statement: """
      MATCH (this)-[:CURRENT_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target)
      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
  multiplicationRecords(
    startDate: String!
    endDate: String!
  ): [MultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (multiplication:MultiplicationDate)
      WHERE date(multiplication.date) >= date($startDate) AND date(multiplication.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(multiplication.date)

      WITH collect(DISTINCT(date(multiplication.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "multiplicationRecords"
    )
}

extend type Bacenta {
  multiplicationRecords(
    startDate: String!
    endDate: String!
  ): [MultiplicationRecord!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (multiplication:MultiplicationDate)
      WHERE date(multiplication.date) >= date($startDate) AND date(multiplication.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_MULTIPLICATION_AGGREGATE]->(aggregate:AggregateMultiplicationRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(multiplication.date)

      WITH collect(DISTINCT(date(multiplication.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "multiplicationRecords"
    )
  target: Int
    @cypher(
      statement: """
      MATCH (this)-[:CURRENT_HISTORY]->(log:ServiceLog)-[:HAS_TARGET]->(target)
      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
}
 type SwellStats {
  attendance: Int!
  target: Int
  week: Int!
}

extend type Oversight {
  target: Int
    @cypher(
      statement: """
      MATCH (this)-[:CURRENT_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target)
      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
  swellBussingRecords(startDate: String!, endDate: String!): [SwellStats!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (swell:SwellDate)
      WHERE date(swell.date) >= date($startDate) AND date(swell.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(swell.date)

      WITH collect(DISTINCT(date(swell.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "swellBussingRecords"
    )
}

extend type Campus {
  swellBussingRecords(startDate: String!, endDate: String!): [SwellStats!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (swell:SwellDate)
      WHERE date(swell.date) >= date($startDate) AND date(swell.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(swell.date)

      WITH collect(DISTINCT(date(swell.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "swellBussingRecords"
    )
  target: Int
    @cypher(
      statement: """
      MATCH (this)-[:CURRENT_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target)
      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
}

extend type Stream {
  swellBussingRecords(startDate: String!, endDate: String!): [SwellStats!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (swell:SwellDate)
      WHERE date(swell.date) >= date($startDate) AND date(swell.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(swell.date)

      WITH collect(DISTINCT(date(swell.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "swellBussingRecords"
    )
  target: Int
    @cypher(
      statement: """
      MATCH (this)-[:CURRENT_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target)
      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
}

extend type Council {
  swellBussingRecords(startDate: String!, endDate: String!): [SwellStats!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (swell:SwellDate)
      WHERE date(swell.date) >= date($startDate) AND date(swell.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(swell.date)

      WITH collect(DISTINCT(date(swell.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "swellBussingRecords"
    )
  target: Int
    @cypher(
      statement: """
      MATCH (this)-[:CURRENT_HISTORY]->(log:ServiceLog)-[:HAS_TARGET]->(target)
      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
}

extend type Governorship {
  swellBussingRecords(startDate: String!, endDate: String!): [SwellStats!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (swell:SwellDate)
      WHERE date(swell.date) >= date($startDate) AND date(swell.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(swell.date)

      WITH collect(DISTINCT(date(swell.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "swellBussingRecords"
    )
  target: Int
    @cypher(
      statement: """
      MATCH (this)
      MATCH (this)-[:CURRENT_HISTORY]->(log:ServiceLog)-[:HAS_TARGET]->(target)

      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
}

extend type Bacenta {
  swellBussingRecords(startDate: String!, endDate: String!): [SwellStats!]!
    @cypher(
      statement: """
      MATCH (this)
      MATCH (swell:SwellDate)
      WHERE date(swell.date) >= date($startDate) AND date(swell.date) <= date($endDate)
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(aggregate:AggregateBussingRecord)
      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_TARGET]->(target:Target) WHERE target.date = date(swell.date)

      WITH collect(DISTINCT(date(swell.date).week)) as list, aggregate, this, target
      MATCH (aggregate) WHERE aggregate.week IN list
      RETURN {attendance: toFloat(aggregate.attendance),target: target.target, week: aggregate.week} ORDER BY aggregate.week DESC
      """
      columnName: "swellBussingRecords"
    )
  target: Int
    @cypher(
      statement: """
      MATCH (this)-[:CURRENT_HISTORY]->(log:ServiceLog)-[:HAS_TARGET]->(target)
      RETURN target.target ORDER BY target.date DESC LIMIT 1
      """
      columnName: "target"
    )
}

extend type Mutation {
  UploadBacentaTargets(data: String!, swellDate: String!): String!
  ShareTargetsByCouncil(data: String!, swellDate: String!): Boolean!
}
 type IncomeAttendanceBussing {
  income: Float
  attendance: Int
  bussing: Int
  avgWeeklyIncome: Float
}

type IncomeAttendance {
  income: Float
  attendance: Int
  avgWeeklyIncome: Float
}

extend type Oversight {
  statsForYearTillDate(
    startDate: String!
    endDate: String!
  ): IncomeAttendanceBussing!
    @cypher(
      statement: """
       MATCH (this)
      WITH date($endDate) as endDate, this
      WITH (endDate.week -  duration.inDays(date($startDate), endDate).weeks) as startWeek, this, endDate
      WITH  range(startWeek, endDate.week) as weeks, this
      WITH range(date($startDate).year, date($endDate).year) as years, weeks, this

      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      WHERE agg.week IN weeks and agg.year IN years
      WITH avg(agg.attendance) AS attendance, sum(agg.income) as income, avg(agg.income) as avgWeeklyIncome, weeks, this, years

      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      WHERE agg.week IN weeks and agg.year IN years

      WITH avg(agg.attendance) AS bussing, income, attendance, avgWeeklyIncome
      RETURN  {
        attendance: round(attendance),
        income: round(income, 2),
        bussing: round(bussing),
        avgWeeklyIncome: round(avgWeeklyIncome, 2)
        }
      """
      columnName: "result"
    )
}

extend type Campus {
  statsForYearTillDate(
    startDate: String!
    endDate: String!
  ): IncomeAttendanceBussing!
    @cypher(
      statement: """
       MATCH (this)
      WITH date($endDate) as endDate, this
      WITH (endDate.week -  duration.inDays(date($startDate), endDate).weeks) as startWeek, this, endDate
      WITH  range(startWeek, endDate.week) as weeks, this
      WITH range(date($startDate).year, date($endDate).year) as years, weeks, this

      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      WHERE agg.week IN weeks and agg.year IN years
      WITH avg(agg.attendance) AS attendance, sum(agg.income) as income, avg(agg.income) as avgWeeklyIncome, weeks, this, years

      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      WHERE agg.week IN weeks and agg.year IN years

      WITH avg(agg.attendance) AS bussing, income, attendance, avgWeeklyIncome
      RETURN  {
        attendance: round(attendance),
        income: round(income, 2),
        bussing: round(bussing),
        avgWeeklyIncome: round(avgWeeklyIncome, 2)
        }
      """
      columnName: "result"
    )
}

extend type Stream {
  statsForYearTillDate(
    startDate: String!
    endDate: String!
  ): IncomeAttendanceBussing!
    @cypher(
      statement: """
       MATCH (this)
      WITH date($endDate) as endDate, this
      WITH (endDate.week -  duration.inDays(date($startDate), endDate).weeks) as startWeek, this, endDate
      WITH  range(startWeek, endDate.week) as weeks, this
      WITH range(date($startDate).year, date($endDate).year) as years, weeks, this

      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      WHERE agg.week IN weeks and agg.year IN years
      WITH avg(agg.attendance) AS attendance, sum(agg.income) as income, avg(agg.income) as avgWeeklyIncome, weeks, this, years

      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      WHERE agg.week IN weeks and agg.year IN years

      WITH avg(agg.attendance) AS bussing, income, attendance, avgWeeklyIncome
      RETURN  {
        attendance: round(attendance),
        income: round(income, 2),
        bussing: round(bussing),
        avgWeeklyIncome: round(avgWeeklyIncome, 2)
        }
      """
      columnName: "result"
    )
}

extend type Council {
  statsForYearTillDate(
    startDate: String!
    endDate: String!
  ): IncomeAttendanceBussing
    @cypher(
      statement: """
       MATCH (this)
      WITH date($endDate) as endDate, this
      WITH (endDate.week -  duration.inDays(date($startDate), endDate).weeks) as startWeek, this, endDate
      WITH  range(startWeek, endDate.week) as weeks, this
      WITH range(date($startDate).year, date($endDate).year) as years, weeks, this

      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      WHERE agg.week IN weeks and agg.year IN years
      WITH avg(agg.attendance) AS attendance, sum(agg.income) as income, avg(agg.income) as avgWeeklyIncome, weeks, this, years

      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      WHERE agg.week IN weeks and agg.year IN years

      WITH avg(agg.attendance) AS bussing, income, attendance, avgWeeklyIncome
      RETURN  {
        attendance: round(attendance),
        income: round(income, 2),
        bussing: round(bussing),
        avgWeeklyIncome: round(avgWeeklyIncome, 2)
        }
      """
      columnName: "result"
    )
}

extend type Governorship {
  statsForYearTillDate(
    startDate: String!
    endDate: String!
  ): IncomeAttendanceBussing!
    @cypher(
      statement: """
       MATCH (this)
      WITH date($endDate) as endDate, this
      WITH (endDate.week -  duration.inDays(date($startDate), endDate).weeks) as startWeek, this, endDate
      WITH  range(startWeek, endDate.week) as weeks, this
      WITH range(date($startDate).year, date($endDate).year) as years, weeks, this

      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      WHERE agg.week IN weeks and agg.year IN years
      WITH avg(agg.attendance) AS attendance, sum(agg.income) as income, avg(agg.income) as avgWeeklyIncome, weeks, this, years

      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING_AGGREGATE]->(agg:AggregateBussingRecord)
      WHERE agg.week IN weeks and agg.year IN years

      WITH avg(agg.attendance) AS bussing, income, attendance, avgWeeklyIncome
      RETURN  {
        attendance: round(attendance),
        income: round(income, 2),
        bussing: round(bussing),
        avgWeeklyIncome: round(avgWeeklyIncome, 2)
        }
      """
      columnName: "result"
    )
}

extend type Bacenta {
  statsForYearTillDate(
    startDate: String!
    endDate: String!
  ): IncomeAttendanceBussing
    @cypher(
      statement: """
       MATCH (this)
      WITH date($endDate) as endDate, this
      WITH (endDate.week -  duration.inDays(date($startDate), endDate).weeks) as startWeek, this, endDate
      WITH  range(startWeek, endDate.week) as weeks, this
      WITH range(date($startDate).year, date($endDate).year) as years, weeks, this

      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      WHERE agg.week IN weeks and agg.year IN years
      WITH avg(agg.attendance) AS attendance, sum(agg.income) as income, avg(agg.income) as avgWeeklyIncome, weeks, this, years

      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(bussing:BussingRecord)
      WHERE date(bussing.createdAt).week IN weeks AND date(bussing.createdAt).year IN years

      WITH avg(bussing.attendance) AS bussing, income, attendance, avgWeeklyIncome
      RETURN  {
        attendance: round(attendance),
        income: round(income, 2),
        bussing: round(bussing),
        avgWeeklyIncome: round(avgWeeklyIncome, 2)
        }
      """
      columnName: "result"
    )
}

extend type Fellowship {
  statsForYearTillDate(startDate: String!, endDate: String!): IncomeAttendance!
    @cypher(
      statement: """
      MATCH (this)
      WITH date($endDate) as endDate, this
      WITH (endDate.week -  duration.inDays(date($startDate), endDate).weeks) as startWeek, this, endDate
      WITH  range(startWeek, endDate.week) as weeks, this
       WITH range(date($startDate).year, date($endDate).year) as years, weeks, this

      OPTIONAL MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE_AGGREGATE]->(agg:AggregateServiceRecord)
      WHERE agg.week IN weeks and agg.year IN years
      WITH avg(agg.attendance) AS attendance, sum(agg.income) as income, avg(agg.income) as avgWeeklyIncome, weeks, this

      RETURN  {
        attendance: round(attendance),
        income: round(income, 2),
        avgWeeklyIncome: round(avgWeeklyIncome, 2)
        }
      """
      columnName: "result"
    )
}
 extend type Member {
  leadsHubCouncil: [HubCouncil!]! @relationship(type: "LEADS", direction: OUT)
  leadsHub: [Hub!]! @relationship(type: "LEADS", direction: OUT)
  leadsHubFellowship: [HubFellowship!]!
    @relationship(type: "LEADS", direction: OUT)
  leadsHubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(fellowships:HubFellowship:Fellowship)
      RETURN COUNT(fellowships)
      """
      columnName: "leadsHubFellowshipCount"
    )
  leadsHubCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(hubs:Hub)
      RETURN COUNT(hubs)
      """
      columnName: "leadsHubCount"
    )
  leadsMinistryCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(ministries:Ministry)
      RETURN COUNT(ministries)
      """
      columnName: "leadsMinistryCount"
    )
  isAdminForMinistryCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:IS_ADMIN_FOR]->(ministries:Ministry)
      RETURN COUNT (ministries)
      """
      columnName: "isAdminForMinistryCount"
    )
  leadsAdminsMinistryCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|IS_ADMIN_FOR]->(ministries:Ministry)
      RETURN COUNT(ministries)
      """
      columnName: "leadsAdminsMinistryCount"
    )
  leadscreativeArtCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(creativeArts:CreativeArts)
      RETURN COUNT(creativeArts)
      """
      columnName: "leadscreativeArtCount"
    )
  isAdminForcreativeArtCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:IS_ADMIN_FOR]->(creativeArts:CreativeArts)
      RETURN COUNT (creativeArts)
      """
      columnName: "isAdminForcreativeArtCount"
    )
  leadsAdminsCreativeArtsCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|IS_ADMIN_FOR]->(creativeArts:CreativeArts)
      RETURN COUNT(creativeArts)
      """
      columnName: "leadsAdminsCreativeArtsCount"
    )
  isAdminForMinistry: [Ministry!]!
    @relationship(type: "IS_ADMIN_FOR", direction: OUT)

  isAdminForCreativeArts: [CreativeArts!]!
    @relationship(type: "IS_ADMIN_FOR", direction: OUT)
}

type Basonta {
  id: ID @id
  name: String!
  leader: Member @relationship(type: "LEADS", direction: IN)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC LIMIT $limit"
      columnName: "log"
    )
}

type CreativeArts {
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_MINISTRY]-(campus:Campus)-[:HAS]->(:Stream)-[:HAS]->(:Council)-[:HAS]->(:Governorship)-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(members:Active:Member)
      MATCH (members)-[:BELONGS_TO]->(this)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)
      """
      columnName: "members"
    )
  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_MINISTRY]-(campus:Campus)-[:HAS]->(:Stream)-[:HAS]->(:Council)-[:HAS]->(:Governorship)-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(members:Active:Member)
      MATCH (members)-[:BELONGS_TO]->(this)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "memberCount"
    )
  hubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(fellowships:HubFellowship)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "hubFellowshipCount"
    )
  activeHubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(fellowships:HubFellowship:Active)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "activeHubFellowshipCount"
    )
  vacationHubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(fellowships:HubFellowship:Vacation)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "vacationHubFellowshipCount"
    )
  hubCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(hubs:Hub)
      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "hubCount"
    )
  hubCouncilCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(ministries:Ministry)-[:HAS]->(hubCouncils:HubCouncil)
      RETURN COUNT(DISTINCT hubCouncils)
      """
      columnName: "hubCouncilCount"
    )
  ministryCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(ministries:Ministry)
      RETURN COUNT(DISTINCT ministries)
      """
      columnName: "ministryCount"
    )
  id: ID @id
  name: String!
  leader: Member @relationship(type: "LEADS", direction: IN)
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  campus: Campus @relationship(type: "HAS_MINISTRY", direction: IN)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC LIMIT $limit"
      columnName: "log"
    )
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  ministries: [Ministry!]! @relationship(type: "HAS", direction: OUT)
  streams: [Stream!]!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_MINISTRY]-(:Campus)-[:HAS]->(stream:Stream)
      RETURN stream
      """
      columnName: "result"
    )
}

type Ministry {
  bankAccount: String!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_MINISTRY]-(stream:Stream)

      RETURN
        CASE this.bankAccount
          WHEN NULL THEN stream.bankAccount
        ELSE this.bankAccount
        END
      """
      columnName: "bankAccount"
    )
  vacationStatus: String!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_MINISTRY]-(stream:Stream)
      UNWIND labels(stream) AS status
      WITH status WHERE status = 'Active' OR status = 'Vacation' OR status = 'Online'
      RETURN status
      """
      columnName: "vacationStatus"
    )
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS]-(creativeArts:CreativeArts)
      MATCH (this)<-[:HAS_MINISTRY]-(stream:Stream)-[:HAS]->(:Council)-[:HAS]->(:Governorship)-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(members:Active:Member)
      MATCH (members)-[:BELONGS_TO]->(creativeArts)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)
      """
      columnName: "members"
    )
  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS]-(creativeArts:CreativeArts)
      MATCH (this)<-[:HAS_MINISTRY]-(stream:Stream)-[:HAS]->(:Council)-[:HAS]->(:Governorship)-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(members:Active:Member)
      MATCH (members)-[:BELONGS_TO]->(creativeArts)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "memberCount"
    )
  hubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:HubFellowship)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "hubFellowshipCount"
    )
  activeHubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:Active:HubFellowship)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "activeHubFellowshipCount"
    )
  vacationHubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:Vacation:HubFellowship)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "vacationHubFellowshipCount"
    )
  hubCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(hubs:Hub)
      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "hubCount"
    )
  hubCouncilCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(hubs:HubCouncil)
      RETURN COUNT(DISTINCT hubs)
      """
      columnName: "hubCouncilCount"
    )
  id: ID @id
  name: String!
  leader: Member @relationship(type: "LEADS", direction: IN)
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  stream: Stream @relationship(type: "HAS_MINISTRY", direction: IN)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC  LIMIT $limit"
      columnName: "log"
    )
  servicelogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  creativeArts: CreativeArts! @relationship(type: "HAS", direction: IN)
  hubCouncils: [HubCouncil!]! @relationship(type: "HAS", direction: OUT)
  councils: [Council!]!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_MINISTRY]-(stream:Stream)-[:HAS]->(councils:Council)
      RETURN councils
      """
      columnName: "result"
    )
  hubFellowships: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:HubFellowship)
      RETURN fellowship
      """
      columnName: "result"
    )
  onStageAttendanceRecords(
    limit: Int!
    skip: Int = 0
  ): [StageAttendanceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(records:StageAttendanceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records,date
      RETURN records ORDER BY date.date DESC SKIP $skip LIMIT $limit
      """
      columnName: "result"
    )
}

type HubCouncil {
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS]-(:Ministry)<-[:HAS]-(creativeArts:CreativeArts)
      MATCH (this)<-[:HAS_MINISTRY]-(council:Council)-[:HAS]->(:Governorship)-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(members:Active:Member)
      MATCH (members)-[:BELONGS_TO]->(creativeArts)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)
      """
      columnName: "members"
    )
  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS]-(:Ministry)<-[:HAS]-(creativeArts:CreativeArts)
      MATCH (this)<-[:HAS_MINISTRY]-(council:Council)-[:HAS]->(:Governorship)-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(members:Active:Member)
      MATCH (members)-[:BELONGS_TO]->(creativeArts)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "memberCount"
    )
  hubCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(hub:Hub)
      RETURN COUNT(DISTINCT hub)
      """
      columnName: "hubCount"
    )
  hubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Hub)-[:HAS]->(fellowships:HubFellowship)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "hubFellowshipCount"
    )
  activeHubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Hub)-[:HAS]->(fellowships:Active:HubFellowship)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "activeHubFellowshipCount"
    )
  vacationHubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Hub)-[:HAS]->(fellowships:Vacation:HubFellowship)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "vacationHubFellowshipCount"
    )
  id: ID! @id
  name: String!
  leader: Member @relationship(type: "LEADS", direction: IN)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC  LIMIT $limit"
      columnName: "log"
    )
  vacationStatus: String!
    @cypher(
      statement: """
      MATCH (this)
      UNWIND labels(this) AS status
      WITH status WHERE status = 'Active' OR status = 'Vacation' OR status = 'Online'
      RETURN status
      """
      columnName: "result"
    )
  hubs: [Hub!]! @relationship(type: "HAS", direction: OUT)
  ministry: Ministry! @relationship(type: "HAS", direction: IN)
  council: Council! @relationship(type: "HAS_MINISTRY", direction: IN)
  governorships: [Governorship!]!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_MINISTRY]-(council:Council)-[:HAS]->(governorships:Governorship)
      RETURN governorships
      """
      columnName: "result"
    )
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  rehearsals(limit: Int!, skip: Int = 0): [RehearsalRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(records:RehearsalRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records,date
      RETURN records ORDER BY date.date DESC SKIP $skip LIMIT $limit
      """
      columnName: "result"
    )
}

type Hub {
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(creativeArts:CreativeArts)
      MATCH (this)<-[:HAS_MINISTRY]-(governorship:Governorship)-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(members:Active:Member)
      MATCH (members)-[:BELONGS_TO]->(creativeArts)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)
      """
      columnName: "members"
    )
  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS]-(:HubCouncil)<-[:HAS]-(:Ministry)<-[:HAS]-(creativeArts:CreativeArts)
      MATCH (this)<-[:HAS_MINISTRY]-(governorship:Governorship)-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(members:Active:Member)
      MATCH (members)-[:BELONGS_TO]->(creativeArts)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "memberCount"
    )
  hubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(fellowships:Active:HubFellowship)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "hubFellowshipCount"
    )
  activeHubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(fellowships:Active:HubFellowship)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "activeHubFellowshipCount"
    )
  vacationHubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(fellowships:Vacation:HubFellowship)
      RETURN COUNT(DISTINCT fellowships)
      """
      columnName: "vacationHubFellowshipCount"
    )
  id: ID! @id
  name: String!
  location: Point
  leader: Member @relationship(type: "LEADS", direction: IN)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC  LIMIT $limit"
      columnName: "log"
    )
  meetingDay: ServiceDay! @relationship(type: "MEETS_ON", direction: OUT)
  vacationStatus: String!
    @cypher(
      statement: """
      MATCH (this)
      UNWIND labels(this) AS status
      WITH status WHERE status = 'Active' OR status = 'Vacation' OR status = 'Online'
      RETURN status
      """
      columnName: "result"
    )
  hubFellowships: [Fellowship!]! @relationship(type: "HAS", direction: OUT)
  hubCouncil: HubCouncil! @relationship(type: "HAS", direction: IN)
  governorship: Governorship! @relationship(type: "HAS_MINISTRY", direction: IN)
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  rehearsals(limit: Int!, skip: Int = 0): [RehearsalRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(records:RehearsalRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records,date
      RETURN records ORDER BY date.date DESC SKIP $skip LIMIT $limit
      """
      columnName: "result"
    )
}

extend type Campus {
  basontas: [Basonta!]! @relationship(type: "HAS_MINISTRY", direction: OUT)
  creativeArtsCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS_MINISTRY]->(creativeArts:CreativeArts) RETURN COUNT(creativeArts)"
      columnName: "creativeArtsCount"
    )

  ministryCount: Int!
    @cypher(
      statement: "MATCH (this)-[:HAS_MINISTRY]->(creativeArts:CreativeArts)-[:HAS]->(ministry:Ministry) RETURN COUNT(ministry)"
      columnName: "ministryCount"
    )
  hubCount: Int!
    @cypher(
      statement: "MATCH (this)-[:HAS_MINISTRY]->(creativeArts:CreativeArts)-[:HAS*2]->(hubs:Hub) RETURN COUNT(hub)"
      columnName: "hubCount"
    )
  hubFellowshipCount: Int!
    @cypher(
      statement: "MATCH (this)-[:HAS_MINISTRY]->(creativeArts:CreativeArts)-[:HAS*4]->(fellowship:HubFellowship) RETURN COUNT(fellowship)"
      columnName: "hubFellowshipCount"
    )
  hubFellowships: [Fellowship!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(fellowship:HubFellowship) RETURN fellowship"
      columnName: "fellowship"
    )
  hubs: [Hub!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_MINISTRY]->(creativeArts:CreativeArts)-[:HAS*2]->(hub:Hub) RETURN hub"
      columnName: "hub"
    )
}

extend type Stream {
  ministries: [Ministry!]! @relationship(type: "HAS_MINISTRY", direction: OUT)
  ministryCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(ministry:Ministry)
      RETURN COUNT(ministry)
      """
      columnName: "ministryCount"
    )
  hubCouncils: [Hub!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_MINISTRY]->(ministry:Ministry)-[HAS]->(hubCouncils:HubCouncil) RETURN hubCouncils"
      columnName: "hubCouncils"
    )
  hubCouncilCount: Int!
    @cypher(
      statement: "MATCH (this)-[:HAS_MINISTRY]->(ministry:Ministry)-[:HAS]->(hubCouncils:HubCouncil) RETURN COUNT(hubCouncils)"
      columnName: "hubCouncilCount"
    )
  hubs: [Hub!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_MINISTRY]->(ministry:Ministry)-[HAS*2]->(hubs:Hub) RETURN hubs"
      columnName: "hubs"
    )
  hubCount: Int!
    @cypher(
      statement: "MATCH (this)-[:HAS_MINISTRY]->(ministry:Ministry)-[:HAS*2]->(hubs:Hub) RETURN COUNT(hubs)"
      columnName: "hubCount"
    )
  hubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(:Ministry)-[:HAS*2]->(:Hub)-[:HAS]->(hubFellowships:HubFellowship)
      RETURN COUNT(hubFellowships)
      """
      columnName: "hubFellowshipCount"
    )

  hubFellowships: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(:Ministry)-[:HAS*2]->(:Hub)-[:HAS]->(hubFellowships:HubFellowship)
      RETURN hubFellowships
      """
      columnName: "result"
    )
}

extend type Council {
  hubCouncils: [HubCouncil!]!
    @relationship(type: "HAS_MINISTRY", direction: OUT)
  hubCouncilsFromMinistry(ministryId: ID!): [HubCouncil!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(hubs:HubCouncil)<-[:HAS]-(ministry:Ministry {id:$ministryId})
      RETURN hubs
      """
      columnName: "result"
    )
  hubCouncilCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(hubs:HubCouncil)
      RETURN COUNT(hubs)
      """
      columnName: "hubCouncilCount"
    )
  hubCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(:HubCouncil)-[:HAS]->(hubs:Hub)
      RETURN COUNT(hubs)
      """
      columnName: "hubCount"
    )
  hubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(:HubCouncil)-[:HAS*2]->(fellowship:HubFellowship)
      RETURN COUNT(fellowship)
      """
      columnName: "hubFellowshipCount"
    )
}

extend type Governorship {
  hubs: [Hub!]! @relationship(type: "HAS_MINISTRY", direction: OUT)
  hubCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(hubs:Hub)
      RETURN COUNT(hubs)
      """
      columnName: "hubCount"
    )
  hubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(:Hub)-[:HAS]->(fellowship:HubFellowship)
      RETURN COUNT(fellowship)
      """
      columnName: "hubFellowshipCount"
    )
}

extend type Fellowship {
  hub: Hub @relationship(type: "HAS", direction: IN)
  councilHubs: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS]-(:Bacenta)<-[:HAS]-(:Governorship)<-[:HAS]-(council:Council)
      MATCH (council)-[:HAS_MINISTRY]->(hub:Hub)
      RETURN hub
      """
      columnName: "result"
    )
}

type HubFellowship implements Church {
  id: ID @id
  bankingCode: Int
  name: String!
  location: Point
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*4]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
      columnName: "result"
    )
  vacationStatus: String!
    @cypher(
      statement: """
      MATCH (this)
      UNWIND labels(this) AS status
      WITH status WHERE status = 'Active' OR status = 'Vacation' OR status = 'Online'
      RETURN status
      """
      columnName: "result"
    )
  bacenta: Bacenta @relationship(type: "HAS", direction: IN)
  leader: Member @relationship(type: "LEADS", direction: IN)
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)
      """
      columnName: "result"
    )
  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "result"
    )
  ministryMemberCount: Int
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)-[:BELONGS_TO]->(:Ministry)
      RETURN COUNT(DISTINCT members)
      """
      columnName: "result"
    )
  pastorCount: Int
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(pastors:Active:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
      columnName: "result"
    )
  meetingDay: ServiceDay @relationship(type: "MEETS_ON", direction: OUT)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC LIMIT $limit"
      columnName: "log"
    )
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!, skip: Int): [ServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(records:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records,date
      RETURN records ORDER BY date.date DESC LIMIT $limit
      """
      columnName: "result"
    )
  labels: [String]
    @cypher(
      statement: """
      MATCH (this)
      RETURN labels(this)
      """
      columnName: "result"
    )

  council: Council
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*3]-(council:Council)
      RETURN council
      """
      columnName: "result"
    )
  hub: Hub! @relationship(type: "HAS", direction: IN)
}

extend type Mutation {
  CreateCreativeArts(
    name: String!
    leaderId: ID!
    campusId: ID!
  ): CreativeArts!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus"] })
    @cypher(
      statement: """
      CREATE (creativeArt:CreativeArts:Basonta {name:$name})
        SET creativeArt.id = apoc.create.uuid()

      WITH creativeArt
      MATCH (leader:Member:Active {id:$leaderId}) WHERE leader.email IS NOT NULL
      MATCH (campus:Campus {id:$campusId})
      MATCH (currentUser:Active:Member {auth_id:$auth.jwt.sub})

      CREATE (log:HistoryLog:ServiceLog)
        SET log.id = apoc.create.uuid(),
          log.timeStamp = datetime(),
          log.priority=2,
          log.historyRecord = creativeArt.name +' Creative Art Ministry History Begins'

      MERGE (leader)-[:LEADS]->(creativeArt)
      MERGE (campus)-[:HAS_MINISTRY]->(creativeArt)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (creativeArt)-[:HAS_HISTORY]->(log)

      RETURN creativeArt
      """
      columnName: "result"
    )
  CreateMinistry(
    leaderId: ID!
    streamId: ID!
    creativeArtsId: ID!
    bankAccount: String!
  ): Ministry!
    @authentication(
      jwt: {
        roles_INCLUDES: ["adminCampus", "adminStream", "adminCreativeArts"]
      }
    )
    @cypher(
      statement: """
      CREATE (ministry:Ministry)
        SET	ministry.id = apoc.create.uuid(),
          ministry.bankAccount = $bankAccount

      WITH ministry
      MATCH (leader:Active:Member {id: $leaderId}) WHERE leader.email IS NOT NULL
      MATCH (stream:Stream {id: $streamId})
      MATCH (creativeArt:CreativeArts {id: $creativeArtsId})
      MATCH (currentUser:Active:Member {auth_id: $auth.jwt.sub})
        SET ministry.name = stream.name + ' ' +  creativeArt.name

      WITH ministry, stream, leader, creativeArt, currentUser
      CREATE (log:HistoryLog:ServiceLog)
        SET log.id = apoc.create.uuid(),
          log.timeStamp = datetime(),
          log.priority=2,
          log.historyRecord = ministry.name +' Ministry History Begins'

      WITH ministry, stream, leader, creativeArt, currentUser, log
      MERGE (stream)-[:HAS_MINISTRY]->(ministry)
      MERGE (leader)-[:LEADS]->(ministry)
      MERGE (creativeArt)-[:HAS]->(ministry)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (ministry)-[:HAS_HISTORY]->(log)

      RETURN ministry
      """
      columnName: "result"
    )
  CreateHubCouncil(leaderId: ID!, ministryId: ID!, councilId: ID!): HubCouncil!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminCampus"
          "adminStream"
          "adminCreativeArts"
          "adminMinistry"
        ]
      }
    )
    @cypher(
      statement: """
      CREATE (hub:Active:HubCouncil)
        SET hub.id = apoc.create.uuid()

      WITH hub
      CREATE (log:HistoryLog:ServiceLog)
        SET log.id = apoc.create.uuid(),
          log.timeStamp = datetime(),
          log.priority=1

      WITH hub, log
      MATCH (leader:Active:Member {id: $leaderId})  WHERE leader.email IS NOT NULL
      MATCH (currentUser:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (ministry:Ministry {id: $ministryId})<-[:HAS]-(creativeArts:CreativeArts)
      MATCH (council:Council {id: $councilId})
        SET hub.name = council.name + ' ' + creativeArts.name,
          log.historyRecord = hub.name +' Hub Council History Begins'

      WITH hub, leader, ministry, currentUser, log, council
      MERGE (council)-[:HAS_MINISTRY]->(hub)
      MERGE (ministry)-[:HAS]->(hub)
      MERGE (leader)-[:LEADS]->(hub)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (hub)-[:HAS_HISTORY]->(log)

      RETURN hub
      """
      columnName: "result"
    )
  CreateHub(
    name: String!
    leaderId: ID!
    hubCouncilId: ID!
    governorshipId: ID!
    meetingDay: String!
    venueLongitude: Float
    venueLatitude: Float
  ): Hub!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminCouncil"
          "adminCampus"
          "adminStream"
          "adminCreativeArts"
          "adminMinistry"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (council:HubCouncil {id: $hubCouncilId})<-[:HAS]-(:Ministry)<-[:HAS]-(creative:CreativeArts)
      MATCH (governorship:Governorship {id: $governorshipId})
      UNWIND split(creative.name, ' ') AS creativeName
      WITH COLLECT(LEFT(creativeName, 1)) AS firstLetters, governorship.name AS governorshipName
      WITH REDUCE(s = '', letter in firstLetters | s + letter) AS concatenatedString, governorshipName

      CREATE (hub:Active:Hub {name: concatenatedString + ' ' + governorshipName + ' ' + $name})
        SET hub.id = apoc.create.uuid()
        SET hub.location = point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})

      WITH hub
      CREATE (log:HistoryLog:ServiceLog)
        SET log.id = apoc.create.uuid(),
          log.timeStamp = datetime(),
          log.priority=0,
          log.historyRecord = hub.name +' hub history Begins'

      WITH hub, log
      MATCH (leader:Active:Member {id: $leaderId})  WHERE leader.email IS NOT NULL
      MATCH (currentUser:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (council:HubCouncil {id: $hubCouncilId})
      MATCH (governorship:Governorship {id: $governorshipId})
      MATCH (meetingDay:ServiceDay {day: $meetingDay})

      WITH hub, leader, currentUser, log, council, meetingDay, governorship
      MERGE (council)-[:HAS]->(hub)
      MERGE (governorship)-[:HAS_MINISTRY]->(hub)
      MERGE (leader)-[:LEADS]->(hub)
      MERGE (hub)-[:MEETS_ON]->(meetingDay)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (hub)-[:HAS_HISTORY]->(log)

      RETURN hub
      """
      columnName: "result"
    )
}

extend type Mutation {
  UpdateCreativeArtsDetails(creativeArtsId: ID!, name: String!): CreativeArts!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus"] })
    @cypher(
      statement: """
      MATCH (creativeArt:CreativeArts {id: $creativeArtsId})
        SET creativeArt.name = $name

      RETURN creativeArt
      """
      columnName: "result"
    )
  UpdateMinistryDetails(
    ministryId: ID!
    name: String!
    bankAccount: String!
  ): Ministry!
    @authentication(
      jwt: {
        roles_INCLUDES: ["adminCampus", "adminStream", "adminCreativeArts"]
      }
    )
    @cypher(
      statement: """
       MATCH (ministry:Ministry {id:$ministryId})
        SET ministry.name = $name,
        ministry.bankAccount = $bankAccount

      RETURN ministry
      """
      columnName: "result"
    )
  UpdateHubCouncilDetails(hubCouncilId: ID!, name: String!): HubCouncil!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminCampus"
          "adminStream"
          "adminCreativeArts"
          "adminMinistry"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (hub:HubCouncil {id:$hubCouncilId})
        SET hub.name = $name

      RETURN hub
      """
      columnName: "result"
    )
  UpdateHubDetails(
    hubId: ID!
    name: String!
    meetingDay: String
    venueLongitude: Float
    venueLatitude: Float
  ): Hub!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminCampus"
          "adminStream"
          "adminCreativeArts"
          "adminMinistry"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (hub:Hub {id:$hubId})
        SET hub.name = $name,
        hub.location = point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})

      WITH hub
           CALL {
             WITH hub
             WITH hub WHERE $meetingDay IS NOT NULL
             MATCH (meetingDay:ServiceDay {day: $meetingDay})
             OPTIONAL MATCH (hub)-[r:MEETS_ON]->()
             DELETE r
             MERGE (hub)-[:MEETS_ON]->(meetingDay)
            	RETURN count(hub)
            }

      RETURN hub
      """
      columnName: "result"
    )

  #Set Fellowship to be 'HubFellowship'
  SetFellowshipToHubFellowship(fellowshipId: ID!, hubId: ID!): Fellowship!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminCampus"
          "adminStream"
          "adminCouncil"
          "adminCreativeArts"
          "adminMinistry"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (fellowship:Fellowship {id: $fellowshipId})
      MATCH (hub:Hub {id: $hubId})<-[:HAS]-(ministry:HubCouncil)

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = fellowship.name + ' Fellowship was made into a hub fellowship for ' + ministry.name

      WITH log,fellowship, hub
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MERGE (hub)-[:HAS]->(fellowship)
      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (fellowship)-[:HAS_HISTORY]->(log)
      MERGE (hub)-[:HAS_HISTORY]->(log)

      SET fellowship:HubFellowship

      RETURN fellowship
      """
      columnName: "result"
    )

  SetHubFellowshipToRegularFellowship(fellowshipId: ID!): Fellowship!
    @authentication(
      jwt: {
        roles_INCLUDES: [
          "adminCampus"
          "adminStream"
          "adminCouncil"
          "adminCreativeArts"
          "adminMinistry"
        ]
      }
    )
    @cypher(
      statement: """
      MATCH (fellowship:HubFellowship {id: $fellowshipId})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = fellowship.name + ' hub fellowship was made into a regular fellowship '

      WITH log,fellowship

      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (fellowship)<-[r:HAS]-(hub:Hub)
      DELETE r

      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (fellowship)-[:HAS_HISTORY]->(log)
      MERGE (hub)-[:HAS_HISTORY]->(log)

      REMOVE fellowship:HubFellowship

      RETURN fellowship
      """
      columnName: "result"
    )
}

extend type Mutation {
  MakeCreativeArtsLeader(
    leaderId: ID!
    creativeArtsId: ID!
    oldLeaderId: ID
  ): Member!
  RemoveCreativeArtsLeader(
    leaderId: ID!
    creativeArtsId: ID!
    newLeaderId: ID!
  ): Member
  MakeMinistryLeader(leaderId: ID!, ministryId: ID!, oldLeaderId: ID): Member!
  RemoveMinistryLeader(leaderId: ID!, ministryId: ID!, newLeaderId: ID!): Member
  MakeHubCouncilLeader(
    leaderId: ID!
    hubCouncilId: ID!
    oldLeaderId: ID
  ): Member!
  RemoveHubCouncilLeader(
    leaderId: ID!
    hubCouncilId: ID!
    newLeaderId: ID!
  ): Member
  MakeHubLeader(leaderId: ID!, hubId: ID!, oldLeaderId: ID): Member!
  RemoveHubLeader(leaderId: ID!, hubId: ID!, newLeaderId: ID!): Member
  MakeCreativeArtsAdmin(
    adminId: ID!
    creativeArtsId: ID!
    oldAdminId: ID
  ): Member!
  RemoveCreativeArtsAdmin(
    adminId: ID!
    creativeArtsId: ID!
    newAdminId: ID!
  ): Member
  MakeMinistryAdmin(adminId: ID!, ministryId: ID!, oldAdminId: ID): Member!
  RemoveMinistryAdmin(adminId: ID!, ministryId: ID!, newAdminId: ID!): Member
}

type MinistryAttendanceRecord implements Record {
  id: ID!
  createdAt: DateTime!
  created_by: Member @relationship(type: "LOGGED_BY", direction: OUT)
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
      columnName: "week"
    )
  attendance: Int
  familyPicture: String
  serviceLog: ServiceLog! @relationship(type: "HAS_SERVICE", direction: IN)
  noServiceReason: String
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(church)
      WHERE church:HubFellowship
      MATCH (church)<-[:HAS*1..4]-(stream:Stream)
      RETURN stream.name
      """
      columnName: "stream"
    )
}

type StageAttendanceRecord implements Record {
  id: ID!
  createdAt: DateTime!
  created_by: Member! @relationship(type: "HAS_SERVICE", direction: IN)
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
      columnName: "week"
    )
  attendance: Int!
  onStagePictures: [String!]!
  serviceLog: ServiceLog! @relationship(type: "HAS_SERVICE", direction: IN)
  noStagePerformanceReason: String
}

type RehearsalRecord implements Record {
  id: ID!
  createdAt: DateTime!
  created_by: Member! @relationship(type: "HAS_SERVICE", direction: IN)
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
      columnName: "week"
    )
  attendance: Int
  income: Float
  cash: Float
  onlineGiving: Float
  numberOfTithers: Int
  foreignCurrency: String
  familyPicture: String
  treasurerSelfie: String
  bankingSlip: String
  bankingSlipUploader: Member
    @relationship(type: "UPLOADED_SLIP_FOR", direction: IN)
  transactionId: ID #deprecated
  treasurers: [Member!]! @relationship(type: "WAS_TREASURER_FOR", direction: IN)
  serviceLog: ServiceLog! @relationship(type: "HAS_SERVICE", direction: IN)
  noServiceReason: String
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(church)
      WHERE church:Fellowship OR church:Governorship OR church:Council OR church:Stream
      MATCH (church)<-[:HAS*1..4]-(stream:Stream)
      RETURN stream.name
      """
      columnName: "stream"
    )
  bankedBy: Member
    @cypher(
      statement: """
      MATCH (this)
      WHERE NOT  (this:NoService)
      MATCH (this)<-[:CONFIRMED_BANKING_FOR | :UPLOADED_SLIP_FOR | :OFFERING_BANKED_BY]-(member:Member)
      RETURN member
      """
      columnName: "bankedBy"
    )
}

extend type Mutation {
  RecordHubCouncilSundayAttendance(
    churchId: ID!
    serviceDate: String!
    attendance: Int!
    familyPicture: String!
  ): MinistryAttendanceRecord!

  RecordRehearsalMeeting(
    churchId: ID!
    serviceDate: String!
    attendance: Int!
    income: Float!
    foreignCurrency: String
    numberOfTithers: Int
    treasurers: [ID]!
    treasurerSelfie: String!
    familyPicture: String!
  ): RehearsalRecord!

  RecordMinistryOnStageAttendance(
    churchId: ID!
    serviceDate: String!
    attendance: Int!
    onStagePictures: [String!]!
  ): StageAttendanceRecord!

  RecordCancelledOnstagePerformance(
    churchId: ID!
    serviceDate: String!
    noStagePerformanceReason: String!
  ): StageAttendanceRecord!
}

## DELETE OPERATIONS
extend type Mutation {
  CloseDownCreativeArts(
    creativeArtsId: ID!
    leaderId: ID!
    adminId: ID!
  ): Campus!
  CloseDownMinistry(ministryId: ID!, leaderId: ID!, adminId: ID!): CreativeArts!
  CloseDownHubCouncil(hubCouncilId: ID!, leaderId: ID!): Ministry!
  CloseDownHub(hubId: ID!, leaderId: ID!): HubCouncil!
}
 interface MapLocation {
  id: ID!
  name: String!
  location: Point!
}

type Place implements MapLocation {
  id: ID!
  typename: String!
  name: String!
  firstName: String
  lastName: String
  latitude: Float!
  longitude: Float!
  # TODO: We must eventually switch from these to a location property object
  # Currently this code is breaking in neo4j/graphql
  location: Point!
  description: String
  picture: String
}

extend type Member {
  placesSearchByLocation(
    latitude: Float!
    longitude: Float!
    limit: Int = 30
  ): [Place!]!
  placesSearchByName(key: String!, limit: Int = 30): [Place!]!
  memberLoadCouncilUnvisitedMembers: [Place!]!
}

type IndoorVenue implements MapLocation {
  id: ID!
  name: String!
  location: Point!
  capacity: Int!
}

type OutdoorVenue implements MapLocation {
  id: ID!
  name: String!
  location: Point!
  capacity: Int!
}

type Hostel implements MapLocation {
  id: ID!
  name: String!
  location: Point!
  capacity: Int!
  school: String!
  university: String!
    @cypher(statement: "MATCH (this) RETURN this.school", columnName: "school")
}

type HighSchool implements MapLocation {
  id: ID!
  name: String!
  location: Point!
  capacity: Int!
  school: String!
}

extend type Mutation {
  CreateIndoorVenue(
    name: String!
    capacity: Int!
    longitude: Float!
    latitude: Float!
  ): IndoorVenue!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus"] })
    @cypher(
      statement: """
      CREATE (indoorVenue:IndoorVenue:OutreachVenue)
        SET indoorVenue.id = apoc.create.uuid(),
         indoorVenue.name = $name,
         indoorVenue.capacity = $capacity,
         indoorVenue.location = point({latitude: $latitude, longitude:$longitude})

      WITH indoorVenue
      MATCH (currentUser:Active:Member {auth_id: $auth.jwt.sub})

      WITH indoorVenue, currentUser
      CREATE (log:HistoryLog)
        SET log.id = apoc.create.uuid(),
          log.timeStamp = datetime(),
          log.priority=0,
          log.historyRecord = 'New Indoor Venue ' + indoorVenue.name + ' Created'

      WITH indoorVenue, currentUser, log

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)

      RETURN indoorVenue
      """
      columnName: "result"
    )

  CreateOutdoorVenue(
    name: String!
    capacity: Int!
    longitude: Float!
    latitude: Float!
  ): OutdoorVenue!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus"] })
    @cypher(
      statement: """
      CREATE (outdoorVenue:OutdoorVenue:OutreachVenue)
        SET outdoorVenue.id = apoc.create.uuid()
        SET outdoorVenue.name = $name
        SET outdoorVenue.capacity = $capacity
        SET outdoorVenue.location = point({latitude: $latitude, longitude:$longitude})


      WITH outdoorVenue
      MATCH (currentUser:Active:Member {auth_id: $auth.jwt.sub})

      WITH outdoorVenue, currentUser
      CREATE (log:HistoryLog)
        SET log.id = apoc.create.uuid(),
          log.timeStamp = datetime(),
          log.priority=0,
          log.historyRecord = 'New outdoor venue ' + outdoorVenue.name + ' created'

      WITH outdoorVenue, currentUser, log

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)

      RETURN outdoorVenue
      """
      columnName: "result"
    )

  CreateHostel(
    name: String!
    capacity: Int!
    latitude: Float!
    longitude: Float!
    school: String!
  ): Hostel!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus"] })
    @cypher(
      statement: """
      CREATE (hostel:Hostel)
        SET hostel.id = apoc.create.uuid()
        SET hostel.name = $name
        SET hostel.capacity = $capacity
        SET hostel.location = point({latitude: $latitude, longitude:$longitude})
        SET hostel.school = $school

      WITH hostel,
      MATCH (currentUser:Active:Member {auth_id: $auth.jwt.sub})

      WITH hostel, currentUser
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
         SET log.timestamp = datetime()
         SET log.priority = 0
         SET log.historyRecord = 'New hostel venue' + hostel.name + 'added'

      WITH hostel, currentUser, log

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)

      RETURN hostel
      """
      columnName: "result"
    )
  CreateHighSchool(
    name: String!
    capacity: Int!
    latitude: Float!
    longitude: Float!
    school: String!
  ): HighSchool!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus"] })
    @cypher(
      statement: """
      CREATE (highSchool:HighSchool)
        SET highSchool.id = apoc.create.uuid()
        SET highSchool.name = $name
        SET highSchool.capacity = $capacity
        SET highSchool.location = point({latitude: $latitude, longitude:$longitude})
        SET highSchool.school = $school

      WITH highSchool,
      MATCH (currentUser:Active:Member {auth_id: $auth.jwt.sub})

      WITH highSchool, currentUser
      CREATE (log:HistoryLog)
        SET log.id = apoc.create.uuid()
        SET log.timestamp = datetime()
        SET log.priority = 0
        SET log.historyRecord = 'New senior high school venue' + highSchool.name + 'added'

      WITH highSchool, currentUser, log

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)

      RETURN highSchool
      """
      columnName: "result"
    )
}

extend type Mutation {
  UpdateIndoorVenue(
    longitude: Float!
    latitude: Float!
    indoorVenueId: ID!
    capacity: Int!
    name: String!
  ): IndoorVenue!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus"] })
    @cypher(
      statement: """
      MATCH (indoorVenue:IndoorVenue:OutreachVenue {id: $indoorVenueId})
      SET indoorVenue.location = point({latitude:$latitude, longitude:$longitude})
      SET indoorVenue.name = $name
      SET indoorVenue.capacity = $capacity

      RETURN indoorVenue
      """
      columnName: "result"
    )
  UpdateOutdoorVenue(
    longitude: Float!
    latitude: Float!
    outdoorVenueId: ID!
    capacity: Int!
    name: String!
  ): OutdoorVenue!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus"] })
    @cypher(
      statement: """
      MATCH (outdoorVenue:OutdoorVenue:OutreachVenue {id: $outdoorVenueId})
      SET outdoorVenue.location = point({latitude:$latitude, longitude:$longitude})
      SET outdoorVenue.name = $name
      SET outdoorVenue.capacity = $capacity

      RETURN outdoorVenue
      """
      columnName: "result"
    )
  UpdateHostel(
    longitude: Float!
    latitude: Float!
    hostelId: ID!
    name: String!
    capacity: Int!
    university: String!
  ): Hostel!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus"] })
    @cypher(
      statement: """
      MATCH (hostel:Hostel {id: $hostelId})
      SET hostel.location = point({latitude:$latitude, longitude:$longitude}),
          hostel.name = $name,
          hostel.capacity = $capacity,
          hostel.university = $university

      RETURN hostel
      """
      columnName: "result"
    )
  UpdateHighSchool(
    longitude: Float!
    latitude: Float!
    highSchoolId: ID!
    name: String!
    capacity: Int!
  ): HighSchool!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus"] })
    @cypher(
      statement: """
      MATCH (highSchool:HighSchool {id: $highSchoolId})
      SET highSchool.location = point({latitude:$latitude, longitude:$longitude})
          highSchool.name = $name
          highSchool.capacity = $capacity,


      RETURN highSchool
      """
      columnName: "result"
    )
}

extend type Mutation {
  CloseDownIndoorVenue(indoorVenueId: ID!): Boolean!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus"] })
    @cypher(
      statement: """
      MATCH (indoorVenue:IndoorVenue:OutreachVenue {id: $indoorVenueId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})

      WITH indoorVenue, admin
      CREATE (log:HistoryLog)
       SET log.id = apoc.create.uuid()
        SET log.timestamp = datetime()
        SET log.priority = 0
        SET log.historyRecord = 'The indoor venue' + indoorVenue.name + 'has been deleted'

      MERGE (date:Timegraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)

      DETACH DELETE indoorVenue
      RETURN true
      """
      columnName: "result"
    )
  CloseDownOutdoorVenue(outdoorVenueId: ID!): Boolean!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus"] })
    @cypher(
      statement: """
      MATCH (outdoorVenue:OutdoorVenue:OutreachVenue {id: $outdoorVenueId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})

      CREATE (log:HistoryLog)
        SET log.id = apoc.create.uuid()
            log.timestamp = datetime()
            log.priority = 0
            log.historyRecord = 'The outdoor venue' + outdoorVenue.name + 'has been deleted'

      MERGE (date:Timegraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)

      DETACH DELETE outdoorVenue
      RETURN true
      """
      columnName: "result"
    )

  CloseDownHostel(hostelId: ID!): Boolean!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus"] })
    @cypher(
      statement: """
      MATCH (hostel:Hostel {id: $hostelId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})

      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.timestamp = datetime()
            log.priority = 0
            log.historyRecord = 'The hostel venue' + hostel.name + 'has been deleted'


      MERGE (date:Timegraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)

      DETACH DELETE hostel
      RETURN true
      """
      columnName: "result"
    )
  CloseDownHighSchool(highSchoolId: ID!): Boolean!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus"] })
    @cypher(
      statement: """
      MATCH (highSchool:HighSchool {id: $highSchoolId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})

      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.timestamp = datetime()
            log.priority = 0
            log.historyRecord = 'The high school venue' + highSchool.name + 'has been deleted'


      MERGE (date:Timegraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)

      DETACH DELETE highSchool
      RETURN true
      """
      columnName: "result"
    )
}
 type AccountTransaction {
  id: ID!
  createdAt: DateTime!
  lastModified: DateTime!
  description: String!
  account: String!
  amount: Float!
  charge: Float
  category: String!
  status: String!

  momoNumber: String
  momoName: String
  invoiceUrl: String

  council: Council! @relationship(type: "HAS_TRANSACTION", direction: IN)
  loggedBy: Member! @relationship(type: "LOGGED_BY", direction: OUT)

  bussingSocietyBalance: Float!
  weekdayBalance: Float!
}

extend type Oversight {
  hrAmount: Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(council:Council)
      RETURN SUM(council.hrAmount)
      """
      columnName: "hrAmount"
    )
  bussingAmount: Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(council:Council)
      RETURN SUM(council.bussingAmount)
      """
      columnName: "bussingAmount"
    )
  weekdayBalance: Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(council:Council)
      RETURN SUM(council.weekdayBalance)
      """
      columnName: "weekdayBalance"
    )
  bussingSocietyBalance: Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(council:Council)
      RETURN SUM(council.bussingSocietyBalance)
      """
      columnName: "bussingSocietyBalance"
    )
}

extend type Campus {
  hrAmount: Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(council:Council)
      RETURN SUM(council.hrAmount)
      """
      columnName: "hrAmount"
    )
  bussingAmount: Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(council:Council)
      RETURN SUM(council.bussingAmount)
      """
      columnName: "bussingAmount"
    )
  weekdayBalance: Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(council:Council)
      RETURN SUM(council.weekdayBalance)
      """
      columnName: "weekdayBalance"
    )
  bussingSocietyBalance: Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(council:Council)
      RETURN SUM(council.bussingSocietyBalance)
      """
      columnName: "bussingSocietyBalance"
    )
  transactions: [AccountTransaction!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(council:Council)
      MATCH (council)-[:HAS_TRANSACTION]->(transaction:AccountTransaction)

      RETURN transaction ORDER BY transaction.lastModified DESC
      """
      columnName: "transactions"
    )
}

extend type Stream {
  hrAmount: Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(council:Council)
      RETURN SUM(council.hrAmount)
      """
      columnName: "hrAmount"
    )
  bussingAmount: Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(council:Council)
      RETURN SUM(council.bussingAmount)
      """
      columnName: "bussingAmount"
    )
  weekdayBalance: Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(council:Council)
      RETURN SUM(council.weekdayBalance)
      """
      columnName: "weekdayBalance"
    )
  bussingSocietyBalance: Float!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(council:Council)
      RETURN SUM(council.bussingSocietyBalance)
      """
      columnName: "bussingSocietyBalance"
    )
  transactions: [AccountTransaction!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(council:Council)
      MATCH (council)-[:HAS_TRANSACTION]->(transaction:AccountTransaction)

      RETURN transaction ORDER BY transaction.lastModified DESC
      """
      columnName: "transactions"
    )
}

extend type Council {
  hrAmount: Float
  bussingAmount: Float
  weekdayBalance: Float!
  bussingSocietyBalance: Float
  transactions: [AccountTransaction!]!
    @relationship(type: "HAS_TRANSACTION", direction: OUT)
}

extend type Mutation {
  SetCouncilHRAmount(councilId: ID!, amount: Float!): Council!
    @authentication(jwt: { roles_INCLUDES: "adminCampus" })
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})
        SET council.hrAmount = $amount
      RETURN council
      """
      columnName: "council"
    )
  DepositIntoCouncilCurrentAccount(
    councilId: ID!
    weekdayBalanceDepositAmount: Float!
  ): AccountTransaction!

  DepositIntoCouncilBussingSociety(
    councilId: ID!
    bussingSocietyBalance: Float!
  ): AccountTransaction!

  ExpenseRequest(
    councilId: ID!
    expenseAmount: Float!
    expenseCategory: String!
    accountType: String!
    description: String! #momoNumber: String! #momoName: String! #invoiceUrl: String!
  ): AccountTransaction!
    @authentication(jwt: { roles_INCLUDES: ["leaderCouncil", "adminCampus"] })
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})
      MATCH (requester:Member {auth_id: $auth.jwt.sub})

      WITH council, requester

      CREATE (transaction:AccountTransaction {id: randomUUID()})
        SET transaction.description = $description,
        transaction.amount = $expenseAmount *  -1,
        transaction.account = $accountType,
        transaction.category = $expenseCategory,
        transaction.status = 'pending approval',
        transaction.createdAt = datetime(),
        transaction.lastModified = datetime(),
        transaction.bussingSocietyBalance = council.bussingSocietyBalance,
        transaction.weekdayBalance = council.weekdayBalance
        // transaction.momoNumber = $momoNumber,
        // transaction.momoName = $momoName,
        // transaction.invoiceUrl = $invoiceUrl

      MERGE (council)-[:HAS_TRANSACTION]->(transaction)
      MERGE (requester)<-[:LOGGED_BY]-(transaction)

      RETURN transaction
      """
      columnName: "transaction"
    )

  ApproveExpense(transactionId: ID!, charge: Float!): AccountTransaction!

  DeclineExpense(transactionId: ID!): AccountTransaction!
    @authentication(jwt: { roles_INCLUDES: ["adminCampus", "leaderCampus"] })
    @cypher(
      statement: """
      MATCH (transaction:AccountTransaction {id: $transactionId})
        SET transaction.status = 'declined'

      RETURN transaction
      """
      columnName: "transaction"
    )
  UndoBussingTransaction(transactionId: ID!): Council!
    @cypher(
      statement: """
      MATCH (transaction:AccountTransaction {id: $transactionId})<-[:HAS_TRANSACTION]-(council:Council)

        SET council.bussingSocietyBalance = council.bussingSocietyBalance - transaction.amount
      DETACH DELETE transaction

      RETURN council
      """
      columnName: "council"
    )
  UndoWeekdayTransaction(transactionId: ID!): Council!
    @cypher(
      statement: """
      MATCH (transaction:AccountTransaction {id: $transactionId})<-[:HAS_TRANSACTION]-(council:Council)

        SET council.weekdayBalance = council.weekdayBalance - transaction.amount
      DETACH DELETE transaction

      RETURN council
      """
      columnName: "council"
    )

  DebitBussingSociety(
    councilId: ID!
    expenseAmount: Float!
    expenseCategory: String!
  ): AccountTransaction!
}
 extend type Council {
  downloadCredits: Int
  downloadMembership: [Member!]!
  creditsTransactionHistory: [CreditTransaction!]!
    @relationship(type: "PURCHASED_CREDITS", direction: OUT)
}

extend type Mutation {
  PurchaseDownloadCredits(
    churchId: ID!
    amount: Float!
    mobileNetwork: String!
    mobileNumber: String!
  ): CreditTransaction!

  RemoveDownloadCredit(churchId: ID!): Int!
    @cypher(
      statement: """
      MATCH (church {id: $churchId})
      WHERE church:Bacenta OR church:Governorship OR church:Council OR church:Stream OR church:Campus
      AND church.downloadCredits > 0

      SET church.downloadCredits = church.downloadCredits - 1

      RETURN church.downloadCredits
      """
      columnName: "downloadCredits"
    )

  ConfirmCreditTransaction(transactionReference: String!): CreditTransaction!
}

type CreditTransaction {
  id: ID!
  amount: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
  mobileNetwork: String!
  mobileNumber: String!
  transactionReference: String!
  transactionStatus: String!
  credited: Boolean!
  council: Council! @relationship(type: "PURCHASED_CREDITS", direction: IN)
}
