extend type Member {
  leadscreativeArt: [CreativeArts!]!
    @relationship(type: "LEADS", direction: OUT)
  leadsHub: [Hub!]! @relationship(type: "LEADS", direction: OUT)
  leadsHubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(fellowships:HubFellowship:Fellowship)
      RETURN COUNT(fellowships)
      """
    )
  leadsHubCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(hubs:Hub)
      RETURN COUNT(hubs)
      """
    )
  leadsMinistryCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(ministries:Ministry)
      RETURN COUNT(ministries)
      """
    )
  isAdminForMinistryCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:IS_ADMIN_FOR]->(ministries:Ministry)
      RETURN COUNT (ministries)
      """
    )
  leadsAdminsMinistryCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|IS_ADMIN_FOR]->(ministries:Ministry)
      RETURN COUNT(ministries)
      """
    )
  leadscreativeArtCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(creativeArts:CreativeArts)
      RETURN COUNT(creativeArts)
      """
    )
  isAdminForcreativeArtCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:IS_ADMIN_FOR]->(creativeArts:CreativeArts)
      RETURN COUNT (creativeArts)
      """
    )
  leadsAdminsCreativeArtsCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|IS_ADMIN_FOR]->(creativeArts:CreativeArts)
      RETURN COUNT(creativeArts)
      """
    )
  isAdminForMinistry: [Ministry!]!
    @relationship(type: "IS_ADMIN_FOR", direction: OUT)

  isAdminForCreativeArts: [CreativeArts!]!
    @relationship(type: "IS_ADMIN_FOR", direction: OUT)
}

type HubFellowship implements Church {
  id: ID @id
  bankingCode: Int
  name: String!
  location: Point
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*4]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  vacationStatus: String!
    @cypher(
      statement: """
      MATCH (this)
      UNWIND labels(this) AS status
      WITH status WHERE status = 'Active' OR status = 'Vacation' OR status = 'Online'
      RETURN status
      """
    )
  bacenta: Bacenta @relationship(type: "HAS", direction: IN)
  leader: Member @relationship(type: "LEADS", direction: IN)
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)
      """
    )
  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  ministryMemberCount: Int
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)-[:BELONGS_TO]->(:Ministry)
      RETURN COUNT(DISTINCT members)
      """
    )
  pastorCount: Int
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(pastors:Active:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
    )
  meetingDay: ServiceDay @relationship(type: "MEETS_ON", direction: OUT)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC LIMIT $limit"
    )
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!): [ServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(records:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records,date
      RETURN records ORDER BY date.date DESC LIMIT $limit
      """
    )
  labels: [String]
    @cypher(
      statement: """
      MATCH (this)
      RETURN labels(this)
      """
    )

  council: Council
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*3]-(council:Council)
      RETURN council
      """
    )
  hub: [Hub!]! @relationship(type: "HAS", direction: IN)
}

extend type Mutation {
  CreateCreativeArts(name: String!, leaderId: ID!, campusId: ID!): CreativeArts
    @auth(rules: [{ roles: ["adminCampus"] }])
    @cypher(
      statement: """
      CREATE (creativeArt:CreativeArts {name:$name})
        SET creativeArt.id = apoc.create.uuid()

      WITH creativeArt
      MATCH (leader:Member:Active {id:$leaderId}) WHERE leader.email IS NOT NULL
      MATCH (campus:Campus {id:$campusId})
      MATCH (currentUser:Active:Member {auth_id:$auth.jwt.sub})

      CREATE (log:HistoryLog:ServiceLog)
        SET log.id = apoc.create.uuid(),
          log.timeStamp = datetime(),
          log.priority=0,
          log.historyRecord = creativeArt.name +' Creative Art Ministry History Begins'

      MERGE (leader)-[:LEADS]->(creativeArt)
      MERGE (campus)-[:HAS_MINISTRY]->(creativeArt)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (creativeArt)-[:HAS_HISTORY]->(log)

      RETURN creativeArt
      """
    )
  CreateMinistry(leaderId: ID!, streamId: ID!, creativeArtsId: ID!): Ministry
    @auth(
      rules: [{ roles: ["adminCampus", "adminStream", "adminCreativeArts"] }]
    )
    @cypher(
      statement: """
      CREATE (ministry:Ministry)
        SET	ministry.id = apoc.create.uuid()

      WITH ministry
      MATCH (leader:Active:Member {id: $leaderId}) WHERE leader.email IS NOT NULL
      MATCH (stream:Stream {id: $streamId})
      MATCH (creativeArt:CreativeArts {id: $creativeArtsId})
      MATCH (currentUser:Active:Member {auth_id: $auth.jwt.sub})
        SET ministry.name = stream.name + ' ' +  creativeArt.name

      WITH ministry, stream, leader, creativeArt, currentUser
      CREATE (log:HistoryLog:ServiceLog)
        SET log.id = apoc.create.uuid(),
          log.timeStamp = datetime(),
          log.priority=0,
          log.historyRecord = ministry.name +' Ministry History Begins'

      WITH ministry, stream, leader, creativeArt, currentUser, log
      MERGE (stream)-[:HAS]->(ministry)
      MERGE (leader)-[:LEADS]->(ministry)
      MERGE (creativeArt)-[:HAS]->(ministry)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (ministry)-[:HAS_HISTORY]->(log)

      RETURN ministry
      """
    )
  CreateHub(name: String!, leaderId: ID!, ministryId: ID!, councilId: ID!): Hub
    @auth(
      rules: [
        {
          roles: [
            "adminCampus"
            "adminStream"
            "adminCreativeArts"
            "adminMinistry"
          ]
        }
      ]
    )
    @cypher(
      statement: """
      CREATE (hub:Hub {name: $name})
        SET hub.id = apoc.create.uuid()

      WITH hub
      CREATE (log:HistoryLog:ServiceLog)
        SET log.id = apoc.create.uuid(),
          log.timeStamp = datetime(),
          log.priority=0,
          log.historyRecord = hub.name +' hub history Begins'

      WITH hub, log
      MATCH (leader:Active:Member {id: $leaderId})  WHERE leader.email IS NOT NULL
      MATCH (currentUser:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (ministry:Ministry {id: $ministryId})
      MATCH (council:Council {id: $councilId})

      WITH hub, leader, ministry, currentUser, log, council
      MERGE (council)-[:HAS]->(hub)
      MERGE (ministry)-[:HAS]->(hub)
      MERGE (leader)-[:LEADS]->(hub)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (hub)-[:HAS_HISTORY]->(log)

      RETURN hub
      """
    )
}

extend type Mutation {
  UpdatecreativeArtDetails(
    creativeArtsId: ID!
    campusId: ID!
    creativeArtName: String!
  ): CreativeArts
    @auth(rules: [{ roles: ["adminCampus"] }])
    @cypher(
      statement: """
      MATCH (creativeArt:CreativeArts {id: $creativeArtsId})
      SET creativeArt.name = $creativeArtName

      WITH creativeArt
          CALL{
            WITH creativeArt

              MATCH (campus:Campus {id: $campusId})
              OPTIONAL MATCH (creativeArt)<-[r:HAS_MINISTRY]-()
              DELETE r
              MERGE (campus)-[:HAS_MINISTRY]->(creativeArt)

            RETURN count(creativeArt)
          }
      MATCH (creativeArt)<-[:LEADS]-(leader:Active:Member)
      RETURN creativeArt
      """
    )
  UpdateMinistryDetails(
    ministryId: ID!
    streamId: ID!
    ministryName: String!
    creativeArtsId: ID!
  ): Ministry
    @auth(
      rules: [{ roles: ["adminCampus", "adminStream", "adminCreativeArts"] }]
    )
    @cypher(
      statement: """
       MATCH (ministry:Ministry {id:$ministryId})
        SET ministry.name = $ministryName

        WITH ministry
          CALL {
            WITH ministry
              MATCH (stream:Stream {id:$streamId})
              MATCH (creativeArt:CreativeArts {id:$creativeArtsId})
              OPTIONAL MATCH (ministry)-[r:HAS]->()
              DELETE r
              MERGE (stream)-[:HAS]->(ministry)
              MERGE (creativeArt)-[:HAS]->(ministry)
            RETURN COUNT(ministry)
          }
      MATCH (ministry)<-[:LEADS]-(leader:Active:Member)
      RETURN ministry
      """
    )
  UpdateHubDetails(hubId: ID!, ministryId: ID!, hubName: String!): Hub
    @auth(
      rules: [
        {
          roles: [
            "adminCampus"
            "adminStream"
            "adminCreativeArts"
            "adminMinistry"
          ]
        }
      ]
    )
    @cypher(
      statement: """
      MATCH (hub:Hub {id:$hubId})
        set hub.name = $hubName

        WITH hub
          CALL {
            WITH hub
              MATCH (ministry:Ministry {id:$ministryId})
              OPTIONAL MATCH (ministry)<-[r:HAS]-()
              DELETE r
              MERGE (ministry)-[:HAS]->(hub)
            RETURN COUNT(hub)
          }
      MATCH (hub)<-[:LEADS]-(leader:Active:Member)
      RETURN hub
      """
    )

  #Set Fellowship to be 'HubFellowship'
  SetActiveFellowshipToHubFellowship(
    fellowshipId: ID!
    hubId: ID!
    ministryId: ID!
  ): Fellowship
    @cypher(
      statement: """
      MATCH (fellowship:Active:Fellowship {id:$fellowshipId})
      MATCH (hub:Hub {id: $hubId})
      MATCH (ministry:Ministry {id:$ministryId})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = fellowship.name + ' Fellowship was made into a hub fellowship for' + ministry.name

      WITH log,fellowship, hub
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MERGE (hub)-[:HAS]->(fellowship)
      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (fellowship)-[:HAS_HISTORY]->(log)

      SET fellowship:HubFellowship

      RETURN fellowship
      """
    )

  SetHubFellowshipToFellowship(fellowshipId: ID!, hubId: ID!): Fellowship
    @auth(
      rules: [
        {
          roles: [
            "adminCampus"
            "adminStream"
            "adminCreativeArts"
            "adminMinistry"
          ]
        }
      ]
    )
    @cypher(
      statement: """
      MATCH (fellowship:Active:HubFellowship {id:$fellowshipId})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = fellowship.name + ' hub Fellowship was made into a fellowship '

      WITH log,fellowship
      WITH fellowship
        CALL {
          WITH fellowship
          MATCH (hub:Hub {id: $hubId})
          OPTIONAL MATCH (fellowship)-[r:HAS]-(hub)
          DELETE r
          RETURN COUNT(fellowship)
        }
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (fellowship)-[:HAS_HISTORY]->(log)

      REMOVE fellowship:HubFellowship

      RETURN fellowship
      """
    )
}

## DELETE OPERATIONS

extend type Mutation {
  CloseDownCreativeArts(creativeArtsId: ID!, leaderId: ID!): Campus
    @cypher(
      statement: """
      MATCH (creativeArt:CreativeArts {id:$creativeArtsId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (creativeArt)<-[:HAS]-(campus:Campus)

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timestamp = datetime()
        SET log.historyRecord = creativeArt.name + ' creative art was closed down under' + campus.name +' gathering service'

      OPTIONAL MATCH (creativeArt)-[:HAS]->(ministry)-[:HAS]->(hub)-[:HAS]->(fellowships)

      MERGE (date:Timegraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (campus)-[:HAS_HISTORY]->(log)

      SET creativeArt:ClosedCreativeArts, ministry:ClosedMinistry, hub:ClosedHub
      REMOVE creativeArt:CreativeArts, ministry:Ministry, hub:Hub, fellowships:HubFellowship
      RETURN campus
      """
    )
  closeDownMinistry(ministryId: ID!, leaderId: ID!): CreativeArts
    @cypher(
      statement: """
      MATCH (ministry:Ministry {id:$ministryId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (ministry)<-[:HAS]-(creativeArt:CreativeArts)

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timestamp = datetime()
        SET log.historyRecord = ministry.name + ' ministry was closed down under' + creativeArt.name +' ministry'

      OPTIONAL MATCH (ministry)-[:HAS]->(hub)-[:HAS]->(fellowships)

      MERGE (date:Timegraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (creativeArt)-[:HAS_HISTORY]->(log)

      SET ministry:ClosedMinistry, hub:ClosedHub
      REMOVE ministry:Ministry, hub:Hub, fellowships:HubFellowship
      RETURN creativeArt
      """
    )
  closeDownHub(hubId: ID!, leaderId: ID!): Ministry
    @cypher(
      statement: """
      MATCH (hub:Hub {id:$hubId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (hub)<-[:HAS]-(ministry:Ministry)

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timestamp = datetime()
        SET log.historyRecord = hub.name + ' hub was closed down under ' + ministry.name +' ministry'

      WITH hub, ministry, log
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      OPTIONAL MATCH (hub)-[:HAS]->(fellowships)

      MERGE (date:Timegraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (ministry)-[:HAS_HISTORY]->(log)

      SET hub:ClosedHub
      REMOVE hub:Hub, fellowships:HubFellowship
      RETURN ministry
      """
    )
}

extend type Mutation {
  MakeCreativeArtsLeader(
    leaderId: ID!
    creativeArtsId: ID!
    oldLeaderId: ID
  ): Member!
  RemoveCreativeArtsLeader(
    leaderId: ID!
    creativeArtsId: ID!
    newLeaderId: ID!
  ): Member!
  MakeMinistryLeader(leaderId: ID!, ministryId: ID!, oldLeaderId: ID): Member!
  RemoveMinistryLeader(
    leaderId: ID!
    ministryId: ID!
    newLeaderId: ID!
  ): Member!
  MakeHubLeader(leaderId: ID!, hubId: ID!, oldLeaderId: ID): Member!
  RemoveHubLeader(leaderId: ID!, hubId: ID!, newLeaderId: ID!): Member!
}

type MinistryAttendanceRecord implements Record
  @auth(rules: [{ isAuthenticated: true }]) {
  id: ID!
  createdAt: DateTime!
  created_by: Member
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
    )
  attendance: Int
  familyPicture: String
  serviceLog: ServiceLog! @relationship(type: "HAS_SERVICE", direction: IN)
  noServiceReason: String
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(church)
      WHERE church:HubFellowship
      MATCH (church)<-[:HAS*1..4]-(stream:Stream)
      RETURN stream.name
      """
    )
}

type RehearsalRecord implements Record
  @auth(rules: [{ isAuthenticated: true }]) {
  id: ID!
  createdAt: DateTime!
  created_by: Member
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
    )
  attendance: Int
  familyPicture: String
  serviceLog: ServiceLog! @relationship(type: "HAS_SERVICE", direction: IN)
  noServiceReason: String
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(church)
      WHERE church:HubFellowship
      MATCH (church)<-[:HAS*1..4]-(stream:Stream)
      RETURN stream.name
      """
    )
}

extend type Mutation {
  RecordHubFellowshipSundayAttendance(
    churchId: ID!
    serviceDate: String!
    attendance: Int!
    familyPicture: String!
  ): MinistryAttendanceRecord!

  RecordHubRehearsalService(
    churchId: ID!
    serviceDate: String!
    attendance: Int!
    familyPicture: String!
  ): RehearsalRecord!
}
