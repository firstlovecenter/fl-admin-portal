extend type Member {
  leadscreativeArt: [CreativeArts!]!
    @relationship(type: "LEADS", direction: OUT)
  leadsHub: [Hub!]! @relationship(type: "LEADS", direction: OUT)
  leadsHubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(fellowships:HubFellowship:Fellowship)
      RETURN COUNT(fellowships)
      """
    )
  leadsHubCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(hubs:Hub)
      RETURN COUNT(hubs)
      """
    )
  leadsMinistryCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(ministries:Ministry)
      RETURN COUNT(ministries)
      """
    )
  isAdminForMinistryCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:IS_ADMIN_FOR]->(ministries:Ministry)
      RETURN COUNT (ministries)
      """
    )
  leadsAdminsMinistryCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|IS_ADMIN_FOR]->(ministries:Ministry)
      RETURN COUNT(ministries)
      """
    )
  leadscreativeArtCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(creativeArts:CreativeArts)
      RETURN COUNT(creativeArts)
      """
    )
  isAdminForcreativeArtCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:IS_ADMIN_FOR]->(creativeArts:CreativeArts)
      RETURN COUNT (creativeArts)
      """
    )
  leadsAdminsCreativeArtsCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|IS_ADMIN_FOR]->(creativeArts:CreativeArts)
      RETURN COUNT(creativeArts)
      """
    )
  isAdminForMinistry: [Ministry!]!
    @relationship(type: "IS_ADMIN_FOR", direction: OUT)

  isAdminForCreativeArts: [CreativeArts!]!
    @relationship(type: "IS_ADMIN_FOR", direction: OUT)
}

type CreativeArts {
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Ministry)-[:HAS]->(:Hub)-[:HAS]->(:HubFellowship)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)
      """
    )
  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(ministry:Ministry)-[:HAS]->(:Hub)-[:HAS]->(:HubFellowship)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  hubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:HubFellowship:Fellowship)
      RETURN COUNT(DISTINCT fellowships)
      """
    )
  hubCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(hubs:Hub)
      RETURN COUNT(DISTINCT hubs)
      """
    )
  ministryCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(ministries:Ministry)
      RETURN COUNT(DISTINCT ministries)
      """
    )
  id: ID @id
  name: String!
  leader: Member @relationship(type: "LEADS", direction: IN)
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  campus: Campus @relationship(type: "HAS_MINISTRY", direction: IN)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC LIMIT $limit"
    )
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  ministries: [Ministry!]! @relationship(type: "HAS", direction: OUT)
}

type Ministry {
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Hub)-[:HAS]->(:HubFellowship)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)
      """
    )
  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Hub)-[:HAS]->(:HubFellowship)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  hubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:HubFellowship:Fellowship)
      RETURN COUNT(DISTINCT fellowships)
      """
    )
  hubCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(hubs:Hub)
      RETURN COUNT(DISTINCT hubs)
      """
    )
  id: ID @id
  name: String!
  leader: Member @relationship(type: "LEADS", direction: IN)
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  hubs: [Hub!]! @relationship(type: "HAS", direction: OUT)
  stream: Stream @relationship(type: "HAS_MINISTRY", direction: IN)
  history: [HistoryLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  servicelogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  creativeArts: CreativeArts @relationship(type: "HAS", direction: IN)
  councils: [Council!]!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_MINISTRY]-(stream:Stream)-[:HAS]->(councils:Council)
      RETURN councils
      """
    )
  hubFellowships: [Fellowship!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowship:HubFellowship:Fellowship)
      RETURN fellowship
      """
    )
}

type Hub {
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(hubFellowship:Active:HubFellowship)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)
      """
    )
  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(hubFellowship:Active:HubFellowship)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  hubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(fellowships:Active:HubFellowship)
      RETURN COUNT(DISTINCT fellowships)
      """
    )
  id: ID! @id
  name: String!
  leader: Member @relationship(type: "LEADS", direction: IN)
  history: [HistoryLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  hubFellowships: [Fellowship!]! @relationship(type: "HAS", direction: OUT)
  ministry: Ministry @relationship(type: "HAS", direction: IN)
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  rehearsals(limit: Int!, skip: Int = 0): [RehearsalRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(records:RehearsalRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records,date
      RETURN records ORDER BY date.date DESC SKIP $skip LIMIT $limit
      """
    )
}

extend type Stream {
  ministryCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(ministry:Ministry)
      RETURN COUNT(ministry)
      """
    )
  hubCount: Int!
    @cypher(
      statement: "MATCH (this)-[:HAS_MINISTRY]->(ministry:Ministry)-[:HAS]->(hubs:Hub) RETURN COUNT(hubs)"
    )
  hubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(:Ministry)-[:HAS]->(:Hub)-[:HAS]->(hubFellowships:HubFellowship)
      RETURN COUNT(hubFellowships)
      """
    )

  hubFellowshipCount: Int!
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(fellowships:HubFellowship) RETURN COUNT(fellowships)"
    )
  hubFellowships: [Fellowship!]!
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(fellowships:HubFellowship) RETURN fellowships"
    )
  hubs: [Hub!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_MINISTRY]->(ministry:Ministry)-[HAS]->(hubs:Hub) RETURN hubs"
    )
}

extend type Council {
  hubs: [Hub!]! @relationship(type: "HAS_MINISTRY", direction: OUT)
  hubsFromMinistry(ministryId: ID!): [Hub!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(hubs:Hub)<-[:HAS]-(ministry:Ministry {id:$ministryId})
      RETURN hubs
      """
    )
  hubCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(hubs:Hub)
      RETURN COUNT(hubs)
      """
    )
  hubFellowshipCount: Int!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_MINISTRY]->(:Hub)-[:HAS]->(fellowship:HubFellowship)
      RETURN COUNT(fellowship)
      """
    )
}

extend type Fellowship {
  hub: Hub @relationship(type: "HAS", direction: IN)
  councilHubs: [Hub!]!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS]-(:Bacenta)<-[:HAS]-(:Constituency)<-[:HAS]-(council:Council)
      MATCH (council)-[:HAS_MINISTRY]->(hub:Hub)
      RETURN hub
      """
    )
}

type HubFellowship implements Church {
  id: ID @id
  bankingCode: Int
  name: String!
  location: Point
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*4]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  vacationStatus: String!
    @cypher(
      statement: """
      MATCH (this)
      UNWIND labels(this) AS status
      WITH status WHERE status = 'Active' OR status = 'Vacation' OR status = 'Online'
      RETURN status
      """
    )
  bacenta: Bacenta @relationship(type: "HAS", direction: IN)
  leader: Member @relationship(type: "LEADS", direction: IN)
  members: [Member!]!
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN DISTINCT members ORDER BY toLower(members.lastName), toLower(members.firstName)
      """
    )
  memberCount: Int!
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  ministryMemberCount: Int
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Active:Member)-[:BELONGS_TO]->(:Ministry)
      RETURN COUNT(DISTINCT members)
      """
    )
  pastorCount: Int
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(pastors:Active:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
    )
  meetingDay: ServiceDay @relationship(type: "MEETS_ON", direction: OUT)
  history(limit: Int! = 3): [HistoryLog!]!
    @cypher(
      statement: "MATCH (this)-[:HAS_HISTORY|OLD_HISTORY]->(log:HistoryLog) RETURN log ORDER BY log.timeStamp DESC LIMIT $limit"
    )
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!, skip: Int): [ServiceRecord!]!
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_SERVICE]->(records:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      WITH DISTINCT records,date
      RETURN records ORDER BY date.date DESC LIMIT $limit
      """
    )
  labels: [String]
    @cypher(
      statement: """
      MATCH (this)
      RETURN labels(this)
      """
    )

  council: Council
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*3]-(council:Council)
      RETURN council
      """
    )
  hub: [Hub!]! @relationship(type: "HAS", direction: IN)
}

extend type Mutation {
  CreateCreativeArts(
    name: String!
    leaderId: ID!
    campusId: ID!
  ): CreativeArts!
    @auth(rules: [{ roles: ["adminCampus"] }])
    @cypher(
      statement: """
      CREATE (creativeArt:CreativeArts {name:$name})
        SET creativeArt.id = apoc.create.uuid()

      WITH creativeArt
      MATCH (leader:Member:Active {id:$leaderId}) WHERE leader.email IS NOT NULL
      MATCH (campus:Campus {id:$campusId})
      MATCH (currentUser:Active:Member {auth_id:$auth.jwt.sub})

      CREATE (log:HistoryLog:ServiceLog)
        SET log.id = apoc.create.uuid(),
          log.timeStamp = datetime(),
          log.priority=0,
          log.historyRecord = creativeArt.name +' Creative Art Ministry History Begins'

      MERGE (leader)-[:LEADS]->(creativeArt)
      MERGE (campus)-[:HAS_MINISTRY]->(creativeArt)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (creativeArt)-[:HAS_HISTORY]->(log)

      RETURN creativeArt
      """
    )
  CreateMinistry(leaderId: ID!, streamId: ID!, creativeArtsId: ID!): Ministry!
    @auth(
      rules: [{ roles: ["adminCampus", "adminStream", "adminCreativeArts"] }]
    )
    @cypher(
      statement: """
      CREATE (ministry:Ministry)
        SET	ministry.id = apoc.create.uuid()

      WITH ministry
      MATCH (leader:Active:Member {id: $leaderId}) WHERE leader.email IS NOT NULL
      MATCH (stream:Stream {id: $streamId})
      MATCH (creativeArt:CreativeArts {id: $creativeArtsId})
      MATCH (currentUser:Active:Member {auth_id: $auth.jwt.sub})
        SET ministry.name = stream.name + ' ' +  creativeArt.name

      WITH ministry, stream, leader, creativeArt, currentUser
      CREATE (log:HistoryLog:ServiceLog)
        SET log.id = apoc.create.uuid(),
          log.timeStamp = datetime(),
          log.priority=0,
          log.historyRecord = ministry.name +' Ministry History Begins'

      WITH ministry, stream, leader, creativeArt, currentUser, log
      MERGE (stream)-[:HAS_MINISTRY]->(ministry)
      MERGE (leader)-[:LEADS]->(ministry)
      MERGE (creativeArt)-[:HAS]->(ministry)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (ministry)-[:HAS_HISTORY]->(log)

      RETURN ministry
      """
    )
  CreateHub(
    name: String!
    leaderId: ID!
    ministryId: ID!
    councilId: ID!
  ): Hub!
    @auth(
      rules: [
        {
          roles: [
            "adminCampus"
            "adminStream"
            "adminCreativeArts"
            "adminMinistry"
          ]
        }
      ]
    )
    @cypher(
      statement: """
      CREATE (hub:Hub {name: $name})
        SET hub.id = apoc.create.uuid()

      WITH hub
      CREATE (log:HistoryLog:ServiceLog)
        SET log.id = apoc.create.uuid(),
          log.timeStamp = datetime(),
          log.priority=0,
          log.historyRecord = hub.name +' hub history Begins'

      WITH hub, log
      MATCH (leader:Active:Member {id: $leaderId})  WHERE leader.email IS NOT NULL
      MATCH (currentUser:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (ministry:Ministry {id: $ministryId})
      MATCH (council:Council {id: $councilId})

      WITH hub, leader, ministry, currentUser, log, council
      MERGE (council)-[:HAS_MINISTRY]->(hub)
      MERGE (ministry)-[:HAS]->(hub)
      MERGE (leader)-[:LEADS]->(hub)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (hub)-[:HAS_HISTORY]->(log)

      RETURN hub
      """
    )
}

extend type Mutation {
  UpdateCreativeArtsDetails(
    creativeArtsId: ID!
    campusId: ID!
    name: String!
  ): CreativeArts!
    @auth(rules: [{ roles: ["adminCampus"] }])
    @cypher(
      statement: """
      MATCH (creativeArt:CreativeArts {id: $creativeArtsId})
        SET creativeArt.name = $name

      WITH creativeArt
      CALL{
        WITH creativeArt
        WITH creativeArt WHERE $campusId IS NOT NULL

          MATCH (campus:Campus {id: $campusId})
          OPTIONAL MATCH (creativeArt)<-[r:HAS_MINISTRY]-()
          DELETE r
          MERGE (campus)-[:HAS_MINISTRY]->(creativeArt)

        RETURN count(creativeArt)
      }

      RETURN creativeArt
      """
    )
  UpdateMinistryDetails(
    ministryId: ID!
    streamId: ID!
    ministryName: String!
    creativeArtsId: ID!
  ): Ministry!
    @auth(
      rules: [{ roles: ["adminCampus", "adminStream", "adminCreativeArts"] }]
    )
    @cypher(
      statement: """
       MATCH (ministry:Ministry {id:$ministryId})
        SET ministry.name = $ministryName

        WITH ministry
          CALL {
            WITH ministry
              MATCH (stream:Stream {id:$streamId})
              MATCH (creativeArt:CreativeArts {id:$creativeArtsId})
              OPTIONAL MATCH (ministry)-[r:HAS]->()
              DELETE r
              MERGE (stream)-[:HAS_MINISTRY]->(ministry)
              MERGE (creativeArt)-[:HAS]->(ministry)
            RETURN COUNT(ministry)
          }
      MATCH (ministry)<-[:LEADS]-(leader:Active:Member)
      RETURN ministry
      """
    )
  UpdateHubDetails(hubId: ID!, ministryId: ID!, hubName: String!): Hub!
    @auth(
      rules: [
        {
          roles: [
            "adminCampus"
            "adminStream"
            "adminCreativeArts"
            "adminMinistry"
          ]
        }
      ]
    )
    @cypher(
      statement: """
      MATCH (hub:Hub {id:$hubId})
        set hub.name = $hubName

        WITH hub
          CALL {
            WITH hub
              MATCH (ministry:Ministry {id:$ministryId})
              OPTIONAL MATCH (ministry)<-[r:HAS]-()
              DELETE r
              MERGE (ministry)-[:HAS]->(hub)
            RETURN COUNT(hub)
          }
      MATCH (hub)<-[:LEADS]-(leader:Active:Member)
      RETURN hub
      """
    )

  #Set Fellowship to be 'HubFellowship'
  SetFellowshipToHubFellowship(fellowshipId: ID!, hubId: ID!): Fellowship!
    @cypher(
      statement: """
      MATCH (fellowship:Active:Fellowship {id:$fellowshipId})
      MATCH (hub:Hub {id: $hubId})<-[:HAS]-(ministry:Ministry)

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = fellowship.name + ' Fellowship was made into a hub fellowship for ' + ministry.name

      WITH log,fellowship, hub
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MERGE (hub)-[:HAS]->(fellowship)
      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (fellowship)-[:HAS_HISTORY]->(log)
      MERGE (hub)-[:HAS_HISTORY]->(log)

      SET fellowship:HubFellowship

      RETURN fellowship
      """
    )

  SetHubFellowshipToRegularFellowship(fellowshipId: ID!): Fellowship!
    @auth(
      rules: [
        {
          roles: [
            "adminCampus"
            "adminStream"
            "adminCreativeArts"
            "adminMinistry"
          ]
        }
      ]
    )
    @cypher(
      statement: """
      MATCH (fellowship:Active:HubFellowship {id: $fellowshipId})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = fellowship.name + ' hub fellowship was made into a regular fellowship '

      WITH log,fellowship

      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (fellowship)<-[r:HAS]-(hub:Hub)
      DELETE r

      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (fellowship)-[:HAS_HISTORY]->(log)
      MERGE (hub)-[:HAS_HISTORY]->(log)

      REMOVE fellowship:HubFellowship

      RETURN fellowship
      """
    )
}

## DELETE OPERATIONS

extend type Mutation {
  CloseDownCreativeArts(creativeArtsId: ID!, leaderId: ID!): Campus!
    @cypher(
      statement: """
      MATCH (creativeArt:CreativeArts {id:$creativeArtsId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (creativeArt)<-[:HAS]-(campus:Campus)

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timestamp = datetime()
        SET log.priority = 0
        SET log.historyRecord = creativeArt.name + ' creative art was closed down under' + campus.name +' gathering service'

      OPTIONAL MATCH (creativeArt)-[:HAS]->(ministry)-[:HAS]->(hub)-[:HAS]->(fellowships)

      MERGE (date:Timegraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (campus)-[:HAS_HISTORY]->(log)

      SET creativeArt:ClosedCreativeArts, ministry:ClosedMinistry, hub:ClosedHub
      REMOVE creativeArt:CreativeArts, ministry:Ministry, hub:Hub, fellowships:HubFellowship
      RETURN campus
      """
    )
  CloseDownMinistry(ministryId: ID!, leaderId: ID!): CreativeArts!
    @cypher(
      statement: """
      MATCH (ministry:Ministry {id:$ministryId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (ministry)<-[:HAS]-(creativeArt:CreativeArts)

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timestamp = datetime()
        SET log.priority = 0
        SET log.historyRecord = ministry.name + ' ministry was closed down under' + creativeArt.name +' ministry'

      OPTIONAL MATCH (ministry)-[:HAS]->(hub)-[:HAS]->(fellowships)

      MERGE (date:Timegraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (creativeArt)-[:HAS_HISTORY]->(log)

      SET ministry:ClosedMinistry, hub:ClosedHub
      REMOVE ministry:Ministry, hub:Hub, fellowships:HubFellowship
      RETURN creativeArt
      """
    )
  CloseDownHub(hubId: ID!, leaderId: ID!): Ministry!
    @cypher(
      statement: """
      MATCH (hub:Hub {id:$hubId})
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      MATCH (hub)<-[:HAS]-(ministry:Ministry)

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timestamp = datetime()
        SET log.priority = 0
        SET log.historyRecord = hub.name + ' hub was closed down under ' + ministry.name +' ministry'

      WITH hub, ministry, log
      MATCH (admin:Active:Member {auth_id: $auth.jwt.sub})
      OPTIONAL MATCH (hub)-[:HAS]->(fellowships)

      MERGE (date:Timegraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (ministry)-[:HAS_HISTORY]->(log)

      SET hub:ClosedHub
      REMOVE hub:Hub, fellowships:HubFellowship
      RETURN ministry
      """
    )
}

extend type Mutation {
  MakeCreativeArtsLeader(
    leaderId: ID!
    creativeArtsId: ID!
    oldLeaderId: ID
  ): Member!
  RemoveCreativeArtsLeader(
    leaderId: ID!
    creativeArtsId: ID!
    newLeaderId: ID!
  ): Member
  MakeMinistryLeader(leaderId: ID!, ministryId: ID!, oldLeaderId: ID): Member!
  RemoveMinistryLeader(leaderId: ID!, ministryId: ID!, newLeaderId: ID!): Member
  MakeHubLeader(leaderId: ID!, hubId: ID!, oldLeaderId: ID): Member!
  RemoveHubLeader(leaderId: ID!, hubId: ID!, newLeaderId: ID!): Member
  MakeCreativeArtsAdmin(
    adminId: ID!
    creativeArtsId: ID!
    oldAdminId: ID
  ): Member!
  RemoveCreativeArtsAdmin(
    adminId: ID!
    creativeArtsId: ID!
    newAdminId: ID!
  ): Member
  MakeMinistryAdmin(adminId: ID!, ministryId: ID!, oldAdminId: ID): Member!
  RemoveMinistryAdmin(adminId: ID!, ministryId: ID!, newAdminId: ID!): Member
}

type MinistryAttendanceRecord implements Record
  @auth(rules: [{ isAuthenticated: true }]) {
  id: ID!
  createdAt: DateTime!
  created_by: Member
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
    )
  attendance: Int
  familyPicture: String
  serviceLog: ServiceLog! @relationship(type: "HAS_SERVICE", direction: IN)
  noServiceReason: String
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(church)
      WHERE church:HubFellowship
      MATCH (church)<-[:HAS*1..4]-(stream:Stream)
      RETURN stream.name
      """
    )
}

type RehearsalRecord implements Record
  @auth(rules: [{ isAuthenticated: true }]) {
  id: ID!
  createdAt: DateTime!
  created_by: Member
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
    )
  attendance: Int
  familyPicture: String
  serviceLog: ServiceLog! @relationship(type: "HAS_SERVICE", direction: IN)
  noServiceReason: String
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_SERVICE]-(:ServiceLog)<-[:HAS_HISTORY]-(church)
      WHERE church:HubFellowship
      MATCH (church)<-[:HAS*1..4]-(stream:Stream)
      RETURN stream.name
      """
    )
}

extend type Mutation {
  RecordHubFellowshipSundayAttendance(
    churchId: ID!
    serviceDate: String!
    attendance: Int!
    familyPicture: String!
  ): MinistryAttendanceRecord!

  RecordHubRehearsalService(
    churchId: ID!
    serviceDate: String!
    attendance: Int!
    familyPicture: String!
  ): RehearsalRecord!
}
